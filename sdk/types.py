#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Nov 18 23:21:56 2018 by generateDS.py version 2.30.5.
# Python 3.6.6 (default, Jul 19 2018, 14:25:17)  [GCC 8.1.1 20180712 (Red Hat 8.1.1-5)]
#
# Command line options:
#   ('-o', 'types.py')
#   ('--subclass-suffix', '--super=types')
#   ('-s', 'subclasses.py')
#   ('--no-namespace-defs', '')
#   ('-f', '')
#   ('-m', '')
#   ('--export', 'write')
#   ('--disable-generatedssuper-lookup', '')
#
# Command line arguments:
#   ./api.xsd
#
# Command line:
#   ./generateDS.py -o "types.py" --subclass-suffix="--super=types" -s "subclasses.py" --no-namespace-defs -f -m --export="write" --disable-generatedssuper-lookup ./api.xsd
#
# Current working directory (os.getcwd()):
#   sdk
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.


class GeneratedsSuper(object):
    tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
    class _FixedOffsetTZ(datetime_.tzinfo):
        def __init__(self, offset, name):
            self.__offset = datetime_.timedelta(minutes=offset)
            self.__name = name
        def utcoffset(self, dt):
            return self.__offset
        def tzname(self, dt):
            return self.__name
        def dst(self, dt):
            return None
    def gds_format_string(self, input_data, input_name=''):
        return input_data
    def gds_validate_string(self, input_data, node=None, input_name=''):
        if not input_data:
            return ''
        else:
            return input_data
    def gds_format_base64(self, input_data, input_name=''):
        return base64.b64encode(input_data)
    def gds_validate_base64(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_integer(self, input_data, input_name=''):
        return '%d' % input_data
    def gds_validate_integer(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_integer_list(self, input_data, input_name=''):
        return '%s' % ' '.join(input_data)
    def gds_validate_integer_list(
            self, input_data, node=None, input_name=''):
        values = input_data.split()
        for value in values:
            try:
                int(value)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires sequence of integers')
        return values
    def gds_format_float(self, input_data, input_name=''):
        return ('%.15f' % input_data).rstrip('0')
    def gds_validate_float(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_float_list(self, input_data, input_name=''):
        return '%s' % ' '.join(input_data)
    def gds_validate_float_list(
            self, input_data, node=None, input_name=''):
        values = input_data.split()
        for value in values:
            try:
                float(value)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires sequence of floats')
        return values
    def gds_format_double(self, input_data, input_name=''):
        return '%e' % input_data
    def gds_validate_double(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_double_list(self, input_data, input_name=''):
        return '%s' % ' '.join(input_data)
    def gds_validate_double_list(
            self, input_data, node=None, input_name=''):
        values = input_data.split()
        for value in values:
            try:
                float(value)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires sequence of doubles')
        return values
    def gds_format_boolean(self, input_data, input_name=''):
        return ('%s' % input_data).lower()
    def gds_validate_boolean(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_boolean_list(self, input_data, input_name=''):
        return '%s' % ' '.join(input_data)
    def gds_validate_boolean_list(
            self, input_data, node=None, input_name=''):
        values = input_data.split()
        for value in values:
            if value not in ('true', '1', 'false', '0', ):
                raise_parse_error(
                    node,
                    'Requires sequence of booleans '
                    '("true", "1", "false", "0")')
        return values
    def gds_validate_datetime(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_datetime(self, input_data, input_name=''):
        if input_data.microsecond == 0:
            _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
                input_data.hour,
                input_data.minute,
                input_data.second,
            )
        else:
            _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                input_data.year,
                input_data.month,
                input_data.day,
                input_data.hour,
                input_data.minute,
                input_data.second,
                ('%f' % (float(input_data.microsecond) / 1000000))[2:],
            )
        if input_data.tzinfo is not None:
            tzoff = input_data.tzinfo.utcoffset(input_data)
            if tzoff is not None:
                total_seconds = tzoff.seconds + (86400 * tzoff.days)
                if total_seconds == 0:
                    _svalue += 'Z'
                else:
                    if total_seconds < 0:
                        _svalue += '-'
                        total_seconds *= -1
                    else:
                        _svalue += '+'
                    hours = total_seconds // 3600
                    minutes = (total_seconds - (hours * 3600)) // 60
                    _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
        return _svalue
    @classmethod
    def gds_parse_datetime(cls, input_data):
        tz = None
        if input_data[-1] == 'Z':
            tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
            input_data = input_data[:-1]
        else:
            results = GeneratedsSuper.tzoff_pattern.search(input_data)
            if results is not None:
                tzoff_parts = results.group(2).split(':')
                tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                if results.group(1) == '-':
                    tzoff *= -1
                tz = GeneratedsSuper._FixedOffsetTZ(
                    tzoff, results.group(0))
                input_data = input_data[:-6]
        time_parts = input_data.split('.')
        if len(time_parts) > 1:
            micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
            input_data = '%s.%s' % (
                time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
            dt = datetime_.datetime.strptime(
                input_data, '%Y-%m-%dT%H:%M:%S.%f')
        else:
            dt = datetime_.datetime.strptime(
                input_data, '%Y-%m-%dT%H:%M:%S')
        dt = dt.replace(tzinfo=tz)
        return dt
    def gds_validate_date(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_date(self, input_data, input_name=''):
        _svalue = '%04d-%02d-%02d' % (
            input_data.year,
            input_data.month,
            input_data.day,
        )
        try:
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(
                            hours, minutes)
        except AttributeError:
            pass
        return _svalue
    @classmethod
    def gds_parse_date(cls, input_data):
        tz = None
        if input_data[-1] == 'Z':
            tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
            input_data = input_data[:-1]
        else:
            results = GeneratedsSuper.tzoff_pattern.search(input_data)
            if results is not None:
                tzoff_parts = results.group(2).split(':')
                tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                if results.group(1) == '-':
                    tzoff *= -1
                tz = GeneratedsSuper._FixedOffsetTZ(
                    tzoff, results.group(0))
                input_data = input_data[:-6]
        dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
        dt = dt.replace(tzinfo=tz)
        return dt.date()
    def gds_validate_time(self, input_data, node=None, input_name=''):
        return input_data
    def gds_format_time(self, input_data, input_name=''):
        if input_data.microsecond == 0:
            _svalue = '%02d:%02d:%02d' % (
                input_data.hour,
                input_data.minute,
                input_data.second,
            )
        else:
            _svalue = '%02d:%02d:%02d.%s' % (
                input_data.hour,
                input_data.minute,
                input_data.second,
                ('%f' % (float(input_data.microsecond) / 1000000))[2:],
            )
        if input_data.tzinfo is not None:
            tzoff = input_data.tzinfo.utcoffset(input_data)
            if tzoff is not None:
                total_seconds = tzoff.seconds + (86400 * tzoff.days)
                if total_seconds == 0:
                    _svalue += 'Z'
                else:
                    if total_seconds < 0:
                        _svalue += '-'
                        total_seconds *= -1
                    else:
                        _svalue += '+'
                    hours = total_seconds // 3600
                    minutes = (total_seconds - (hours * 3600)) // 60
                    _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
        return _svalue
    def gds_validate_simple_patterns(self, patterns, target):
        # pat is a list of lists of strings/patterns.
        # The target value must match at least one of the patterns
        # in order for the test to succeed.
        found1 = True
        for patterns1 in patterns:
            found2 = False
            for patterns2 in patterns1:
                mo = re_.search(patterns2, target)
                if mo is not None and len(mo.group(0)) == len(target):
                    found2 = True
                    break
            if not found2:
                found1 = False
                break
        return found1
    @classmethod
    def gds_parse_time(cls, input_data):
        tz = None
        if input_data[-1] == 'Z':
            tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
            input_data = input_data[:-1]
        else:
            results = GeneratedsSuper.tzoff_pattern.search(input_data)
            if results is not None:
                tzoff_parts = results.group(2).split(':')
                tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                if results.group(1) == '-':
                    tzoff *= -1
                tz = GeneratedsSuper._FixedOffsetTZ(
                    tzoff, results.group(0))
                input_data = input_data[:-6]
        if len(input_data.split('.')) > 1:
            dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
        else:
            dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
        dt = dt.replace(tzinfo=tz)
        return dt.time()
    def gds_str_lower(self, instring):
        return instring.lower()
    def get_path_(self, node):
        path_list = []
        self.get_path_list_(node, path_list)
        path_list.reverse()
        path = '/'.join(path_list)
        return path
    Tag_strip_pattern_ = re_.compile(r'\{.*\}')
    def get_path_list_(self, node, path_list):
        if node is None:
            return
        tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
        if tag:
            path_list.append(tag)
        self.get_path_list_(node.getparent(), path_list)
    def get_class_obj_(self, node, default_class=None):
        class_obj1 = default_class
        if 'xsi' in node.nsmap:
            classname = node.get('{%s}type' % node.nsmap['xsi'])
            if classname is not None:
                names = classname.split(':')
                if len(names) == 2:
                    classname = names[1]
                class_obj2 = globals().get(classname)
                if class_obj2 is not None:
                    class_obj1 = class_obj2
        return class_obj1
    def gds_build_any(self, node, type_name=None):
        return None
    @classmethod
    def gds_reverse_node_mapping(cls, mapping):
        return dict(((v, k) for k, v in mapping.items()))
    @staticmethod
    def gds_encode(instring):
        if sys.version_info.major == 2:
            if ExternalEncoding:
                encoding = ExternalEncoding
            else:
                encoding = 'utf-8'
            return instring.encode(encoding)
        else:
            return instring
    @staticmethod
    def convert_unicode(instring):
        if isinstance(instring, str):
            result = quote_xml(instring)
        elif sys.version_info.major == 2 and isinstance(instring, unicode):
            result = quote_xml(instring).encode('utf8')
        else:
            result = GeneratedsSuper.gds_encode(str(instring))
        return result
    def __eq__(self, other):
        if type(self) != type(other):
            return False
        return self.__dict__ == other.__dict__
    def __ne__(self, other):
        return not self.__eq__(other)

def getSubclassFromModule_(module, class_):
    '''Get the subclass of a class from a specific module.'''
    name = class_.__name__ + '--super=types'
    if hasattr(module, name):
        return getattr(module, name)
    else:
        return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class HttpMethod(object):
    GET='GET'
    POST='POST'
    PUT='PUT'
    DELETE='DELETE'
    OPTIONS='OPTIONS'


class StatisticType(object):
    GAUGE='GAUGE'
    COUNTER='COUNTER'


class StatisticUnit(object):
    NONE='NONE'
    PERCENT='PERCENT'
    BYTES='BYTES'
    SECONDS='SECONDS'
    BYTES_PER_SECOND='BYTES_PER_SECOND'
    BITS_PER_SECOND='BITS_PER_SECOND'
    COUNT_PER_SECOND='COUNT_PER_SECOND'


class ValueType(object):
    INTEGER='INTEGER'
    DECIMAL='DECIMAL'
    STRING='STRING'


class KeyValuePair(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, key=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.key = key
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyValuePair)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyValuePair.subclass:
            return KeyValuePair.subclass(*args_, **kwargs_)
        else:
            return KeyValuePair(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    keyProp = property(get_key, set_key)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def hasContent_(self):
        if (
            self.key is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='keyValuePair', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('keyValuePair')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='keyValuePair')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='keyValuePair', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='keyValuePair'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='keyValuePair', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey>%s</%skey>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.key), input_name='key')), namespaceprefix_ , eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'key':
            key_ = child_.text
            key_ = self.gds_validate_string(key_, node, 'key')
            self.key = key_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class KeyValuePair


class LinkCapabilities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, searchable=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.searchable = searchable
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LinkCapabilities)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LinkCapabilities.subclass:
            return LinkCapabilities.subclass(*args_, **kwargs_)
        else:
            return LinkCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_searchable(self):
        return self.searchable
    def set_searchable(self, searchable):
        self.searchable = searchable
    searchableProp = property(get_searchable, set_searchable)
    def hasContent_(self):
        if (
            self.searchable is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='linkCapabilities', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkCapabilities')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkCapabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='linkCapabilities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='linkCapabilities'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='linkCapabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.searchable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssearchable>%s</%ssearchable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.searchable, input_name='searchable'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'searchable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'searchable')
            self.searchable = ival_
# end class LinkCapabilities


class DetailedLinks(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailedLinks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailedLinks.subclass:
            return DetailedLinks.subclass(*args_, **kwargs_)
        else:
            return DetailedLinks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def add_link(self, value):
        self.link.append(value)
    def insert_link_at(self, index, value):
        self.link.insert(index, value)
    def replace_link_at(self, index, value):
        self.link[index] = value
    linkProp = property(get_link, set_link)
    def hasContent_(self):
        if (
            self.link
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='detailedLinks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detailedLinks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detailedLinks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='detailedLinks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detailedLinks'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='detailedLinks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for link_ in self.link:
            link_.export(outfile, level, namespaceprefix_, name_='link', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'link':
            class_obj_ = self.get_class_obj_(child_, Link)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
# end class DetailedLinks


class Link(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, href=None, rel=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.href = _cast(None, href)
        self.rel = _cast(None, rel)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Link.subclass:
            return Link.subclass(*args_, **kwargs_)
        else:
            return Link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    hrefProp = property(get_href, set_href)
    def get_rel(self):
        return self.rel
    def set_rel(self, rel):
        self.rel = rel
    relProp = property(get_rel, set_rel)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='link', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='link', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='link'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rel), input_name='rel')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='link', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Link


class ApiSummary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vms=None, hosts=None, users=None, storage_domains=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vms = vms
        self.hosts = hosts
        self.users = users
        self.storage_domains = storage_domains
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApiSummary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApiSummary.subclass:
            return ApiSummary.subclass(*args_, **kwargs_)
        else:
            return ApiSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vms(self):
        return self.vms
    def set_vms(self, vms):
        self.vms = vms
    vmsProp = property(get_vms, set_vms)
    def get_hosts(self):
        return self.hosts
    def set_hosts(self, hosts):
        self.hosts = hosts
    hostsProp = property(get_hosts, set_hosts)
    def get_users(self):
        return self.users
    def set_users(self, users):
        self.users = users
    usersProp = property(get_users, set_users)
    def get_storage_domains(self):
        return self.storage_domains
    def set_storage_domains(self, storage_domains):
        self.storage_domains = storage_domains
    storage_domainsProp = property(get_storage_domains, set_storage_domains)
    def hasContent_(self):
        if (
            self.vms is not None or
            self.hosts is not None or
            self.users is not None or
            self.storage_domains is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='summary', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('summary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='summary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='summary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='summary'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='summary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vms is not None:
            self.vms.export(outfile, level, namespaceprefix_, name_='vms', pretty_print=pretty_print)
        if self.hosts is not None:
            self.hosts.export(outfile, level, namespaceprefix_, name_='hosts', pretty_print=pretty_print)
        if self.users is not None:
            self.users.export(outfile, level, namespaceprefix_, name_='users', pretty_print=pretty_print)
        if self.storage_domains is not None:
            self.storage_domains.export(outfile, level, namespaceprefix_, name_='storage_domains', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vms':
            obj_ = VMs.factory(parent_object_=self)
            obj_.build(child_)
            self.vms = obj_
            obj_.original_tagname_ = 'vms'
        elif nodeName_ == 'hosts':
            obj_ = Hosts.factory(parent_object_=self)
            obj_.build(child_)
            self.hosts = obj_
            obj_.original_tagname_ = 'hosts'
        elif nodeName_ == 'users':
            obj_ = Users.factory(parent_object_=self)
            obj_.build(child_)
            self.users = obj_
            obj_.original_tagname_ = 'users'
        elif nodeName_ == 'storage_domains':
            obj_ = StorageDomains.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domains = obj_
            obj_.original_tagname_ = 'storage_domains'
# end class ApiSummary


class Fault(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reason=None, detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.reason = reason
        self.detail = detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Fault)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Fault.subclass:
            return Fault.subclass(*args_, **kwargs_)
        else:
            return Fault(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reason(self):
        return self.reason
    def set_reason(self, reason):
        self.reason = reason
    reasonProp = property(get_reason, set_reason)
    def get_detail(self):
        return self.detail
    def set_detail(self, detail):
        self.detail = detail
    detailProp = property(get_detail, set_detail)
    def hasContent_(self):
        if (
            self.reason is not None or
            self.detail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='fault', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fault')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fault')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='fault', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fault'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='fault', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reason), input_name='reason')), namespaceprefix_ , eol_))
        if self.detail is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetail>%s</%sdetail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.detail), input_name='detail')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reason':
            reason_ = child_.text
            reason_ = self.gds_validate_string(reason_, node, 'reason')
            self.reason = reason_
        elif nodeName_ == 'detail':
            detail_ = child_.text
            detail_ = self.gds_validate_string(detail_, node, 'detail')
            self.detail = detail_
# end class Fault


class UsageMessage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, message=None, detailedLink=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.message = message
        self.detailedLink = detailedLink
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsageMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsageMessage.subclass:
            return UsageMessage.subclass(*args_, **kwargs_)
        else:
            return UsageMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_message(self):
        return self.message
    def set_message(self, message):
        self.message = message
    messageProp = property(get_message, set_message)
    def get_detailedLink(self):
        return self.detailedLink
    def set_detailedLink(self, detailedLink):
        self.detailedLink = detailedLink
    detailedLinkProp = property(get_detailedLink, set_detailedLink)
    def hasContent_(self):
        if (
            self.message is not None or
            self.detailedLink is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='usage_message', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('usage_message')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='usage_message')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='usage_message', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='usage_message'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='usage_message', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.message is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessage>%s</%smessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.message), input_name='message')), namespaceprefix_ , eol_))
        if self.detailedLink is not None:
            self.detailedLink.export(outfile, level, namespaceprefix_, name_='detailedLink', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'message':
            message_ = child_.text
            message_ = self.gds_validate_string(message_, node, 'message')
            self.message = message_
        elif nodeName_ == 'detailedLink':
            class_obj_ = self.get_class_obj_(child_, DetailedLink)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.detailedLink = obj_
            obj_.original_tagname_ = 'detailedLink'
# end class UsageMessage


class GracePeriod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, expiry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.expiry = expiry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GracePeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GracePeriod.subclass:
            return GracePeriod.subclass(*args_, **kwargs_)
        else:
            return GracePeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expiry(self):
        return self.expiry
    def set_expiry(self, expiry):
        self.expiry = expiry
    expiryProp = property(get_expiry, set_expiry)
    def hasContent_(self):
        if (
            self.expiry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='GracePeriod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GracePeriod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GracePeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='GracePeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GracePeriod'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='GracePeriod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.expiry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiry>%s</%sexpiry>%s' % (namespaceprefix_ , self.gds_format_integer(self.expiry, input_name='expiry'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expiry' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'expiry')
            self.expiry = ival_
# end class GracePeriod


class IscsiDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, initiator=None, port=None, target=None, username=None, password=None, portal=None, address=None, serial=None, vendor_id=None, product_id=None, lun_mapping=None, size=None, paths=None, status=None, volume_group_id=None, storage_domain_id=None, disk_id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.initiator = initiator
        self.port = port
        self.target = target
        self.username = username
        self.password = password
        self.portal = portal
        self.address = address
        self.serial = serial
        self.vendor_id = vendor_id
        self.product_id = product_id
        self.lun_mapping = lun_mapping
        self.size = size
        self.paths = paths
        self.status = status
        self.volume_group_id = volume_group_id
        self.storage_domain_id = storage_domain_id
        self.disk_id = disk_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IscsiDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IscsiDetails.subclass:
            return IscsiDetails.subclass(*args_, **kwargs_)
        else:
            return IscsiDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initiator(self):
        return self.initiator
    def set_initiator(self, initiator):
        self.initiator = initiator
    initiatorProp = property(get_initiator, set_initiator)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    targetProp = property(get_target, set_target)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_portal(self):
        return self.portal
    def set_portal(self, portal):
        self.portal = portal
    portalProp = property(get_portal, set_portal)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_serial(self):
        return self.serial
    def set_serial(self, serial):
        self.serial = serial
    serialProp = property(get_serial, set_serial)
    def get_vendor_id(self):
        return self.vendor_id
    def set_vendor_id(self, vendor_id):
        self.vendor_id = vendor_id
    vendor_idProp = property(get_vendor_id, set_vendor_id)
    def get_product_id(self):
        return self.product_id
    def set_product_id(self, product_id):
        self.product_id = product_id
    product_idProp = property(get_product_id, set_product_id)
    def get_lun_mapping(self):
        return self.lun_mapping
    def set_lun_mapping(self, lun_mapping):
        self.lun_mapping = lun_mapping
    lun_mappingProp = property(get_lun_mapping, set_lun_mapping)
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    sizeProp = property(get_size, set_size)
    def get_paths(self):
        return self.paths
    def set_paths(self, paths):
        self.paths = paths
    pathsProp = property(get_paths, set_paths)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_volume_group_id(self):
        return self.volume_group_id
    def set_volume_group_id(self, volume_group_id):
        self.volume_group_id = volume_group_id
    volume_group_idProp = property(get_volume_group_id, set_volume_group_id)
    def get_storage_domain_id(self):
        return self.storage_domain_id
    def set_storage_domain_id(self, storage_domain_id):
        self.storage_domain_id = storage_domain_id
    storage_domain_idProp = property(get_storage_domain_id, set_storage_domain_id)
    def get_disk_id(self):
        return self.disk_id
    def set_disk_id(self, disk_id):
        self.disk_id = disk_id
    disk_idProp = property(get_disk_id, set_disk_id)
    def hasContent_(self):
        if (
            self.initiator is not None or
            self.port is not None or
            self.target is not None or
            self.username is not None or
            self.password is not None or
            self.portal is not None or
            self.address is not None or
            self.serial is not None or
            self.vendor_id is not None or
            self.product_id is not None or
            self.lun_mapping is not None or
            self.size is not None or
            self.paths is not None or
            self.status is not None or
            self.volume_group_id is not None or
            self.storage_domain_id is not None or
            self.disk_id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='IscsiDetails', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IscsiDetails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IscsiDetails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='IscsiDetails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IscsiDetails'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='IscsiDetails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initiator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitiator>%s</%sinitiator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.initiator), input_name='initiator')), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.target), input_name='target')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.portal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sportal>%s</%sportal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.portal), input_name='portal')), namespaceprefix_ , eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.serial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserial>%s</%sserial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serial), input_name='serial')), namespaceprefix_ , eol_))
        if self.vendor_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor_id>%s</%svendor_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor_id), input_name='vendor_id')), namespaceprefix_ , eol_))
        if self.product_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_id>%s</%sproduct_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_id), input_name='product_id')), namespaceprefix_ , eol_))
        if self.lun_mapping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slun_mapping>%s</%slun_mapping>%s' % (namespaceprefix_ , self.gds_format_integer(self.lun_mapping, input_name='lun_mapping'), namespaceprefix_ , eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_format_integer(self.size, input_name='size'), namespaceprefix_ , eol_))
        if self.paths is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaths>%s</%spaths>%s' % (namespaceprefix_ , self.gds_format_integer(self.paths, input_name='paths'), namespaceprefix_ , eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.status), input_name='status')), namespaceprefix_ , eol_))
        if self.volume_group_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume_group_id>%s</%svolume_group_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume_group_id), input_name='volume_group_id')), namespaceprefix_ , eol_))
        if self.storage_domain_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_domain_id>%s</%sstorage_domain_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.storage_domain_id), input_name='storage_domain_id')), namespaceprefix_ , eol_))
        if self.disk_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisk_id>%s</%sdisk_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disk_id), input_name='disk_id')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initiator':
            initiator_ = child_.text
            initiator_ = self.gds_validate_string(initiator_, node, 'initiator')
            self.initiator = initiator_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'portal':
            portal_ = child_.text
            portal_ = self.gds_validate_string(portal_, node, 'portal')
            self.portal = portal_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_
        elif nodeName_ == 'vendor_id':
            vendor_id_ = child_.text
            vendor_id_ = self.gds_validate_string(vendor_id_, node, 'vendor_id')
            self.vendor_id = vendor_id_
        elif nodeName_ == 'product_id':
            product_id_ = child_.text
            product_id_ = self.gds_validate_string(product_id_, node, 'product_id')
            self.product_id = product_id_
        elif nodeName_ == 'lun_mapping' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lun_mapping')
            self.lun_mapping = ival_
        elif nodeName_ == 'size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'paths' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'paths')
            self.paths = ival_
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'volume_group_id':
            volume_group_id_ = child_.text
            volume_group_id_ = self.gds_validate_string(volume_group_id_, node, 'volume_group_id')
            self.volume_group_id = volume_group_id_
        elif nodeName_ == 'storage_domain_id':
            storage_domain_id_ = child_.text
            storage_domain_id_ = self.gds_validate_string(storage_domain_id_, node, 'storage_domain_id')
            self.storage_domain_id = storage_domain_id_
        elif nodeName_ == 'disk_id':
            disk_id_ = child_.text
            disk_id_ = self.gds_validate_string(disk_id_, node, 'disk_id')
            self.disk_id = disk_id_
# end class IscsiDetails


class ProxyTicket(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProxyTicket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProxyTicket.subclass:
            return ProxyTicket.subclass(*args_, **kwargs_)
        else:
            return ProxyTicket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def hasContent_(self):
        if (
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ProxyTicket', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProxyTicket')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProxyTicket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ProxyTicket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProxyTicket'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ProxyTicket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class ProxyTicket


class Actions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Actions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Actions.subclass:
            return Actions.subclass(*args_, **kwargs_)
        else:
            return Actions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def add_link(self, value):
        self.link.append(value)
    def insert_link_at(self, index, value):
        self.link.insert(index, value)
    def replace_link_at(self, index, value):
        self.link[index] = value
    linkProp = property(get_link, set_link)
    def hasContent_(self):
        if (
            self.link
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Actions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Actions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Actions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Actions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Actions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Actions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for link_ in self.link:
            link_.export(outfile, level, namespaceprefix_, name_='link', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'link':
            class_obj_ = self.get_class_obj_(child_, Link)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
# end class Actions


class Status(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, state=None, detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.state = state
        self.detail = detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Status)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Status.subclass:
            return Status.subclass(*args_, **kwargs_)
        else:
            return Status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    stateProp = property(get_state, set_state)
    def get_detail(self):
        return self.detail
    def set_detail(self, detail):
        self.detail = detail
    detailProp = property(get_detail, set_detail)
    def hasContent_(self):
        if (
            self.state is not None or
            self.detail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='status', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('status')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='status', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='status'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='status', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.state is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.state), input_name='state')), namespaceprefix_ , eol_))
        if self.detail is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetail>%s</%sdetail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.detail), input_name='detail')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state = state_
        elif nodeName_ == 'detail':
            detail_ = child_.text
            detail_ = self.gds_validate_string(detail_, node, 'detail')
            self.detail = detail_
# end class Status


class Usages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, usage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if usage is None:
            self.usage = []
        else:
            self.usage = usage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Usages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Usages.subclass:
            return Usages.subclass(*args_, **kwargs_)
        else:
            return Usages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def add_usage(self, value):
        self.usage.append(value)
    def insert_usage_at(self, index, value):
        self.usage.insert(index, value)
    def replace_usage_at(self, index, value):
        self.usage[index] = value
    usageProp = property(get_usage, set_usage)
    def hasContent_(self):
        if (
            self.usage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='usages', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('usages')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='usages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='usages', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='usages'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='usages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for usage_ in self.usage:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(usage_), input_name='usage')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'usage':
            usage_ = child_.text
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage.append(usage_)
# end class Usages


class CreationStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, creation_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if creation_state is None:
            self.creation_state = []
        else:
            self.creation_state = creation_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreationStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreationStates.subclass:
            return CreationStates.subclass(*args_, **kwargs_)
        else:
            return CreationStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creation_state(self):
        return self.creation_state
    def set_creation_state(self, creation_state):
        self.creation_state = creation_state
    def add_creation_state(self, value):
        self.creation_state.append(value)
    def insert_creation_state_at(self, index, value):
        self.creation_state.insert(index, value)
    def replace_creation_state_at(self, index, value):
        self.creation_state[index] = value
    creation_stateProp = property(get_creation_state, set_creation_state)
    def hasContent_(self):
        if (
            self.creation_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='creation_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('creation_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='creation_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='creation_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='creation_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='creation_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for creation_state_ in self.creation_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screation_state>%s</%screation_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(creation_state_), input_name='creation_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creation_state':
            creation_state_ = child_.text
            creation_state_ = self.gds_validate_string(creation_state_, node, 'creation_state')
            self.creation_state.append(creation_state_)
# end class CreationStates


class Value(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datum=None, detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.datum = datum
        self.detail = detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Value)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Value.subclass:
            return Value.subclass(*args_, **kwargs_)
        else:
            return Value(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datum(self):
        return self.datum
    def set_datum(self, datum):
        self.datum = datum
    datumProp = property(get_datum, set_datum)
    def get_detail(self):
        return self.detail
    def set_detail(self, detail):
        self.detail = detail
    detailProp = property(get_detail, set_detail)
    def hasContent_(self):
        if (
            self.datum is not None or
            self.detail is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='value', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('value')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='value')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='value', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='value'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='value', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.datum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdatum>%s</%sdatum>%s' % (namespaceprefix_ , self.gds_format_float(self.datum, input_name='datum'), namespaceprefix_ , eol_))
        if self.detail is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetail>%s</%sdetail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.detail), input_name='detail')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'datum' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'datum')
            self.datum = fval_
        elif nodeName_ == 'detail':
            detail_ = child_.text
            detail_ = self.gds_validate_string(detail_, node, 'detail')
            self.detail = detail_
# end class Value


class Values(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = _cast(None, type_)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Values)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Values.subclass:
            return Values.subclass(*args_, **kwargs_)
        else:
            return Values(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def add_value(self, value):
        self.value.append(value)
    def insert_value_at(self, index, value):
        self.value.insert(index, value)
    def replace_value_at(self, index, value):
        self.value[index] = value
    valueProp = property(get_value, set_value)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def validate_ValueType(self, value):
        # Validate type ValueType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['INTEGER', 'DECIMAL', 'STRING']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ValueType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='values', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('values')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='values')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='values', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='values'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='values', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            value_.export(outfile, level, namespaceprefix_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_ValueType(self.type_)    # validate type ValueType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_)
            self.value.append(obj_)
            obj_.original_tagname_ = 'value'
# end class Values


class CpuTopology(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sockets=None, cores=None, threads=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.sockets = _cast(int, sockets)
        self.cores = _cast(int, cores)
        self.threads = _cast(int, threads)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CpuTopology)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CpuTopology.subclass:
            return CpuTopology.subclass(*args_, **kwargs_)
        else:
            return CpuTopology(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sockets(self):
        return self.sockets
    def set_sockets(self, sockets):
        self.sockets = sockets
    socketsProp = property(get_sockets, set_sockets)
    def get_cores(self):
        return self.cores
    def set_cores(self, cores):
        self.cores = cores
    coresProp = property(get_cores, set_cores)
    def get_threads(self):
        return self.threads
    def set_threads(self, threads):
        self.threads = threads
    threadsProp = property(get_threads, set_threads)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='CpuTopology', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CpuTopology')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CpuTopology')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='CpuTopology', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CpuTopology'):
        if self.sockets is not None and 'sockets' not in already_processed:
            already_processed.add('sockets')
            outfile.write(' sockets="%s"' % self.gds_format_integer(self.sockets, input_name='sockets'))
        if self.cores is not None and 'cores' not in already_processed:
            already_processed.add('cores')
            outfile.write(' cores="%s"' % self.gds_format_integer(self.cores, input_name='cores'))
        if self.threads is not None and 'threads' not in already_processed:
            already_processed.add('threads')
            outfile.write(' threads="%s"' % self.gds_format_integer(self.threads, input_name='threads'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='CpuTopology', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sockets', node)
        if value is not None and 'sockets' not in already_processed:
            already_processed.add('sockets')
            try:
                self.sockets = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cores', node)
        if value is not None and 'cores' not in already_processed:
            already_processed.add('cores')
            try:
                self.cores = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('threads', node)
        if value is not None and 'threads' not in already_processed:
            already_processed.add('threads')
            try:
                self.threads = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CpuTopology


class VCpuPin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vcpu=None, cpu_set=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vcpu = _cast(int, vcpu)
        self.cpu_set = _cast(None, cpu_set)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VCpuPin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VCpuPin.subclass:
            return VCpuPin.subclass(*args_, **kwargs_)
        else:
            return VCpuPin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vcpu(self):
        return self.vcpu
    def set_vcpu(self, vcpu):
        self.vcpu = vcpu
    vcpuProp = property(get_vcpu, set_vcpu)
    def get_cpu_set(self):
        return self.cpu_set
    def set_cpu_set(self, cpu_set):
        self.cpu_set = cpu_set
    cpu_setProp = property(get_cpu_set, set_cpu_set)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vcpu_pin', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vcpu_pin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vcpu_pin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vcpu_pin', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vcpu_pin'):
        if self.vcpu is not None and 'vcpu' not in already_processed:
            already_processed.add('vcpu')
            outfile.write(' vcpu="%s"' % self.gds_format_integer(self.vcpu, input_name='vcpu'))
        if self.cpu_set is not None and 'cpu_set' not in already_processed:
            already_processed.add('cpu_set')
            outfile.write(' cpu_set=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cpu_set), input_name='cpu_set')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vcpu_pin', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vcpu', node)
        if value is not None and 'vcpu' not in already_processed:
            already_processed.add('vcpu')
            try:
                self.vcpu = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cpu_set', node)
        if value is not None and 'cpu_set' not in already_processed:
            already_processed.add('cpu_set')
            self.cpu_set = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VCpuPin


class CpuTune(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vcpu_pin=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vcpu_pin is None:
            self.vcpu_pin = []
        else:
            self.vcpu_pin = vcpu_pin
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CpuTune)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CpuTune.subclass:
            return CpuTune.subclass(*args_, **kwargs_)
        else:
            return CpuTune(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vcpu_pin(self):
        return self.vcpu_pin
    def set_vcpu_pin(self, vcpu_pin):
        self.vcpu_pin = vcpu_pin
    def add_vcpu_pin(self, value):
        self.vcpu_pin.append(value)
    def insert_vcpu_pin_at(self, index, value):
        self.vcpu_pin.insert(index, value)
    def replace_vcpu_pin_at(self, index, value):
        self.vcpu_pin[index] = value
    vcpu_pinProp = property(get_vcpu_pin, set_vcpu_pin)
    def hasContent_(self):
        if (
            self.vcpu_pin
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cpu_tune', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpu_tune')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu_tune')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cpu_tune', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpu_tune'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cpu_tune', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vcpu_pin_ in self.vcpu_pin:
            vcpu_pin_.export(outfile, level, namespaceprefix_, name_='vcpu_pin', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vcpu_pin':
            obj_ = VCpuPin.factory(parent_object_=self)
            obj_.build(child_)
            self.vcpu_pin.append(obj_)
            obj_.original_tagname_ = 'vcpu_pin'
# end class CpuTune


class CPU(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, topology=None, level=None, name=None, speed=None, cpu_tune=None, mode=None, architecture=None, cores=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.topology = topology
        self.level = level
        self.name = name
        self.speed = speed
        self.cpu_tune = cpu_tune
        self.mode = mode
        self.architecture = architecture
        self.cores = cores
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CPU)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CPU.subclass:
            return CPU.subclass(*args_, **kwargs_)
        else:
            return CPU(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_topology(self):
        return self.topology
    def set_topology(self, topology):
        self.topology = topology
    topologyProp = property(get_topology, set_topology)
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    levelProp = property(get_level, set_level)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    speedProp = property(get_speed, set_speed)
    def get_cpu_tune(self):
        return self.cpu_tune
    def set_cpu_tune(self, cpu_tune):
        self.cpu_tune = cpu_tune
    cpu_tuneProp = property(get_cpu_tune, set_cpu_tune)
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    modeProp = property(get_mode, set_mode)
    def get_architecture(self):
        return self.architecture
    def set_architecture(self, architecture):
        self.architecture = architecture
    architectureProp = property(get_architecture, set_architecture)
    def get_cores(self):
        return self.cores
    def set_cores(self, cores):
        self.cores = cores
    coresProp = property(get_cores, set_cores)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    idProp = property(get_id, set_id)
    def hasContent_(self):
        if (
            self.topology is not None or
            self.level is not None or
            self.name is not None or
            self.speed is not None or
            self.cpu_tune is not None or
            self.mode is not None or
            self.architecture is not None or
            self.cores is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cpu', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cpu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpu'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cpu', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.topology is not None:
            self.topology.export(outfile, level, namespaceprefix_, name_='topology', pretty_print=pretty_print)
        if self.level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevel>%s</%slevel>%s' % (namespaceprefix_ , self.gds_format_integer(self.level, input_name='level'), namespaceprefix_ , eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.speed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspeed>%s</%sspeed>%s' % (namespaceprefix_ , self.gds_format_float(self.speed, input_name='speed'), namespaceprefix_ , eol_))
        if self.cpu_tune is not None:
            self.cpu_tune.export(outfile, level, namespaceprefix_, name_='cpu_tune', pretty_print=pretty_print)
        if self.mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smode>%s</%smode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mode), input_name='mode')), namespaceprefix_ , eol_))
        if self.architecture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarchitecture>%s</%sarchitecture>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.architecture), input_name='architecture')), namespaceprefix_ , eol_))
        if self.cores is not None:
            self.cores.export(outfile, level, namespaceprefix_, name_='cores', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'topology':
            obj_ = CpuTopology.factory(parent_object_=self)
            obj_.build(child_)
            self.topology = obj_
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'level' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'level')
            self.level = ival_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'speed' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'speed')
            self.speed = fval_
        elif nodeName_ == 'cpu_tune':
            obj_ = CpuTune.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu_tune = obj_
            obj_.original_tagname_ = 'cpu_tune'
        elif nodeName_ == 'mode':
            mode_ = child_.text
            mode_ = self.gds_validate_string(mode_, node, 'mode')
            self.mode = mode_
        elif nodeName_ == 'architecture':
            architecture_ = child_.text
            architecture_ = self.gds_validate_string(architecture_, node, 'architecture')
            self.architecture = architecture_
        elif nodeName_ == 'cores':
            obj_ = Cores.factory(parent_object_=self)
            obj_.build(child_)
            self.cores = obj_
            obj_.original_tagname_ = 'cores'
# end class CPU


class CPUs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cpu=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if cpu is None:
            self.cpu = []
        else:
            self.cpu = cpu
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CPUs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CPUs.subclass:
            return CPUs.subclass(*args_, **kwargs_)
        else:
            return CPUs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu(self):
        return self.cpu
    def set_cpu(self, cpu):
        self.cpu = cpu
    def add_cpu(self, value):
        self.cpu.append(value)
    def insert_cpu_at(self, index, value):
        self.cpu.insert(index, value)
    def replace_cpu_at(self, index, value):
        self.cpu[index] = value
    cpuProp = property(get_cpu, set_cpu)
    def hasContent_(self):
        if (
            self.cpu
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cpus', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cpus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpus'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cpus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cpu_ in self.cpu:
            cpu_.export(outfile, level, namespaceprefix_, name_='cpu', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpu':
            obj_ = CPU.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu.append(obj_)
            obj_.original_tagname_ = 'cpu'
# end class CPUs


class TemplateVersion(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, base_template=None, version_number=None, version_name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.base_template = base_template
        self.version_number = version_number
        self.version_name = version_name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemplateVersion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemplateVersion.subclass:
            return TemplateVersion.subclass(*args_, **kwargs_)
        else:
            return TemplateVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_base_template(self):
        return self.base_template
    def set_base_template(self, base_template):
        self.base_template = base_template
    base_templateProp = property(get_base_template, set_base_template)
    def get_version_number(self):
        return self.version_number
    def set_version_number(self, version_number):
        self.version_number = version_number
    version_numberProp = property(get_version_number, set_version_number)
    def get_version_name(self):
        return self.version_name
    def set_version_name(self, version_name):
        self.version_name = version_name
    version_nameProp = property(get_version_name, set_version_name)
    def hasContent_(self):
        if (
            self.base_template is not None or
            self.version_number is not None or
            self.version_name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='TemplateVersion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TemplateVersion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TemplateVersion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='TemplateVersion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TemplateVersion'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TemplateVersion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.base_template is not None:
            self.base_template.export(outfile, level, namespaceprefix_, name_='base_template', pretty_print=pretty_print)
        if self.version_number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion_number>%s</%sversion_number>%s' % (namespaceprefix_ , self.gds_format_integer(self.version_number, input_name='version_number'), namespaceprefix_ , eol_))
        if self.version_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion_name>%s</%sversion_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version_name), input_name='version_name')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'base_template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.base_template = obj_
            obj_.original_tagname_ = 'base_template'
        elif nodeName_ == 'version_number' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'version_number')
            self.version_number = ival_
        elif nodeName_ == 'version_name':
            version_name_ = child_.text
            version_name_ = self.gds_validate_string(version_name_, node, 'version_name')
            self.version_name = version_name_
# end class TemplateVersion


class SupportedVersions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if version is None:
            self.version = []
        else:
            self.version = version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportedVersions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportedVersions.subclass:
            return SupportedVersions.subclass(*args_, **kwargs_)
        else:
            return SupportedVersions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def add_version(self, value):
        self.version.append(value)
    def insert_version_at(self, index, value):
        self.version.insert(index, value)
    def replace_version_at(self, index, value):
        self.version[index] = value
    versionProp = property(get_version, set_version)
    def hasContent_(self):
        if (
            self.version
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='SupportedVersions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportedVersions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedVersions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='SupportedVersions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportedVersions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SupportedVersions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for version_ in self.version:
            version_.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version.append(obj_)
            obj_.original_tagname_ = 'version'
# end class SupportedVersions


class ErrorHandling(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, on_error=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.on_error = on_error
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ErrorHandling)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ErrorHandling.subclass:
            return ErrorHandling.subclass(*args_, **kwargs_)
        else:
            return ErrorHandling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_on_error(self):
        return self.on_error
    def set_on_error(self, on_error):
        self.on_error = on_error
    on_errorProp = property(get_on_error, set_on_error)
    def hasContent_(self):
        if (
            self.on_error is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ErrorHandling', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ErrorHandling')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ErrorHandling')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ErrorHandling', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ErrorHandling'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ErrorHandling', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.on_error is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%son_error>%s</%son_error>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.on_error), input_name='on_error')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'on_error':
            on_error_ = child_.text
            on_error_ = self.gds_validate_string(on_error_, node, 'on_error')
            self.on_error = on_error_
# end class ErrorHandling


class Features(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, feature=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if feature is None:
            self.feature = []
        else:
            self.feature = feature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Features)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Features.subclass:
            return Features.subclass(*args_, **kwargs_)
        else:
            return Features(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_feature(self):
        return self.feature
    def set_feature(self, feature):
        self.feature = feature
    def add_feature(self, value):
        self.feature.append(value)
    def insert_feature_at(self, index, value):
        self.feature.insert(index, value)
    def replace_feature_at(self, index, value):
        self.feature[index] = value
    featureProp = property(get_feature, set_feature)
    def hasContent_(self):
        if (
            self.feature
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='features', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('features')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='features')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='features', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='features'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='features', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for feature_ in self.feature:
            feature_.export(outfile, level, namespaceprefix_, name_='feature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'feature':
            obj_ = Feature.factory(parent_object_=self)
            obj_.build(child_)
            self.feature.append(obj_)
            obj_.original_tagname_ = 'feature'
# end class Features


class FenceTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fence_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if fence_type is None:
            self.fence_type = []
        else:
            self.fence_type = fence_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FenceTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FenceTypes.subclass:
            return FenceTypes.subclass(*args_, **kwargs_)
        else:
            return FenceTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fence_type(self):
        return self.fence_type
    def set_fence_type(self, fence_type):
        self.fence_type = fence_type
    def add_fence_type(self, value):
        self.fence_type.append(value)
    def insert_fence_type_at(self, index, value):
        self.fence_type.insert(index, value)
    def replace_fence_type_at(self, index, value):
        self.fence_type[index] = value
    fence_typeProp = property(get_fence_type, set_fence_type)
    def hasContent_(self):
        if (
            self.fence_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='fence_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fence_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fence_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='fence_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fence_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='fence_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fence_type_ in self.fence_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfence_type>%s</%sfence_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(fence_type_), input_name='fence_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fence_type':
            fence_type_ = child_.text
            fence_type_ = self.gds_validate_string(fence_type_, node, 'fence_type')
            self.fence_type.append(fence_type_)
# end class FenceTypes


class StorageTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, storage_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if storage_type is None:
            self.storage_type = []
        else:
            self.storage_type = storage_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageTypes.subclass:
            return StorageTypes.subclass(*args_, **kwargs_)
        else:
            return StorageTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_type(self):
        return self.storage_type
    def set_storage_type(self, storage_type):
        self.storage_type = storage_type
    def add_storage_type(self, value):
        self.storage_type.append(value)
    def insert_storage_type_at(self, index, value):
        self.storage_type.insert(index, value)
    def replace_storage_type_at(self, index, value):
        self.storage_type[index] = value
    storage_typeProp = property(get_storage_type, set_storage_type)
    def hasContent_(self):
        if (
            self.storage_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_type_ in self.storage_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_type>%s</%sstorage_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(storage_type_), input_name='storage_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_type':
            storage_type_ = child_.text
            storage_type_ = self.gds_validate_string(storage_type_, node, 'storage_type')
            self.storage_type.append(storage_type_)
# end class StorageTypes


class ConfigurationTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, configuration_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if configuration_type is None:
            self.configuration_type = []
        else:
            self.configuration_type = configuration_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfigurationTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfigurationTypes.subclass:
            return ConfigurationTypes.subclass(*args_, **kwargs_)
        else:
            return ConfigurationTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configuration_type(self):
        return self.configuration_type
    def set_configuration_type(self, configuration_type):
        self.configuration_type = configuration_type
    def add_configuration_type(self, value):
        self.configuration_type.append(value)
    def insert_configuration_type_at(self, index, value):
        self.configuration_type.insert(index, value)
    def replace_configuration_type_at(self, index, value):
        self.configuration_type[index] = value
    configuration_typeProp = property(get_configuration_type, set_configuration_type)
    def hasContent_(self):
        if (
            self.configuration_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='configuration_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configuration_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configuration_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='configuration_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='configuration_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='configuration_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for configuration_type_ in self.configuration_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconfiguration_type>%s</%sconfiguration_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(configuration_type_), input_name='configuration_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configuration_type':
            configuration_type_ = child_.text
            configuration_type_ = self.gds_validate_string(configuration_type_, node, 'configuration_type')
            self.configuration_type.append(configuration_type_)
# end class ConfigurationTypes


class StorageDomainTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, storage_domain_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if storage_domain_type is None:
            self.storage_domain_type = []
        else:
            self.storage_domain_type = storage_domain_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageDomainTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageDomainTypes.subclass:
            return StorageDomainTypes.subclass(*args_, **kwargs_)
        else:
            return StorageDomainTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_domain_type(self):
        return self.storage_domain_type
    def set_storage_domain_type(self, storage_domain_type):
        self.storage_domain_type = storage_domain_type
    def add_storage_domain_type(self, value):
        self.storage_domain_type.append(value)
    def insert_storage_domain_type_at(self, index, value):
        self.storage_domain_type.insert(index, value)
    def replace_storage_domain_type_at(self, index, value):
        self.storage_domain_type[index] = value
    storage_domain_typeProp = property(get_storage_domain_type, set_storage_domain_type)
    def hasContent_(self):
        if (
            self.storage_domain_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_domain_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_domain_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_domain_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_domain_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_domain_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_domain_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_domain_type_ in self.storage_domain_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_domain_type>%s</%sstorage_domain_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(storage_domain_type_), input_name='storage_domain_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_domain_type':
            storage_domain_type_ = child_.text
            storage_domain_type_ = self.gds_validate_string(storage_domain_type_, node, 'storage_domain_type')
            self.storage_domain_type.append(storage_domain_type_)
# end class StorageDomainTypes


class VmTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vm_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vm_type is None:
            self.vm_type = []
        else:
            self.vm_type = vm_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmTypes.subclass:
            return VmTypes.subclass(*args_, **kwargs_)
        else:
            return VmTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm_type(self):
        return self.vm_type
    def set_vm_type(self, vm_type):
        self.vm_type = vm_type
    def add_vm_type(self, value):
        self.vm_type.append(value)
    def insert_vm_type_at(self, index, value):
        self.vm_type.insert(index, value)
    def replace_vm_type_at(self, index, value):
        self.vm_type[index] = value
    vm_typeProp = property(get_vm_type, set_vm_type)
    def hasContent_(self):
        if (
            self.vm_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_type_ in self.vm_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svm_type>%s</%svm_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(vm_type_), input_name='vm_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm_type':
            vm_type_ = child_.text
            vm_type_ = self.gds_validate_string(vm_type_, node, 'vm_type')
            self.vm_type.append(vm_type_)
# end class VmTypes


class BootDevices(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, boot_device=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if boot_device is None:
            self.boot_device = []
        else:
            self.boot_device = boot_device
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BootDevices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BootDevices.subclass:
            return BootDevices.subclass(*args_, **kwargs_)
        else:
            return BootDevices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boot_device(self):
        return self.boot_device
    def set_boot_device(self, boot_device):
        self.boot_device = boot_device
    def add_boot_device(self, value):
        self.boot_device.append(value)
    def insert_boot_device_at(self, index, value):
        self.boot_device.insert(index, value)
    def replace_boot_device_at(self, index, value):
        self.boot_device[index] = value
    boot_deviceProp = property(get_boot_device, set_boot_device)
    def hasContent_(self):
        if (
            self.boot_device
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='boot_devices', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boot_devices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boot_devices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='boot_devices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boot_devices'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='boot_devices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for boot_device_ in self.boot_device:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboot_device>%s</%sboot_device>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(boot_device_), input_name='boot_device')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boot_device':
            boot_device_ = child_.text
            boot_device_ = self.gds_validate_string(boot_device_, node, 'boot_device')
            self.boot_device.append(boot_device_)
# end class BootDevices


class DisplayTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, display_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if display_type is None:
            self.display_type = []
        else:
            self.display_type = display_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DisplayTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DisplayTypes.subclass:
            return DisplayTypes.subclass(*args_, **kwargs_)
        else:
            return DisplayTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_display_type(self):
        return self.display_type
    def set_display_type(self, display_type):
        self.display_type = display_type
    def add_display_type(self, value):
        self.display_type.append(value)
    def insert_display_type_at(self, index, value):
        self.display_type.insert(index, value)
    def replace_display_type_at(self, index, value):
        self.display_type[index] = value
    display_typeProp = property(get_display_type, set_display_type)
    def hasContent_(self):
        if (
            self.display_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='display_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('display_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='display_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='display_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='display_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='display_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for display_type_ in self.display_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay_type>%s</%sdisplay_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(display_type_), input_name='display_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'display_type':
            display_type_ = child_.text
            display_type_ = self.gds_validate_string(display_type_, node, 'display_type')
            self.display_type.append(display_type_)
# end class DisplayTypes


class NicInterfaces(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nic_interface=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if nic_interface is None:
            self.nic_interface = []
        else:
            self.nic_interface = nic_interface
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NicInterfaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NicInterfaces.subclass:
            return NicInterfaces.subclass(*args_, **kwargs_)
        else:
            return NicInterfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nic_interface(self):
        return self.nic_interface
    def set_nic_interface(self, nic_interface):
        self.nic_interface = nic_interface
    def add_nic_interface(self, value):
        self.nic_interface.append(value)
    def insert_nic_interface_at(self, index, value):
        self.nic_interface.insert(index, value)
    def replace_nic_interface_at(self, index, value):
        self.nic_interface[index] = value
    nic_interfaceProp = property(get_nic_interface, set_nic_interface)
    def hasContent_(self):
        if (
            self.nic_interface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nic_interfaces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nic_interfaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nic_interfaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nic_interfaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nic_interfaces'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nic_interfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nic_interface_ in self.nic_interface:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snic_interface>%s</%snic_interface>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(nic_interface_), input_name='nic_interface')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nic_interface':
            nic_interface_ = child_.text
            nic_interface_ = self.gds_validate_string(nic_interface_, node, 'nic_interface')
            self.nic_interface.append(nic_interface_)
# end class NicInterfaces


class OsTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, os_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if os_type is None:
            self.os_type = []
        else:
            self.os_type = os_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OsTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OsTypes.subclass:
            return OsTypes.subclass(*args_, **kwargs_)
        else:
            return OsTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_os_type(self):
        return self.os_type
    def set_os_type(self, os_type):
        self.os_type = os_type
    def add_os_type(self, value):
        self.os_type.append(value)
    def insert_os_type_at(self, index, value):
        self.os_type.insert(index, value)
    def replace_os_type_at(self, index, value):
        self.os_type[index] = value
    os_typeProp = property(get_os_type, set_os_type)
    def hasContent_(self):
        if (
            self.os_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='os_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('os_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='os_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='os_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='os_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='os_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for os_type_ in self.os_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sos_type>%s</%sos_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(os_type_), input_name='os_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'os_type':
            os_type_ = child_.text
            os_type_ = self.gds_validate_string(os_type_, node, 'os_type')
            self.os_type.append(os_type_)
# end class OsTypes


class DiskFormats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, disk_format=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if disk_format is None:
            self.disk_format = []
        else:
            self.disk_format = disk_format
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskFormats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskFormats.subclass:
            return DiskFormats.subclass(*args_, **kwargs_)
        else:
            return DiskFormats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk_format(self):
        return self.disk_format
    def set_disk_format(self, disk_format):
        self.disk_format = disk_format
    def add_disk_format(self, value):
        self.disk_format.append(value)
    def insert_disk_format_at(self, index, value):
        self.disk_format.insert(index, value)
    def replace_disk_format_at(self, index, value):
        self.disk_format[index] = value
    disk_formatProp = property(get_disk_format, set_disk_format)
    def hasContent_(self):
        if (
            self.disk_format
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_formats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_formats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_formats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_formats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_formats'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_formats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_format_ in self.disk_format:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisk_format>%s</%sdisk_format>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(disk_format_), input_name='disk_format')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk_format':
            disk_format_ = child_.text
            disk_format_ = self.gds_validate_string(disk_format_, node, 'disk_format')
            self.disk_format.append(disk_format_)
# end class DiskFormats


class GraphicsTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, graphics_types=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if graphics_types is None:
            self.graphics_types = []
        else:
            self.graphics_types = graphics_types
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GraphicsTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GraphicsTypes.subclass:
            return GraphicsTypes.subclass(*args_, **kwargs_)
        else:
            return GraphicsTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_graphics_types(self):
        return self.graphics_types
    def set_graphics_types(self, graphics_types):
        self.graphics_types = graphics_types
    def add_graphics_types(self, value):
        self.graphics_types.append(value)
    def insert_graphics_types_at(self, index, value):
        self.graphics_types.insert(index, value)
    def replace_graphics_types_at(self, index, value):
        self.graphics_types[index] = value
    graphics_typesProp = property(get_graphics_types, set_graphics_types)
    def hasContent_(self):
        if (
            self.graphics_types
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='graphics_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('graphics_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='graphics_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='graphics_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='graphics_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='graphics_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for graphics_types_ in self.graphics_types:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgraphics_types>%s</%sgraphics_types>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(graphics_types_), input_name='graphics_types')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'graphics_types':
            graphics_types_ = child_.text
            graphics_types_ = self.gds_validate_string(graphics_types_, node, 'graphics_types')
            self.graphics_types.append(graphics_types_)
# end class GraphicsTypes


class DiskStorageTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, disk_storage_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if disk_storage_type is None:
            self.disk_storage_type = []
        else:
            self.disk_storage_type = disk_storage_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskStorageTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskStorageTypes.subclass:
            return DiskStorageTypes.subclass(*args_, **kwargs_)
        else:
            return DiskStorageTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk_storage_type(self):
        return self.disk_storage_type
    def set_disk_storage_type(self, disk_storage_type):
        self.disk_storage_type = disk_storage_type
    def add_disk_storage_type(self, value):
        self.disk_storage_type.append(value)
    def insert_disk_storage_type_at(self, index, value):
        self.disk_storage_type.insert(index, value)
    def replace_disk_storage_type_at(self, index, value):
        self.disk_storage_type[index] = value
    disk_storage_typeProp = property(get_disk_storage_type, set_disk_storage_type)
    def hasContent_(self):
        if (
            self.disk_storage_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_storage_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_storage_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_storage_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_storage_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_storage_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_storage_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_storage_type_ in self.disk_storage_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisk_storage_type>%s</%sdisk_storage_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(disk_storage_type_), input_name='disk_storage_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk_storage_type':
            disk_storage_type_ = child_.text
            disk_storage_type_ = self.gds_validate_string(disk_storage_type_, node, 'disk_storage_type')
            self.disk_storage_type.append(disk_storage_type_)
# end class DiskStorageTypes


class DiskInterfaces(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, disk_interface=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if disk_interface is None:
            self.disk_interface = []
        else:
            self.disk_interface = disk_interface
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskInterfaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskInterfaces.subclass:
            return DiskInterfaces.subclass(*args_, **kwargs_)
        else:
            return DiskInterfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk_interface(self):
        return self.disk_interface
    def set_disk_interface(self, disk_interface):
        self.disk_interface = disk_interface
    def add_disk_interface(self, value):
        self.disk_interface.append(value)
    def insert_disk_interface_at(self, index, value):
        self.disk_interface.insert(index, value)
    def replace_disk_interface_at(self, index, value):
        self.disk_interface[index] = value
    disk_interfaceProp = property(get_disk_interface, set_disk_interface)
    def hasContent_(self):
        if (
            self.disk_interface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_interfaces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_interfaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_interfaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_interfaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_interfaces'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_interfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_interface_ in self.disk_interface:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisk_interface>%s</%sdisk_interface>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(disk_interface_), input_name='disk_interface')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk_interface':
            disk_interface_ = child_.text
            disk_interface_ = self.gds_validate_string(disk_interface_, node, 'disk_interface')
            self.disk_interface.append(disk_interface_)
# end class DiskInterfaces


class VmAffinities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, affinity=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if affinity is None:
            self.affinity = []
        else:
            self.affinity = affinity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmAffinities)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmAffinities.subclass:
            return VmAffinities.subclass(*args_, **kwargs_)
        else:
            return VmAffinities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_affinity(self):
        return self.affinity
    def set_affinity(self, affinity):
        self.affinity = affinity
    def add_affinity(self, value):
        self.affinity.append(value)
    def insert_affinity_at(self, index, value):
        self.affinity.insert(index, value)
    def replace_affinity_at(self, index, value):
        self.affinity[index] = value
    affinityProp = property(get_affinity, set_affinity)
    def hasContent_(self):
        if (
            self.affinity
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_affinities', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_affinities')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_affinities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_affinities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_affinities'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_affinities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for affinity_ in self.affinity:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saffinity>%s</%saffinity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(affinity_), input_name='affinity')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'affinity':
            affinity_ = child_.text
            affinity_ = self.gds_validate_string(affinity_, node, 'affinity')
            self.affinity.append(affinity_)
# end class VmAffinities


class BootProtocols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, boot_protocol=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if boot_protocol is None:
            self.boot_protocol = []
        else:
            self.boot_protocol = boot_protocol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BootProtocols)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BootProtocols.subclass:
            return BootProtocols.subclass(*args_, **kwargs_)
        else:
            return BootProtocols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boot_protocol(self):
        return self.boot_protocol
    def set_boot_protocol(self, boot_protocol):
        self.boot_protocol = boot_protocol
    def add_boot_protocol(self, value):
        self.boot_protocol.append(value)
    def insert_boot_protocol_at(self, index, value):
        self.boot_protocol.insert(index, value)
    def replace_boot_protocol_at(self, index, value):
        self.boot_protocol[index] = value
    boot_protocolProp = property(get_boot_protocol, set_boot_protocol)
    def hasContent_(self):
        if (
            self.boot_protocol
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='boot_protocols', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boot_protocols')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boot_protocols')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='boot_protocols', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boot_protocols'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='boot_protocols', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for boot_protocol_ in self.boot_protocol:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboot_protocol>%s</%sboot_protocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(boot_protocol_), input_name='boot_protocol')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boot_protocol':
            boot_protocol_ = child_.text
            boot_protocol_ = self.gds_validate_string(boot_protocol_, node, 'boot_protocol')
            self.boot_protocol.append(boot_protocol_)
# end class BootProtocols


class ErrorHandlingOptions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, on_error=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if on_error is None:
            self.on_error = []
        else:
            self.on_error = on_error
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ErrorHandlingOptions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ErrorHandlingOptions.subclass:
            return ErrorHandlingOptions.subclass(*args_, **kwargs_)
        else:
            return ErrorHandlingOptions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_on_error(self):
        return self.on_error
    def set_on_error(self, on_error):
        self.on_error = on_error
    def add_on_error(self, value):
        self.on_error.append(value)
    def insert_on_error_at(self, index, value):
        self.on_error.insert(index, value)
    def replace_on_error_at(self, index, value):
        self.on_error[index] = value
    on_errorProp = property(get_on_error, set_on_error)
    def hasContent_(self):
        if (
            self.on_error
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='error_handling', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('error_handling')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='error_handling')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='error_handling', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='error_handling'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='error_handling', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for on_error_ in self.on_error:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%son_error>%s</%son_error>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(on_error_), input_name='on_error')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'on_error':
            on_error_ = child_.text
            on_error_ = self.gds_validate_string(on_error_, node, 'on_error')
            self.on_error.append(on_error_)
# end class ErrorHandlingOptions


class StorageFormats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, format=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if format is None:
            self.format = []
        else:
            self.format = format
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageFormats)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageFormats.subclass:
            return StorageFormats.subclass(*args_, **kwargs_)
        else:
            return StorageFormats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self):
        return self.format
    def set_format(self, format):
        self.format = format
    def add_format(self, value):
        self.format.append(value)
    def insert_format_at(self, index, value):
        self.format.insert(index, value)
    def replace_format_at(self, index, value):
        self.format[index] = value
    formatProp = property(get_format, set_format)
    def hasContent_(self):
        if (
            self.format
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_formats', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_formats')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_formats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_formats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_formats'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_formats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for format_ in self.format:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformat>%s</%sformat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(format_), input_name='format')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'format':
            format_ = child_.text
            format_ = self.gds_validate_string(format_, node, 'format')
            self.format.append(format_)
# end class StorageFormats


class NfsVersions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nfs_version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if nfs_version is None:
            self.nfs_version = []
        else:
            self.nfs_version = nfs_version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NfsVersions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NfsVersions.subclass:
            return NfsVersions.subclass(*args_, **kwargs_)
        else:
            return NfsVersions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nfs_version(self):
        return self.nfs_version
    def set_nfs_version(self, nfs_version):
        self.nfs_version = nfs_version
    def add_nfs_version(self, value):
        self.nfs_version.append(value)
    def insert_nfs_version_at(self, index, value):
        self.nfs_version.insert(index, value)
    def replace_nfs_version_at(self, index, value):
        self.nfs_version[index] = value
    nfs_versionProp = property(get_nfs_version, set_nfs_version)
    def hasContent_(self):
        if (
            self.nfs_version
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nfs_versions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nfs_versions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nfs_versions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nfs_versions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nfs_versions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nfs_versions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nfs_version_ in self.nfs_version:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_version>%s</%snfs_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(nfs_version_), input_name='nfs_version')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nfs_version':
            nfs_version_ = child_.text
            nfs_version_ = self.gds_validate_string(nfs_version_, node, 'nfs_version')
            self.nfs_version.append(nfs_version_)
# end class NfsVersions


class ReportedDeviceTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, reported_device_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if reported_device_type is None:
            self.reported_device_type = []
        else:
            self.reported_device_type = reported_device_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportedDeviceTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportedDeviceTypes.subclass:
            return ReportedDeviceTypes.subclass(*args_, **kwargs_)
        else:
            return ReportedDeviceTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reported_device_type(self):
        return self.reported_device_type
    def set_reported_device_type(self, reported_device_type):
        self.reported_device_type = reported_device_type
    def add_reported_device_type(self, value):
        self.reported_device_type.append(value)
    def insert_reported_device_type_at(self, index, value):
        self.reported_device_type.insert(index, value)
    def replace_reported_device_type_at(self, index, value):
        self.reported_device_type[index] = value
    reported_device_typeProp = property(get_reported_device_type, set_reported_device_type)
    def hasContent_(self):
        if (
            self.reported_device_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='reported_device_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reported_device_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reported_device_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='reported_device_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='reported_device_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='reported_device_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reported_device_type_ in self.reported_device_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreported_device_type>%s</%sreported_device_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(reported_device_type_), input_name='reported_device_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reported_device_type':
            reported_device_type_ = child_.text
            reported_device_type_ = self.gds_validate_string(reported_device_type_, node, 'reported_device_type')
            self.reported_device_type.append(reported_device_type_)
# end class ReportedDeviceTypes


class IpVersions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ip_version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if ip_version is None:
            self.ip_version = []
        else:
            self.ip_version = ip_version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IpVersions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IpVersions.subclass:
            return IpVersions.subclass(*args_, **kwargs_)
        else:
            return IpVersions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip_version(self):
        return self.ip_version
    def set_ip_version(self, ip_version):
        self.ip_version = ip_version
    def add_ip_version(self, value):
        self.ip_version.append(value)
    def insert_ip_version_at(self, index, value):
        self.ip_version.insert(index, value)
    def replace_ip_version_at(self, index, value):
        self.ip_version[index] = value
    ip_versionProp = property(get_ip_version, set_ip_version)
    def hasContent_(self):
        if (
            self.ip_version
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ip_versions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ip_versions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ip_versions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ip_versions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ip_versions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ip_versions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ip_version_ in self.ip_version:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip_version>%s</%sip_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(ip_version_), input_name='ip_version')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip_version':
            ip_version_ = child_.text
            ip_version_ = self.gds_validate_string(ip_version_, node, 'ip_version')
            self.ip_version.append(ip_version_)
# end class IpVersions


class CpuModes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cpu_mode=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if cpu_mode is None:
            self.cpu_mode = []
        else:
            self.cpu_mode = cpu_mode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CpuModes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CpuModes.subclass:
            return CpuModes.subclass(*args_, **kwargs_)
        else:
            return CpuModes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu_mode(self):
        return self.cpu_mode
    def set_cpu_mode(self, cpu_mode):
        self.cpu_mode = cpu_mode
    def add_cpu_mode(self, value):
        self.cpu_mode.append(value)
    def insert_cpu_mode_at(self, index, value):
        self.cpu_mode.insert(index, value)
    def replace_cpu_mode_at(self, index, value):
        self.cpu_mode[index] = value
    cpu_modeProp = property(get_cpu_mode, set_cpu_mode)
    def hasContent_(self):
        if (
            self.cpu_mode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cpu_modes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpu_modes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu_modes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cpu_modes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpu_modes'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cpu_modes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cpu_mode_ in self.cpu_mode:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpu_mode>%s</%scpu_mode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(cpu_mode_), input_name='cpu_mode')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpu_mode':
            cpu_mode_ = child_.text
            cpu_mode_ = self.gds_validate_string(cpu_mode_, node, 'cpu_mode')
            self.cpu_mode.append(cpu_mode_)
# end class CpuModes


class ScsiGenericIoOptions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sgio_options=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if sgio_options is None:
            self.sgio_options = []
        else:
            self.sgio_options = sgio_options
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScsiGenericIoOptions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScsiGenericIoOptions.subclass:
            return ScsiGenericIoOptions.subclass(*args_, **kwargs_)
        else:
            return ScsiGenericIoOptions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sgio_options(self):
        return self.sgio_options
    def set_sgio_options(self, sgio_options):
        self.sgio_options = sgio_options
    def add_sgio_options(self, value):
        self.sgio_options.append(value)
    def insert_sgio_options_at(self, index, value):
        self.sgio_options.insert(index, value)
    def replace_sgio_options_at(self, index, value):
        self.sgio_options[index] = value
    sgio_optionsProp = property(get_sgio_options, set_sgio_options)
    def hasContent_(self):
        if (
            self.sgio_options
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='sgio_options', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sgio_options')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sgio_options')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='sgio_options', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sgio_options'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='sgio_options', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sgio_options_ in self.sgio_options:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssgio_options>%s</%ssgio_options>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(sgio_options_), input_name='sgio_options')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sgio_options':
            sgio_options_ = child_.text
            sgio_options_ = self.gds_validate_string(sgio_options_, node, 'sgio_options')
            self.sgio_options.append(sgio_options_)
# end class ScsiGenericIoOptions


class PayloadEncodings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, payload_encodings=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if payload_encodings is None:
            self.payload_encodings = []
        else:
            self.payload_encodings = payload_encodings
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PayloadEncodings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PayloadEncodings.subclass:
            return PayloadEncodings.subclass(*args_, **kwargs_)
        else:
            return PayloadEncodings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payload_encodings(self):
        return self.payload_encodings
    def set_payload_encodings(self, payload_encodings):
        self.payload_encodings = payload_encodings
    def add_payload_encodings(self, value):
        self.payload_encodings.append(value)
    def insert_payload_encodings_at(self, index, value):
        self.payload_encodings.insert(index, value)
    def replace_payload_encodings_at(self, index, value):
        self.payload_encodings[index] = value
    payload_encodingsProp = property(get_payload_encodings, set_payload_encodings)
    def hasContent_(self):
        if (
            self.payload_encodings
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='payload_encodings', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('payload_encodings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='payload_encodings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='payload_encodings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='payload_encodings'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='payload_encodings', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for payload_encodings_ in self.payload_encodings:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spayload_encodings>%s</%spayload_encodings>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(payload_encodings_), input_name='payload_encodings')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payload_encodings':
            payload_encodings_ = child_.text
            payload_encodings_ = self.gds_validate_string(payload_encodings_, node, 'payload_encodings')
            self.payload_encodings.append(payload_encodings_)
# end class PayloadEncodings


class WatchdogActions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if action is None:
            self.action = []
        else:
            self.action = action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WatchdogActions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WatchdogActions.subclass:
            return WatchdogActions.subclass(*args_, **kwargs_)
        else:
            return WatchdogActions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self):
        return self.action
    def set_action(self, action):
        self.action = action
    def add_action(self, value):
        self.action.append(value)
    def insert_action_at(self, index, value):
        self.action.insert(index, value)
    def replace_action_at(self, index, value):
        self.action[index] = value
    actionProp = property(get_action, set_action)
    def hasContent_(self):
        if (
            self.action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='watchdog_actions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('watchdog_actions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='watchdog_actions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='watchdog_actions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='watchdog_actions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='watchdog_actions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for action_ in self.action:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(action_), input_name='action')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action.append(action_)
# end class WatchdogActions


class WatchdogModels(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, model=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if model is None:
            self.model = []
        else:
            self.model = model
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WatchdogModels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WatchdogModels.subclass:
            return WatchdogModels.subclass(*args_, **kwargs_)
        else:
            return WatchdogModels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    def add_model(self, value):
        self.model.append(value)
    def insert_model_at(self, index, value):
        self.model.insert(index, value)
    def replace_model_at(self, index, value):
        self.model[index] = value
    modelProp = property(get_model, set_model)
    def hasContent_(self):
        if (
            self.model
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='watchdog_models', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('watchdog_models')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='watchdog_models')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='watchdog_models', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='watchdog_models'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='watchdog_models', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for model_ in self.model:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodel>%s</%smodel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(model_), input_name='model')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'model':
            model_ = child_.text
            model_ = self.gds_validate_string(model_, node, 'model')
            self.model.append(model_)
# end class WatchdogModels


class SnapshotStatuses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, snapshot_status=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if snapshot_status is None:
            self.snapshot_status = []
        else:
            self.snapshot_status = snapshot_status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SnapshotStatuses)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SnapshotStatuses.subclass:
            return SnapshotStatuses.subclass(*args_, **kwargs_)
        else:
            return SnapshotStatuses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_snapshot_status(self):
        return self.snapshot_status
    def set_snapshot_status(self, snapshot_status):
        self.snapshot_status = snapshot_status
    def add_snapshot_status(self, value):
        self.snapshot_status.append(value)
    def insert_snapshot_status_at(self, index, value):
        self.snapshot_status.insert(index, value)
    def replace_snapshot_status_at(self, index, value):
        self.snapshot_status[index] = value
    snapshot_statusProp = property(get_snapshot_status, set_snapshot_status)
    def hasContent_(self):
        if (
            self.snapshot_status
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='snapshot_statuses', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('snapshot_statuses')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='snapshot_statuses')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='snapshot_statuses', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='snapshot_statuses'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='snapshot_statuses', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for snapshot_status_ in self.snapshot_status:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssnapshot_status>%s</%ssnapshot_status>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(snapshot_status_), input_name='snapshot_status')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'snapshot_status':
            snapshot_status_ = child_.text
            snapshot_status_ = self.gds_validate_string(snapshot_status_, node, 'snapshot_status')
            self.snapshot_status.append(snapshot_status_)
# end class SnapshotStatuses


class SsoMethods(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sso_method=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if sso_method is None:
            self.sso_method = []
        else:
            self.sso_method = sso_method
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SsoMethods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SsoMethods.subclass:
            return SsoMethods.subclass(*args_, **kwargs_)
        else:
            return SsoMethods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sso_method(self):
        return self.sso_method
    def set_sso_method(self, sso_method):
        self.sso_method = sso_method
    def add_sso_method(self, value):
        self.sso_method.append(value)
    def insert_sso_method_at(self, index, value):
        self.sso_method.insert(index, value)
    def replace_sso_method_at(self, index, value):
        self.sso_method[index] = value
    sso_methodProp = property(get_sso_method, set_sso_method)
    def hasContent_(self):
        if (
            self.sso_method
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='sso_methods', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sso_methods')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sso_methods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='sso_methods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sso_methods'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='sso_methods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sso_method_ in self.sso_method:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssso_method>%s</%ssso_method>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(sso_method_), input_name='sso_method')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sso_method':
            sso_method_ = child_.text
            sso_method_ = self.gds_validate_string(sso_method_, node, 'sso_method')
            self.sso_method.append(sso_method_)
# end class SsoMethods


class KdumpStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kdump_status=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if kdump_status is None:
            self.kdump_status = []
        else:
            self.kdump_status = kdump_status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KdumpStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KdumpStates.subclass:
            return KdumpStates.subclass(*args_, **kwargs_)
        else:
            return KdumpStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kdump_status(self):
        return self.kdump_status
    def set_kdump_status(self, kdump_status):
        self.kdump_status = kdump_status
    def add_kdump_status(self, value):
        self.kdump_status.append(value)
    def insert_kdump_status_at(self, index, value):
        self.kdump_status.insert(index, value)
    def replace_kdump_status_at(self, index, value):
        self.kdump_status[index] = value
    kdump_statusProp = property(get_kdump_status, set_kdump_status)
    def hasContent_(self):
        if (
            self.kdump_status
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='kdump_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('kdump_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kdump_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='kdump_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='kdump_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='kdump_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for kdump_status_ in self.kdump_status:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skdump_status>%s</%skdump_status>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(kdump_status_), input_name='kdump_status')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kdump_status':
            kdump_status_ = child_.text
            kdump_status_ = self.gds_validate_string(kdump_status_, node, 'kdump_status')
            self.kdump_status.append(kdump_status_)
# end class KdumpStates


class SpmStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, spm_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if spm_state is None:
            self.spm_state = []
        else:
            self.spm_state = spm_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpmStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpmStates.subclass:
            return SpmStates.subclass(*args_, **kwargs_)
        else:
            return SpmStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_spm_state(self):
        return self.spm_state
    def set_spm_state(self, spm_state):
        self.spm_state = spm_state
    def add_spm_state(self, value):
        self.spm_state.append(value)
    def insert_spm_state_at(self, index, value):
        self.spm_state.insert(index, value)
    def replace_spm_state_at(self, index, value):
        self.spm_state[index] = value
    spm_stateProp = property(get_spm_state, set_spm_state)
    def hasContent_(self):
        if (
            self.spm_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='spm_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spm_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spm_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='spm_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='spm_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='spm_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for spm_state_ in self.spm_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspm_state>%s</%sspm_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(spm_state_), input_name='spm_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'spm_state':
            spm_state_ = child_.text
            spm_state_ = self.gds_validate_string(spm_state_, node, 'spm_state')
            self.spm_state.append(spm_state_)
# end class SpmStates


class NetworkPluginTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, network_plugin_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if network_plugin_type is None:
            self.network_plugin_type = []
        else:
            self.network_plugin_type = network_plugin_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetworkPluginTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetworkPluginTypes.subclass:
            return NetworkPluginTypes.subclass(*args_, **kwargs_)
        else:
            return NetworkPluginTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_plugin_type(self):
        return self.network_plugin_type
    def set_network_plugin_type(self, network_plugin_type):
        self.network_plugin_type = network_plugin_type
    def add_network_plugin_type(self, value):
        self.network_plugin_type.append(value)
    def insert_network_plugin_type_at(self, index, value):
        self.network_plugin_type.insert(index, value)
    def replace_network_plugin_type_at(self, index, value):
        self.network_plugin_type[index] = value
    network_plugin_typeProp = property(get_network_plugin_type, set_network_plugin_type)
    def hasContent_(self):
        if (
            self.network_plugin_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='network_plugin_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('network_plugin_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_plugin_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='network_plugin_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='network_plugin_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='network_plugin_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for network_plugin_type_ in self.network_plugin_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork_plugin_type>%s</%snetwork_plugin_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(network_plugin_type_), input_name='network_plugin_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network_plugin_type':
            network_plugin_type_ = child_.text
            network_plugin_type_ = self.gds_validate_string(network_plugin_type_, node, 'network_plugin_type')
            self.network_plugin_type.append(network_plugin_type_)
# end class NetworkPluginTypes


class MessageBrokerTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, message_broker_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if message_broker_type is None:
            self.message_broker_type = []
        else:
            self.message_broker_type = message_broker_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessageBrokerTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessageBrokerTypes.subclass:
            return MessageBrokerTypes.subclass(*args_, **kwargs_)
        else:
            return MessageBrokerTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_message_broker_type(self):
        return self.message_broker_type
    def set_message_broker_type(self, message_broker_type):
        self.message_broker_type = message_broker_type
    def add_message_broker_type(self, value):
        self.message_broker_type.append(value)
    def insert_message_broker_type_at(self, index, value):
        self.message_broker_type.insert(index, value)
    def replace_message_broker_type_at(self, index, value):
        self.message_broker_type[index] = value
    message_broker_typeProp = property(get_message_broker_type, set_message_broker_type)
    def hasContent_(self):
        if (
            self.message_broker_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='message_broker_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('message_broker_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='message_broker_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='message_broker_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='message_broker_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='message_broker_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for message_broker_type_ in self.message_broker_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smessage_broker_type>%s</%smessage_broker_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(message_broker_type_), input_name='message_broker_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'message_broker_type':
            message_broker_type_ = child_.text
            message_broker_type_ = self.gds_validate_string(message_broker_type_, node, 'message_broker_type')
            self.message_broker_type.append(message_broker_type_)
# end class MessageBrokerTypes


class HostStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if host_state is None:
            self.host_state = []
        else:
            self.host_state = host_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostStates.subclass:
            return HostStates.subclass(*args_, **kwargs_)
        else:
            return HostStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_state(self):
        return self.host_state
    def set_host_state(self, host_state):
        self.host_state = host_state
    def add_host_state(self, value):
        self.host_state.append(value)
    def insert_host_state_at(self, index, value):
        self.host_state.insert(index, value)
    def replace_host_state_at(self, index, value):
        self.host_state[index] = value
    host_stateProp = property(get_host_state, set_host_state)
    def hasContent_(self):
        if (
            self.host_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_state_ in self.host_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost_state>%s</%shost_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(host_state_), input_name='host_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_state':
            host_state_ = child_.text
            host_state_ = self.gds_validate_string(host_state_, node, 'host_state')
            self.host_state.append(host_state_)
# end class HostStates


class ExternalStatuses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, external_status=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if external_status is None:
            self.external_status = []
        else:
            self.external_status = external_status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalStatuses)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalStatuses.subclass:
            return ExternalStatuses.subclass(*args_, **kwargs_)
        else:
            return ExternalStatuses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_status(self):
        return self.external_status
    def set_external_status(self, external_status):
        self.external_status = external_status
    def add_external_status(self, value):
        self.external_status.append(value)
    def insert_external_status_at(self, index, value):
        self.external_status.insert(index, value)
    def replace_external_status_at(self, index, value):
        self.external_status[index] = value
    external_statusProp = property(get_external_status, set_external_status)
    def hasContent_(self):
        if (
            self.external_status
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_statuses', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_statuses')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_statuses')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_statuses', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_statuses'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_statuses', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_status_ in self.external_status:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal_status>%s</%sexternal_status>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(external_status_), input_name='external_status')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_status':
            external_status_ = child_.text
            external_status_ = self.gds_validate_string(external_status_, node, 'external_status')
            self.external_status.append(external_status_)
# end class ExternalStatuses


class QuotaModeTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, quota_mode_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if quota_mode_type is None:
            self.quota_mode_type = []
        else:
            self.quota_mode_type = quota_mode_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotaModeTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotaModeTypes.subclass:
            return QuotaModeTypes.subclass(*args_, **kwargs_)
        else:
            return QuotaModeTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quota_mode_type(self):
        return self.quota_mode_type
    def set_quota_mode_type(self, quota_mode_type):
        self.quota_mode_type = quota_mode_type
    def add_quota_mode_type(self, value):
        self.quota_mode_type.append(value)
    def insert_quota_mode_type_at(self, index, value):
        self.quota_mode_type.insert(index, value)
    def replace_quota_mode_type_at(self, index, value):
        self.quota_mode_type[index] = value
    quota_mode_typeProp = property(get_quota_mode_type, set_quota_mode_type)
    def hasContent_(self):
        if (
            self.quota_mode_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='quota_mode_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quota_mode_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quota_mode_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='quota_mode_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quota_mode_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='quota_mode_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for quota_mode_type_ in self.quota_mode_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squota_mode_type>%s</%squota_mode_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(quota_mode_type_), input_name='quota_mode_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quota_mode_type':
            quota_mode_type_ = child_.text
            quota_mode_type_ = self.gds_validate_string(quota_mode_type_, node, 'quota_mode_type')
            self.quota_mode_type.append(quota_mode_type_)
# end class QuotaModeTypes


class ArchitectureCapability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, architectures=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        if architectures is None:
            self.architectures = []
        else:
            self.architectures = architectures
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArchitectureCapability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArchitectureCapability.subclass:
            return ArchitectureCapability.subclass(*args_, **kwargs_)
        else:
            return ArchitectureCapability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_architectures(self):
        return self.architectures
    def set_architectures(self, architectures):
        self.architectures = architectures
    def add_architectures(self, value):
        self.architectures.append(value)
    def insert_architectures_at(self, index, value):
        self.architectures.insert(index, value)
    def replace_architectures_at(self, index, value):
        self.architectures[index] = value
    architecturesProp = property(get_architectures, set_architectures)
    def hasContent_(self):
        if (
            self.name is not None or
            self.architectures
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='architecture_capability', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('architecture_capability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='architecture_capability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='architecture_capability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='architecture_capability'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='architecture_capability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        for architectures_ in self.architectures:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarchitectures>%s</%sarchitectures>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(architectures_), input_name='architectures')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'architectures':
            architectures_ = child_.text
            architectures_ = self.gds_validate_string(architectures_, node, 'architectures')
            self.architectures.append(architectures_)
# end class ArchitectureCapability


class ArchitectureCapabilities(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, architecture_capability=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if architecture_capability is None:
            self.architecture_capability = []
        else:
            self.architecture_capability = architecture_capability
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ArchitectureCapabilities)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ArchitectureCapabilities.subclass:
            return ArchitectureCapabilities.subclass(*args_, **kwargs_)
        else:
            return ArchitectureCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_architecture_capability(self):
        return self.architecture_capability
    def set_architecture_capability(self, architecture_capability):
        self.architecture_capability = architecture_capability
    def add_architecture_capability(self, value):
        self.architecture_capability.append(value)
    def insert_architecture_capability_at(self, index, value):
        self.architecture_capability.insert(index, value)
    def replace_architecture_capability_at(self, index, value):
        self.architecture_capability[index] = value
    architecture_capabilityProp = property(get_architecture_capability, set_architecture_capability)
    def hasContent_(self):
        if (
            self.architecture_capability
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='architecture_capabilities', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('architecture_capabilities')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='architecture_capabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='architecture_capabilities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='architecture_capabilities'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='architecture_capabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for architecture_capability_ in self.architecture_capability:
            architecture_capability_.export(outfile, level, namespaceprefix_, name_='architecture_capability', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'architecture_capability':
            obj_ = ArchitectureCapability.factory(parent_object_=self)
            obj_.build(child_)
            self.architecture_capability.append(obj_)
            obj_.original_tagname_ = 'architecture_capability'
# end class ArchitectureCapabilities


class SerialNumberPolicies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, serial_number_policy=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if serial_number_policy is None:
            self.serial_number_policy = []
        else:
            self.serial_number_policy = serial_number_policy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SerialNumberPolicies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SerialNumberPolicies.subclass:
            return SerialNumberPolicies.subclass(*args_, **kwargs_)
        else:
            return SerialNumberPolicies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serial_number_policy(self):
        return self.serial_number_policy
    def set_serial_number_policy(self, serial_number_policy):
        self.serial_number_policy = serial_number_policy
    def add_serial_number_policy(self, value):
        self.serial_number_policy.append(value)
    def insert_serial_number_policy_at(self, index, value):
        self.serial_number_policy.insert(index, value)
    def replace_serial_number_policy_at(self, index, value):
        self.serial_number_policy[index] = value
    serial_number_policyProp = property(get_serial_number_policy, set_serial_number_policy)
    def hasContent_(self):
        if (
            self.serial_number_policy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='serial_number_policies', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serial_number_policies')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='serial_number_policies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='serial_number_policies', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='serial_number_policies'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='serial_number_policies', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for serial_number_policy_ in self.serial_number_policy:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserial_number_policy>%s</%sserial_number_policy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(serial_number_policy_), input_name='serial_number_policy')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serial_number_policy':
            serial_number_policy_ = child_.text
            serial_number_policy_ = self.gds_validate_string(serial_number_policy_, node, 'serial_number_policy')
            self.serial_number_policy.append(serial_number_policy_)
# end class SerialNumberPolicies


class DisplayDisconnectActions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, display_disconnect_action=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if display_disconnect_action is None:
            self.display_disconnect_action = []
        else:
            self.display_disconnect_action = display_disconnect_action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DisplayDisconnectActions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DisplayDisconnectActions.subclass:
            return DisplayDisconnectActions.subclass(*args_, **kwargs_)
        else:
            return DisplayDisconnectActions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_display_disconnect_action(self):
        return self.display_disconnect_action
    def set_display_disconnect_action(self, display_disconnect_action):
        self.display_disconnect_action = display_disconnect_action
    def add_display_disconnect_action(self, value):
        self.display_disconnect_action.append(value)
    def insert_display_disconnect_action_at(self, index, value):
        self.display_disconnect_action.insert(index, value)
    def replace_display_disconnect_action_at(self, index, value):
        self.display_disconnect_action[index] = value
    display_disconnect_actionProp = property(get_display_disconnect_action, set_display_disconnect_action)
    def hasContent_(self):
        if (
            self.display_disconnect_action
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='display_disconnect_actions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('display_disconnect_actions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='display_disconnect_actions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='display_disconnect_actions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='display_disconnect_actions'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='display_disconnect_actions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for display_disconnect_action_ in self.display_disconnect_action:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay_disconnect_action>%s</%sdisplay_disconnect_action>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(display_disconnect_action_), input_name='display_disconnect_action')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'display_disconnect_action':
            display_disconnect_action_ = child_.text
            display_disconnect_action_ = self.gds_validate_string(display_disconnect_action_, node, 'display_disconnect_action')
            self.display_disconnect_action.append(display_disconnect_action_)
# end class DisplayDisconnectActions


class SELinuxModes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, selinux_mode=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if selinux_mode is None:
            self.selinux_mode = []
        else:
            self.selinux_mode = selinux_mode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SELinuxModes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SELinuxModes.subclass:
            return SELinuxModes.subclass(*args_, **kwargs_)
        else:
            return SELinuxModes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_selinux_mode(self):
        return self.selinux_mode
    def set_selinux_mode(self, selinux_mode):
        self.selinux_mode = selinux_mode
    def add_selinux_mode(self, value):
        self.selinux_mode.append(value)
    def insert_selinux_mode_at(self, index, value):
        self.selinux_mode.insert(index, value)
    def replace_selinux_mode_at(self, index, value):
        self.selinux_mode[index] = value
    selinux_modeProp = property(get_selinux_mode, set_selinux_mode)
    def hasContent_(self):
        if (
            self.selinux_mode
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='selinux_modes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selinux_modes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selinux_modes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='selinux_modes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='selinux_modes'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='selinux_modes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for selinux_mode_ in self.selinux_mode:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sselinux_mode>%s</%sselinux_mode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(selinux_mode_), input_name='selinux_mode')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'selinux_mode':
            selinux_mode_ = child_.text
            selinux_mode_ = self.gds_validate_string(selinux_mode_, node, 'selinux_mode')
            self.selinux_mode.append(selinux_mode_)
# end class SELinuxModes


class SchedulingPolicyUnitTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scheduling_policy_unit_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if scheduling_policy_unit_type is None:
            self.scheduling_policy_unit_type = []
        else:
            self.scheduling_policy_unit_type = scheduling_policy_unit_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicyUnitTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicyUnitTypes.subclass:
            return SchedulingPolicyUnitTypes.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicyUnitTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduling_policy_unit_type(self):
        return self.scheduling_policy_unit_type
    def set_scheduling_policy_unit_type(self, scheduling_policy_unit_type):
        self.scheduling_policy_unit_type = scheduling_policy_unit_type
    def add_scheduling_policy_unit_type(self, value):
        self.scheduling_policy_unit_type.append(value)
    def insert_scheduling_policy_unit_type_at(self, index, value):
        self.scheduling_policy_unit_type.insert(index, value)
    def replace_scheduling_policy_unit_type_at(self, index, value):
        self.scheduling_policy_unit_type[index] = value
    scheduling_policy_unit_typeProp = property(get_scheduling_policy_unit_type, set_scheduling_policy_unit_type)
    def hasContent_(self):
        if (
            self.scheduling_policy_unit_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='scheduling_policy_unit_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scheduling_policy_unit_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy_unit_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='scheduling_policy_unit_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scheduling_policy_unit_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='scheduling_policy_unit_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for scheduling_policy_unit_type_ in self.scheduling_policy_unit_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscheduling_policy_unit_type>%s</%sscheduling_policy_unit_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(scheduling_policy_unit_type_), input_name='scheduling_policy_unit_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduling_policy_unit_type':
            scheduling_policy_unit_type_ = child_.text
            scheduling_policy_unit_type_ = self.gds_validate_string(scheduling_policy_unit_type_, node, 'scheduling_policy_unit_type')
            self.scheduling_policy_unit_type.append(scheduling_policy_unit_type_)
# end class SchedulingPolicyUnitTypes


class VmPoolTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vm_pool_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vm_pool_type is None:
            self.vm_pool_type = []
        else:
            self.vm_pool_type = vm_pool_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmPoolTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmPoolTypes.subclass:
            return VmPoolTypes.subclass(*args_, **kwargs_)
        else:
            return VmPoolTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm_pool_type(self):
        return self.vm_pool_type
    def set_vm_pool_type(self, vm_pool_type):
        self.vm_pool_type = vm_pool_type
    def add_vm_pool_type(self, value):
        self.vm_pool_type.append(value)
    def insert_vm_pool_type_at(self, index, value):
        self.vm_pool_type.insert(index, value)
    def replace_vm_pool_type_at(self, index, value):
        self.vm_pool_type[index] = value
    vm_pool_typeProp = property(get_vm_pool_type, set_vm_pool_type)
    def hasContent_(self):
        if (
            self.vm_pool_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_pool_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_pool_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_pool_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_pool_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_pool_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_pool_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_pool_type_ in self.vm_pool_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svm_pool_type>%s</%svm_pool_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(vm_pool_type_), input_name='vm_pool_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm_pool_type':
            vm_pool_type_ = child_.text
            vm_pool_type_ = self.gds_validate_string(vm_pool_type_, node, 'vm_pool_type')
            self.vm_pool_type.append(vm_pool_type_)
# end class VmPoolTypes


class ActionableResource(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, actions=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.actions = actions
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActionableResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActionableResource.subclass:
            return ActionableResource.subclass(*args_, **kwargs_)
        else:
            return ActionableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_actions(self):
        return self.actions
    def set_actions(self, actions):
        self.actions = actions
    actionsProp = property(get_actions, set_actions)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.actions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ActionableResource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActionableResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActionableResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ActionableResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActionableResource'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ActionableResource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.actions is not None:
            self.actions.export(outfile, level, namespaceprefix_, name_='actions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'actions':
            obj_ = Actions.factory(parent_object_=self)
            obj_.build(child_)
            self.actions = obj_
            obj_.original_tagname_ = 'actions'
# end class ActionableResource


class BaseResource(ActionableResource):
    subclass = None
    superclass = ActionableResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BaseResource, self).__init__(actions, extensiontype_,  **kwargs_)
        self.href = _cast(None, href)
        self.id = _cast(None, id)
        self.name = name
        self.description = description
        self.comment = comment
        self.creation_status = creation_status
        if link is None:
            self.link = []
        else:
            self.link = link
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseResource.subclass:
            return BaseResource.subclass(*args_, **kwargs_)
        else:
            return BaseResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    descriptionProp = property(get_description, set_description)
    def get_comment(self):
        return self.comment
    def set_comment(self, comment):
        self.comment = comment
    commentProp = property(get_comment, set_comment)
    def get_creation_status(self):
        return self.creation_status
    def set_creation_status(self, creation_status):
        self.creation_status = creation_status
    creation_statusProp = property(get_creation_status, set_creation_status)
    def get_link(self):
        return self.link
    def set_link(self, link):
        self.link = link
    def add_link(self, value):
        self.link.append(value)
    def insert_link_at(self, index, value):
        self.link.insert(index, value)
    def replace_link_at(self, index, value):
        self.link[index] = value
    linkProp = property(get_link, set_link)
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    hrefProp = property(get_href, set_href)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    idProp = property(get_id, set_id)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.name is not None or
            self.description is not None or
            self.comment is not None or
            self.creation_status is not None or
            self.link or
            super(BaseResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BaseResource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='BaseResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseResource'):
        super(BaseResource, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseResource')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BaseResource', fromsubclass_=False, pretty_print=True):
        super(BaseResource, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.comment is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomment>%s</%scomment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.comment), input_name='comment')), namespaceprefix_ , eol_))
        if self.creation_status is not None:
            self.creation_status.export(outfile, level, namespaceprefix_, name_='creation_status', pretty_print=pretty_print)
        for link_ in self.link:
            link_.export(outfile, level, namespaceprefix_, name_='link', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
        elif nodeName_ == 'creation_status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.creation_status = obj_
            obj_.original_tagname_ = 'creation_status'
        elif nodeName_ == 'link':
            class_obj_ = self.get_class_obj_(child_, Link)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        super(BaseResource, self).buildChildren(child_, node, nodeName_, True)
# end class BaseResource


class BaseResources(ActionableResource):
    subclass = None
    superclass = ActionableResource
    def __init__(self, actions=None, size=None, total=None, active=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BaseResources, self).__init__(actions, extensiontype_,  **kwargs_)
        self.size = size
        self.total = total
        self.active = active
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseResources)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseResources.subclass:
            return BaseResources.subclass(*args_, **kwargs_)
        else:
            return BaseResources(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    sizeProp = property(get_size, set_size)
    def get_total(self):
        return self.total
    def set_total(self, total):
        self.total = total
    totalProp = property(get_total, set_total)
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    activeProp = property(get_active, set_active)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.size is not None or
            self.total is not None or
            self.active is not None or
            super(BaseResources, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BaseResources', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseResources')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseResources')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='BaseResources', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseResources'):
        super(BaseResources, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseResources')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BaseResources', fromsubclass_=False, pretty_print=True):
        super(BaseResources, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_format_integer(self.size, input_name='size'), namespaceprefix_ , eol_))
        if self.total is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotal>%s</%stotal>%s' % (namespaceprefix_ , self.gds_format_integer(self.total, input_name='total'), namespaceprefix_ , eol_))
        if self.active is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactive>%s</%sactive>%s' % (namespaceprefix_ , self.gds_format_integer(self.active, input_name='active'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseResources, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'total' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'total')
            self.total = ival_
        elif nodeName_ == 'active' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'active')
            self.active = ival_
        super(BaseResources, self).buildChildren(child_, node, nodeName_, True)
# end class BaseResources


class Option(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Option)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Option.subclass:
            return Option.subclass(*args_, **kwargs_)
        else:
            return Option(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Option', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Option')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Option')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Option', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Option'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Option', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Option


class Options(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, option=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if option is None:
            self.option = []
        else:
            self.option = option
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Options)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Options.subclass:
            return Options.subclass(*args_, **kwargs_)
        else:
            return Options(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_option(self):
        return self.option
    def set_option(self, option):
        self.option = option
    def add_option(self, value):
        self.option.append(value)
    def insert_option_at(self, index, value):
        self.option.insert(index, value)
    def replace_option_at(self, index, value):
        self.option[index] = value
    optionProp = property(get_option, set_option)
    def hasContent_(self):
        if (
            self.option
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='options', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('options')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='options')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='options', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='options'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='options', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for option_ in self.option:
            option_.export(outfile, level, namespaceprefix_, name_='option', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'option':
            obj_ = Option.factory(parent_object_=self)
            obj_.build(child_)
            self.option.append(obj_)
            obj_.original_tagname_ = 'option'
# end class Options


class InheritableBooleans(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inheritable_boolean=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if inheritable_boolean is None:
            self.inheritable_boolean = []
        else:
            self.inheritable_boolean = inheritable_boolean
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InheritableBooleans)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InheritableBooleans.subclass:
            return InheritableBooleans.subclass(*args_, **kwargs_)
        else:
            return InheritableBooleans(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inheritable_boolean(self):
        return self.inheritable_boolean
    def set_inheritable_boolean(self, inheritable_boolean):
        self.inheritable_boolean = inheritable_boolean
    def add_inheritable_boolean(self, value):
        self.inheritable_boolean.append(value)
    def insert_inheritable_boolean_at(self, index, value):
        self.inheritable_boolean.insert(index, value)
    def replace_inheritable_boolean_at(self, index, value):
        self.inheritable_boolean[index] = value
    inheritable_booleanProp = property(get_inheritable_boolean, set_inheritable_boolean)
    def hasContent_(self):
        if (
            self.inheritable_boolean
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='inheritable_booleans', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('inheritable_booleans')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='inheritable_booleans')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='inheritable_booleans', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='inheritable_booleans'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='inheritable_booleans', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for inheritable_boolean_ in self.inheritable_boolean:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinheritable_boolean>%s</%sinheritable_boolean>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(inheritable_boolean_), input_name='inheritable_boolean')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inheritable_boolean':
            inheritable_boolean_ = child_.text
            inheritable_boolean_ = self.gds_validate_string(inheritable_boolean_, node, 'inheritable_boolean')
            self.inheritable_boolean.append(inheritable_boolean_)
# end class InheritableBooleans


class MacPool(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, allow_duplicates=None, default_pool=None, ranges=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(MacPool, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.allow_duplicates = allow_duplicates
        self.default_pool = default_pool
        self.ranges = ranges
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MacPool)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MacPool.subclass:
            return MacPool.subclass(*args_, **kwargs_)
        else:
            return MacPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allow_duplicates(self):
        return self.allow_duplicates
    def set_allow_duplicates(self, allow_duplicates):
        self.allow_duplicates = allow_duplicates
    allow_duplicatesProp = property(get_allow_duplicates, set_allow_duplicates)
    def get_default_pool(self):
        return self.default_pool
    def set_default_pool(self, default_pool):
        self.default_pool = default_pool
    default_poolProp = property(get_default_pool, set_default_pool)
    def get_ranges(self):
        return self.ranges
    def set_ranges(self, ranges):
        self.ranges = ranges
    rangesProp = property(get_ranges, set_ranges)
    def hasContent_(self):
        if (
            self.allow_duplicates is not None or
            self.default_pool is not None or
            self.ranges is not None or
            super(MacPool, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='mac_pool', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mac_pool')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mac_pool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='mac_pool', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mac_pool'):
        super(MacPool, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mac_pool')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='mac_pool', fromsubclass_=False, pretty_print=True):
        super(MacPool, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.allow_duplicates is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallow_duplicates>%s</%sallow_duplicates>%s' % (namespaceprefix_ , self.gds_format_boolean(self.allow_duplicates, input_name='allow_duplicates'), namespaceprefix_ , eol_))
        if self.default_pool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefault_pool>%s</%sdefault_pool>%s' % (namespaceprefix_ , self.gds_format_boolean(self.default_pool, input_name='default_pool'), namespaceprefix_ , eol_))
        if self.ranges is not None:
            self.ranges.export(outfile, level, namespaceprefix_, name_='ranges', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MacPool, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allow_duplicates':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allow_duplicates')
            self.allow_duplicates = ival_
        elif nodeName_ == 'default_pool':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'default_pool')
            self.default_pool = ival_
        elif nodeName_ == 'ranges':
            obj_ = Ranges.factory(parent_object_=self)
            obj_.build(child_)
            self.ranges = obj_
            obj_.original_tagname_ = 'ranges'
        super(MacPool, self).buildChildren(child_, node, nodeName_, True)
# end class MacPool


class MacPools(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, mac_pool=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(MacPools, self).__init__(actions, size, total, active,  **kwargs_)
        if mac_pool is None:
            self.mac_pool = []
        else:
            self.mac_pool = mac_pool
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MacPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MacPools.subclass:
            return MacPools.subclass(*args_, **kwargs_)
        else:
            return MacPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mac_pool(self):
        return self.mac_pool
    def set_mac_pool(self, mac_pool):
        self.mac_pool = mac_pool
    def add_mac_pool(self, value):
        self.mac_pool.append(value)
    def insert_mac_pool_at(self, index, value):
        self.mac_pool.insert(index, value)
    def replace_mac_pool_at(self, index, value):
        self.mac_pool[index] = value
    mac_poolProp = property(get_mac_pool, set_mac_pool)
    def hasContent_(self):
        if (
            self.mac_pool or
            super(MacPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='mac_pools', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mac_pools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mac_pools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='mac_pools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mac_pools'):
        super(MacPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mac_pools')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='mac_pools', fromsubclass_=False, pretty_print=True):
        super(MacPools, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for mac_pool_ in self.mac_pool:
            mac_pool_.export(outfile, level, namespaceprefix_, name_='mac_pool', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MacPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mac_pool':
            obj_ = MacPool.factory(parent_object_=self)
            obj_.build(child_)
            self.mac_pool.append(obj_)
            obj_.original_tagname_ = 'mac_pool'
        super(MacPools, self).buildChildren(child_, node, nodeName_, True)
# end class MacPools


class Range(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.from_ = from_
        self.to = to
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Range)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Range.subclass:
            return Range.subclass(*args_, **kwargs_)
        else:
            return Range(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    fromProp = property(get_from, set_from)
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    toProp = property(get_to, set_to)
    def hasContent_(self):
        if (
            self.from_ is not None or
            self.to is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='range', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('range')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='range')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='range', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='range'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='range', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.from_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfrom>%s</%sfrom>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.from_), input_name='from')), namespaceprefix_ , eol_))
        if self.to is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sto>%s</%sto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.to), input_name='to')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'from':
            from_ = child_.text
            from_ = self.gds_validate_string(from_, node, 'from')
            self.from_ = from_
        elif nodeName_ == 'to':
            to_ = child_.text
            to_ = self.gds_validate_string(to_, node, 'to')
            self.to = to_
# end class Range


class Ranges(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, range=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if range is None:
            self.range = []
        else:
            self.range = range
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Ranges)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Ranges.subclass:
            return Ranges.subclass(*args_, **kwargs_)
        else:
            return Ranges(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_range(self):
        return self.range
    def set_range(self, range):
        self.range = range
    def add_range(self, value):
        self.range.append(value)
    def insert_range_at(self, index, value):
        self.range.insert(index, value)
    def replace_range_at(self, index, value):
        self.range[index] = value
    rangeProp = property(get_range, set_range)
    def hasContent_(self):
        if (
            self.range
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ranges', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ranges')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ranges')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ranges', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ranges'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ranges', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for range_ in self.range:
            range_.export(outfile, level, namespaceprefix_, name_='range', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'range':
            obj_ = Range.factory(parent_object_=self)
            obj_.build(child_)
            self.range.append(obj_)
            obj_.original_tagname_ = 'range'
# end class Ranges


class DataCenter(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, storage_type=None, local=None, storage_format=None, version=None, supported_versions=None, status=None, mac_pool=None, quota_mode=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DataCenter, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.storage_type = storage_type
        self.local = local
        self.storage_format = storage_format
        self.version = version
        self.supported_versions = supported_versions
        self.status = status
        self.mac_pool = mac_pool
        self.quota_mode = quota_mode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataCenter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataCenter.subclass:
            return DataCenter.subclass(*args_, **kwargs_)
        else:
            return DataCenter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_type(self):
        return self.storage_type
    def set_storage_type(self, storage_type):
        self.storage_type = storage_type
    storage_typeProp = property(get_storage_type, set_storage_type)
    def get_local(self):
        return self.local
    def set_local(self, local):
        self.local = local
    localProp = property(get_local, set_local)
    def get_storage_format(self):
        return self.storage_format
    def set_storage_format(self, storage_format):
        self.storage_format = storage_format
    storage_formatProp = property(get_storage_format, set_storage_format)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_supported_versions(self):
        return self.supported_versions
    def set_supported_versions(self, supported_versions):
        self.supported_versions = supported_versions
    supported_versionsProp = property(get_supported_versions, set_supported_versions)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_mac_pool(self):
        return self.mac_pool
    def set_mac_pool(self, mac_pool):
        self.mac_pool = mac_pool
    mac_poolProp = property(get_mac_pool, set_mac_pool)
    def get_quota_mode(self):
        return self.quota_mode
    def set_quota_mode(self, quota_mode):
        self.quota_mode = quota_mode
    quota_modeProp = property(get_quota_mode, set_quota_mode)
    def hasContent_(self):
        if (
            self.storage_type is not None or
            self.local is not None or
            self.storage_format is not None or
            self.version is not None or
            self.supported_versions is not None or
            self.status is not None or
            self.mac_pool is not None or
            self.quota_mode is not None or
            super(DataCenter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='data_center', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('data_center')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data_center')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='data_center'):
        super(DataCenter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data_center')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='data_center', fromsubclass_=False, pretty_print=True):
        super(DataCenter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.storage_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_type>%s</%sstorage_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.storage_type), input_name='storage_type')), namespaceprefix_ , eol_))
        if self.local is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal>%s</%slocal>%s' % (namespaceprefix_ , self.gds_format_boolean(self.local, input_name='local'), namespaceprefix_ , eol_))
        if self.storage_format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_format>%s</%sstorage_format>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.storage_format), input_name='storage_format')), namespaceprefix_ , eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.supported_versions is not None:
            self.supported_versions.export(outfile, level, namespaceprefix_, name_='supported_versions', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.mac_pool is not None:
            self.mac_pool.export(outfile, level, namespaceprefix_, name_='mac_pool', pretty_print=pretty_print)
        if self.quota_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squota_mode>%s</%squota_mode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.quota_mode), input_name='quota_mode')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataCenter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_type':
            storage_type_ = child_.text
            storage_type_ = self.gds_validate_string(storage_type_, node, 'storage_type')
            self.storage_type = storage_type_
        elif nodeName_ == 'local':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'local')
            self.local = ival_
        elif nodeName_ == 'storage_format':
            storage_format_ = child_.text
            storage_format_ = self.gds_validate_string(storage_format_, node, 'storage_format')
            self.storage_format = storage_format_
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'supported_versions':
            obj_ = SupportedVersions.factory(parent_object_=self)
            obj_.build(child_)
            self.supported_versions = obj_
            obj_.original_tagname_ = 'supported_versions'
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'mac_pool':
            obj_ = MacPool.factory(parent_object_=self)
            obj_.build(child_)
            self.mac_pool = obj_
            obj_.original_tagname_ = 'mac_pool'
        elif nodeName_ == 'quota_mode':
            quota_mode_ = child_.text
            quota_mode_ = self.gds_validate_string(quota_mode_, node, 'quota_mode')
            self.quota_mode = quota_mode_
        super(DataCenter, self).buildChildren(child_, node, nodeName_, True)
# end class DataCenter


class DataCenters(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, data_center=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DataCenters, self).__init__(actions, size, total, active,  **kwargs_)
        if data_center is None:
            self.data_center = []
        else:
            self.data_center = data_center
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataCenters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataCenters.subclass:
            return DataCenters.subclass(*args_, **kwargs_)
        else:
            return DataCenters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    def add_data_center(self, value):
        self.data_center.append(value)
    def insert_data_center_at(self, index, value):
        self.data_center.insert(index, value)
    def replace_data_center_at(self, index, value):
        self.data_center[index] = value
    data_centerProp = property(get_data_center, set_data_center)
    def hasContent_(self):
        if (
            self.data_center or
            super(DataCenters, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='data_centers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('data_centers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data_centers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='data_centers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='data_centers'):
        super(DataCenters, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data_centers')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='data_centers', fromsubclass_=False, pretty_print=True):
        super(DataCenters, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_center_ in self.data_center:
            data_center_.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DataCenters, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center.append(obj_)
            obj_.original_tagname_ = 'data_center'
        super(DataCenters, self).buildChildren(child_, node, nodeName_, True)
# end class DataCenters


class DataCenterStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data_center_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if data_center_state is None:
            self.data_center_state = []
        else:
            self.data_center_state = data_center_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataCenterStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataCenterStates.subclass:
            return DataCenterStates.subclass(*args_, **kwargs_)
        else:
            return DataCenterStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center_state(self):
        return self.data_center_state
    def set_data_center_state(self, data_center_state):
        self.data_center_state = data_center_state
    def add_data_center_state(self, value):
        self.data_center_state.append(value)
    def insert_data_center_state_at(self, index, value):
        self.data_center_state.insert(index, value)
    def replace_data_center_state_at(self, index, value):
        self.data_center_state[index] = value
    data_center_stateProp = property(get_data_center_state, set_data_center_state)
    def hasContent_(self):
        if (
            self.data_center_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='data_center_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('data_center_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='data_center_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='data_center_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='data_center_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='data_center_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for data_center_state_ in self.data_center_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata_center_state>%s</%sdata_center_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(data_center_state_), input_name='data_center_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center_state':
            data_center_state_ = child_.text
            data_center_state_ = self.gds_validate_string(data_center_state_, node, 'data_center_state')
            self.data_center_state.append(data_center_state_)
# end class DataCenterStates


class SkipIfConnectivityBroken(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, threshold=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
        self.threshold = threshold
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SkipIfConnectivityBroken)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SkipIfConnectivityBroken.subclass:
            return SkipIfConnectivityBroken.subclass(*args_, **kwargs_)
        else:
            return SkipIfConnectivityBroken(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_threshold(self):
        return self.threshold
    def set_threshold(self, threshold):
        self.threshold = threshold
    thresholdProp = property(get_threshold, set_threshold)
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.threshold is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='skip_if_connectivity_broken', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('skip_if_connectivity_broken')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='skip_if_connectivity_broken')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='skip_if_connectivity_broken', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='skip_if_connectivity_broken'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='skip_if_connectivity_broken', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.threshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthreshold>%s</%sthreshold>%s' % (namespaceprefix_ , self.gds_format_integer(self.threshold, input_name='threshold'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'threshold' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'threshold')
            self.threshold = ival_
# end class SkipIfConnectivityBroken


class SkipIfSDActive(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SkipIfSDActive)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SkipIfSDActive.subclass:
            return SkipIfSDActive.subclass(*args_, **kwargs_)
        else:
            return SkipIfSDActive(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def hasContent_(self):
        if (
            self.enabled is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='skip_if_sd_active', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('skip_if_sd_active')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='skip_if_sd_active')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='skip_if_sd_active', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='skip_if_sd_active'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='skip_if_sd_active', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
# end class SkipIfSDActive


class FencingPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, skip_if_sd_active=None, skip_if_connectivity_broken=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
        self.skip_if_sd_active = skip_if_sd_active
        self.skip_if_connectivity_broken = skip_if_connectivity_broken
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FencingPolicy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FencingPolicy.subclass:
            return FencingPolicy.subclass(*args_, **kwargs_)
        else:
            return FencingPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_skip_if_sd_active(self):
        return self.skip_if_sd_active
    def set_skip_if_sd_active(self, skip_if_sd_active):
        self.skip_if_sd_active = skip_if_sd_active
    skip_if_sd_activeProp = property(get_skip_if_sd_active, set_skip_if_sd_active)
    def get_skip_if_connectivity_broken(self):
        return self.skip_if_connectivity_broken
    def set_skip_if_connectivity_broken(self, skip_if_connectivity_broken):
        self.skip_if_connectivity_broken = skip_if_connectivity_broken
    skip_if_connectivity_brokenProp = property(get_skip_if_connectivity_broken, set_skip_if_connectivity_broken)
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.skip_if_sd_active is not None or
            self.skip_if_connectivity_broken is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='fencing_policy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fencing_policy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fencing_policy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='fencing_policy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fencing_policy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='fencing_policy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.skip_if_sd_active is not None:
            self.skip_if_sd_active.export(outfile, level, namespaceprefix_, name_='skip_if_sd_active', pretty_print=pretty_print)
        if self.skip_if_connectivity_broken is not None:
            self.skip_if_connectivity_broken.export(outfile, level, namespaceprefix_, name_='skip_if_connectivity_broken', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'skip_if_sd_active':
            obj_ = SkipIfSDActive.factory(parent_object_=self)
            obj_.build(child_)
            self.skip_if_sd_active = obj_
            obj_.original_tagname_ = 'skip_if_sd_active'
        elif nodeName_ == 'skip_if_connectivity_broken':
            obj_ = SkipIfConnectivityBroken.factory(parent_object_=self)
            obj_.build(child_)
            self.skip_if_connectivity_broken = obj_
            obj_.original_tagname_ = 'skip_if_connectivity_broken'
# end class FencingPolicy


class MemoryOverCommit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, percent=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.percent = _cast(int, percent)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryOverCommit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryOverCommit.subclass:
            return MemoryOverCommit.subclass(*args_, **kwargs_)
        else:
            return MemoryOverCommit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_percent(self):
        return self.percent
    def set_percent(self, percent):
        self.percent = percent
    percentProp = property(get_percent, set_percent)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='MemoryOverCommit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MemoryOverCommit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MemoryOverCommit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='MemoryOverCommit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MemoryOverCommit'):
        if self.percent is not None and 'percent' not in already_processed:
            already_processed.add('percent')
            outfile.write(' percent="%s"' % self.gds_format_integer(self.percent, input_name='percent'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MemoryOverCommit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percent', node)
        if value is not None and 'percent' not in already_processed:
            already_processed.add('percent')
            try:
                self.percent = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MemoryOverCommit


class MemoryPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, guaranteed=None, ballooning=None, overcommit=None, transparent_hugepages=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.guaranteed = guaranteed
        self.ballooning = ballooning
        self.overcommit = overcommit
        self.transparent_hugepages = transparent_hugepages
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MemoryPolicy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MemoryPolicy.subclass:
            return MemoryPolicy.subclass(*args_, **kwargs_)
        else:
            return MemoryPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_guaranteed(self):
        return self.guaranteed
    def set_guaranteed(self, guaranteed):
        self.guaranteed = guaranteed
    guaranteedProp = property(get_guaranteed, set_guaranteed)
    def get_ballooning(self):
        return self.ballooning
    def set_ballooning(self, ballooning):
        self.ballooning = ballooning
    ballooningProp = property(get_ballooning, set_ballooning)
    def get_overcommit(self):
        return self.overcommit
    def set_overcommit(self, overcommit):
        self.overcommit = overcommit
    overcommitProp = property(get_overcommit, set_overcommit)
    def get_transparent_hugepages(self):
        return self.transparent_hugepages
    def set_transparent_hugepages(self, transparent_hugepages):
        self.transparent_hugepages = transparent_hugepages
    transparent_hugepagesProp = property(get_transparent_hugepages, set_transparent_hugepages)
    def hasContent_(self):
        if (
            self.guaranteed is not None or
            self.ballooning is not None or
            self.overcommit is not None or
            self.transparent_hugepages is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='MemoryPolicy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MemoryPolicy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MemoryPolicy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='MemoryPolicy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MemoryPolicy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='MemoryPolicy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.guaranteed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sguaranteed>%s</%sguaranteed>%s' % (namespaceprefix_ , self.gds_format_integer(self.guaranteed, input_name='guaranteed'), namespaceprefix_ , eol_))
        if self.ballooning is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sballooning>%s</%sballooning>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ballooning, input_name='ballooning'), namespaceprefix_ , eol_))
        if self.overcommit is not None:
            self.overcommit.export(outfile, level, namespaceprefix_, name_='overcommit', pretty_print=pretty_print)
        if self.transparent_hugepages is not None:
            self.transparent_hugepages.export(outfile, level, namespaceprefix_, name_='transparent_hugepages', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'guaranteed' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'guaranteed')
            self.guaranteed = ival_
        elif nodeName_ == 'ballooning':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ballooning')
            self.ballooning = ival_
        elif nodeName_ == 'overcommit':
            obj_ = MemoryOverCommit.factory(parent_object_=self)
            obj_.build(child_)
            self.overcommit = obj_
            obj_.original_tagname_ = 'overcommit'
        elif nodeName_ == 'transparent_hugepages':
            obj_ = TransparentHugePages.factory(parent_object_=self)
            obj_.build(child_)
            self.transparent_hugepages = obj_
            obj_.original_tagname_ = 'transparent_hugepages'
# end class MemoryPolicy


class Console(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = _cast(bool, enabled)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Console)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Console.subclass:
            return Console.subclass(*args_, **kwargs_)
        else:
            return Console(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='console', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('console')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='console')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='console', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='console'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='console', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Console


class VirtIO_SCSI(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = _cast(bool, enabled)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VirtIO_SCSI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VirtIO_SCSI.subclass:
            return VirtIO_SCSI.subclass(*args_, **kwargs_)
        else:
            return VirtIO_SCSI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='virtio_scsi', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('virtio_scsi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='virtio_scsi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='virtio_scsi', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='virtio_scsi'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='virtio_scsi', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VirtIO_SCSI


class SchedulingPolicyThresholds(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, low=None, high=None, duration=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.low = _cast(int, low)
        self.high = _cast(int, high)
        self.duration = _cast(int, duration)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicyThresholds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicyThresholds.subclass:
            return SchedulingPolicyThresholds.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicyThresholds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_low(self):
        return self.low
    def set_low(self, low):
        self.low = low
    lowProp = property(get_low, set_low)
    def get_high(self):
        return self.high
    def set_high(self, high):
        self.high = high
    highProp = property(get_high, set_high)
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    durationProp = property(get_duration, set_duration)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='SchedulingPolicyThresholds', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SchedulingPolicyThresholds')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SchedulingPolicyThresholds')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='SchedulingPolicyThresholds', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SchedulingPolicyThresholds'):
        if self.low is not None and 'low' not in already_processed:
            already_processed.add('low')
            outfile.write(' low="%s"' % self.gds_format_integer(self.low, input_name='low'))
        if self.high is not None and 'high' not in already_processed:
            already_processed.add('high')
            outfile.write(' high="%s"' % self.gds_format_integer(self.high, input_name='high'))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration="%s"' % self.gds_format_integer(self.duration, input_name='duration'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='SchedulingPolicyThresholds', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('low', node)
        if value is not None and 'low' not in already_processed:
            already_processed.add('low')
            try:
                self.low = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('high', node)
        if value is not None and 'high' not in already_processed:
            already_processed.add('high')
            try:
                self.high = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            try:
                self.duration = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SchedulingPolicyThresholds


class SchedulingPolicyUnit(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, internal=None, enabled=None, properties=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SchedulingPolicyUnit, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.internal = internal
        self.enabled = enabled
        self.properties = properties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicyUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicyUnit.subclass:
            return SchedulingPolicyUnit.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicyUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_internal(self):
        return self.internal
    def set_internal(self, internal):
        self.internal = internal
    internalProp = property(get_internal, set_internal)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_properties(self):
        return self.properties
    def set_properties(self, properties):
        self.properties = properties
    propertiesProp = property(get_properties, set_properties)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.internal is not None or
            self.enabled is not None or
            self.properties is not None or
            super(SchedulingPolicyUnit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='scheduling_policy_unit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scheduling_policy_unit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy_unit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='scheduling_policy_unit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scheduling_policy_unit'):
        super(SchedulingPolicyUnit, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy_unit')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='scheduling_policy_unit', fromsubclass_=False, pretty_print=True):
        super(SchedulingPolicyUnit, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.internal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinternal>%s</%sinternal>%s' % (namespaceprefix_ , self.gds_format_boolean(self.internal, input_name='internal'), namespaceprefix_ , eol_))
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespaceprefix_, name_='properties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(SchedulingPolicyUnit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'internal':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'internal')
            self.internal = ival_
        elif nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'properties':
            obj_ = Properties.factory(parent_object_=self)
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        super(SchedulingPolicyUnit, self).buildChildren(child_, node, nodeName_, True)
# end class SchedulingPolicyUnit


class SchedulingPolicyUnits(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, scheduling_policy_unit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SchedulingPolicyUnits, self).__init__(actions, size, total, active,  **kwargs_)
        if scheduling_policy_unit is None:
            self.scheduling_policy_unit = []
        else:
            self.scheduling_policy_unit = scheduling_policy_unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicyUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicyUnits.subclass:
            return SchedulingPolicyUnits.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicyUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduling_policy_unit(self):
        return self.scheduling_policy_unit
    def set_scheduling_policy_unit(self, scheduling_policy_unit):
        self.scheduling_policy_unit = scheduling_policy_unit
    def add_scheduling_policy_unit(self, value):
        self.scheduling_policy_unit.append(value)
    def insert_scheduling_policy_unit_at(self, index, value):
        self.scheduling_policy_unit.insert(index, value)
    def replace_scheduling_policy_unit_at(self, index, value):
        self.scheduling_policy_unit[index] = value
    scheduling_policy_unitProp = property(get_scheduling_policy_unit, set_scheduling_policy_unit)
    def hasContent_(self):
        if (
            self.scheduling_policy_unit or
            super(SchedulingPolicyUnits, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='scheduling_policy_units', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scheduling_policy_units')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy_units')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='scheduling_policy_units', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scheduling_policy_units'):
        super(SchedulingPolicyUnits, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy_units')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='scheduling_policy_units', fromsubclass_=False, pretty_print=True):
        super(SchedulingPolicyUnits, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for scheduling_policy_unit_ in self.scheduling_policy_unit:
            scheduling_policy_unit_.export(outfile, level, namespaceprefix_, name_='scheduling_policy_unit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SchedulingPolicyUnits, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduling_policy_unit':
            obj_ = SchedulingPolicyUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy_unit.append(obj_)
            obj_.original_tagname_ = 'scheduling_policy_unit'
        super(SchedulingPolicyUnits, self).buildChildren(child_, node, nodeName_, True)
# end class SchedulingPolicyUnits


class Filter(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, scheduling_policy_unit=None, position=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Filter, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.scheduling_policy_unit = scheduling_policy_unit
        self.position = position
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Filter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Filter.subclass:
            return Filter.subclass(*args_, **kwargs_)
        else:
            return Filter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduling_policy_unit(self):
        return self.scheduling_policy_unit
    def set_scheduling_policy_unit(self, scheduling_policy_unit):
        self.scheduling_policy_unit = scheduling_policy_unit
    scheduling_policy_unitProp = property(get_scheduling_policy_unit, set_scheduling_policy_unit)
    def get_position(self):
        return self.position
    def set_position(self, position):
        self.position = position
    positionProp = property(get_position, set_position)
    def hasContent_(self):
        if (
            self.scheduling_policy_unit is not None or
            self.position is not None or
            super(Filter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='filter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('filter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='filter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='filter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='filter'):
        super(Filter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='filter')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='filter', fromsubclass_=False, pretty_print=True):
        super(Filter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scheduling_policy_unit is not None:
            self.scheduling_policy_unit.export(outfile, level, namespaceprefix_, name_='scheduling_policy_unit', pretty_print=pretty_print)
        if self.position is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sposition>%s</%sposition>%s' % (namespaceprefix_ , self.gds_format_integer(self.position, input_name='position'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Filter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduling_policy_unit':
            obj_ = SchedulingPolicyUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy_unit = obj_
            obj_.original_tagname_ = 'scheduling_policy_unit'
        elif nodeName_ == 'position' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'position')
            self.position = ival_
        super(Filter, self).buildChildren(child_, node, nodeName_, True)
# end class Filter


class Filters(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, filter=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Filters, self).__init__(actions, size, total, active,  **kwargs_)
        if filter is None:
            self.filter = []
        else:
            self.filter = filter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Filters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Filters.subclass:
            return Filters.subclass(*args_, **kwargs_)
        else:
            return Filters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filter(self):
        return self.filter
    def set_filter(self, filter):
        self.filter = filter
    def add_filter(self, value):
        self.filter.append(value)
    def insert_filter_at(self, index, value):
        self.filter.insert(index, value)
    def replace_filter_at(self, index, value):
        self.filter[index] = value
    filterProp = property(get_filter, set_filter)
    def hasContent_(self):
        if (
            self.filter or
            super(Filters, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='filters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('filters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='filters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='filters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='filters'):
        super(Filters, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='filters')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='filters', fromsubclass_=False, pretty_print=True):
        super(Filters, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for filter_ in self.filter:
            filter_.export(outfile, level, namespaceprefix_, name_='filter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Filters, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'filter':
            obj_ = Filter.factory(parent_object_=self)
            obj_.build(child_)
            self.filter.append(obj_)
            obj_.original_tagname_ = 'filter'
        super(Filters, self).buildChildren(child_, node, nodeName_, True)
# end class Filters


class Weight(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, scheduling_policy=None, scheduling_policy_unit=None, factor=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Weight, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.scheduling_policy = scheduling_policy
        self.scheduling_policy_unit = scheduling_policy_unit
        self.factor = factor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Weight)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Weight.subclass:
            return Weight.subclass(*args_, **kwargs_)
        else:
            return Weight(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduling_policy(self):
        return self.scheduling_policy
    def set_scheduling_policy(self, scheduling_policy):
        self.scheduling_policy = scheduling_policy
    scheduling_policyProp = property(get_scheduling_policy, set_scheduling_policy)
    def get_scheduling_policy_unit(self):
        return self.scheduling_policy_unit
    def set_scheduling_policy_unit(self, scheduling_policy_unit):
        self.scheduling_policy_unit = scheduling_policy_unit
    scheduling_policy_unitProp = property(get_scheduling_policy_unit, set_scheduling_policy_unit)
    def get_factor(self):
        return self.factor
    def set_factor(self, factor):
        self.factor = factor
    factorProp = property(get_factor, set_factor)
    def hasContent_(self):
        if (
            self.scheduling_policy is not None or
            self.scheduling_policy_unit is not None or
            self.factor is not None or
            super(Weight, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='weight', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weight')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weight')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='weight', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weight'):
        super(Weight, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weight')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='weight', fromsubclass_=False, pretty_print=True):
        super(Weight, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scheduling_policy is not None:
            self.scheduling_policy.export(outfile, level, namespaceprefix_, name_='scheduling_policy', pretty_print=pretty_print)
        if self.scheduling_policy_unit is not None:
            self.scheduling_policy_unit.export(outfile, level, namespaceprefix_, name_='scheduling_policy_unit', pretty_print=pretty_print)
        if self.factor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfactor>%s</%sfactor>%s' % (namespaceprefix_ , self.gds_format_integer(self.factor, input_name='factor'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Weight, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduling_policy':
            obj_ = SchedulingPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy = obj_
            obj_.original_tagname_ = 'scheduling_policy'
        elif nodeName_ == 'scheduling_policy_unit':
            obj_ = SchedulingPolicyUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy_unit = obj_
            obj_.original_tagname_ = 'scheduling_policy_unit'
        elif nodeName_ == 'factor' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'factor')
            self.factor = ival_
        super(Weight, self).buildChildren(child_, node, nodeName_, True)
# end class Weight


class Weights(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, weight=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Weights, self).__init__(actions, size, total, active,  **kwargs_)
        if weight is None:
            self.weight = []
        else:
            self.weight = weight
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Weights)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Weights.subclass:
            return Weights.subclass(*args_, **kwargs_)
        else:
            return Weights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weight(self):
        return self.weight
    def set_weight(self, weight):
        self.weight = weight
    def add_weight(self, value):
        self.weight.append(value)
    def insert_weight_at(self, index, value):
        self.weight.insert(index, value)
    def replace_weight_at(self, index, value):
        self.weight[index] = value
    weightProp = property(get_weight, set_weight)
    def hasContent_(self):
        if (
            self.weight or
            super(Weights, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='weights', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('weights')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='weights', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='weights'):
        super(Weights, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='weights')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='weights', fromsubclass_=False, pretty_print=True):
        super(Weights, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for weight_ in self.weight:
            weight_.export(outfile, level, namespaceprefix_, name_='weight', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Weights, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weight':
            obj_ = Weight.factory(parent_object_=self)
            obj_.build(child_)
            self.weight.append(obj_)
            obj_.original_tagname_ = 'weight'
        super(Weights, self).buildChildren(child_, node, nodeName_, True)
# end class Weights


class Balance(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, scheduling_policy=None, scheduling_policy_unit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Balance, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.scheduling_policy = scheduling_policy
        self.scheduling_policy_unit = scheduling_policy_unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Balance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Balance.subclass:
            return Balance.subclass(*args_, **kwargs_)
        else:
            return Balance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduling_policy(self):
        return self.scheduling_policy
    def set_scheduling_policy(self, scheduling_policy):
        self.scheduling_policy = scheduling_policy
    scheduling_policyProp = property(get_scheduling_policy, set_scheduling_policy)
    def get_scheduling_policy_unit(self):
        return self.scheduling_policy_unit
    def set_scheduling_policy_unit(self, scheduling_policy_unit):
        self.scheduling_policy_unit = scheduling_policy_unit
    scheduling_policy_unitProp = property(get_scheduling_policy_unit, set_scheduling_policy_unit)
    def hasContent_(self):
        if (
            self.scheduling_policy is not None or
            self.scheduling_policy_unit is not None or
            super(Balance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='balance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('balance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='balance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='balance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='balance'):
        super(Balance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='balance')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='balance', fromsubclass_=False, pretty_print=True):
        super(Balance, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.scheduling_policy is not None:
            self.scheduling_policy.export(outfile, level, namespaceprefix_, name_='scheduling_policy', pretty_print=pretty_print)
        if self.scheduling_policy_unit is not None:
            self.scheduling_policy_unit.export(outfile, level, namespaceprefix_, name_='scheduling_policy_unit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Balance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduling_policy':
            obj_ = SchedulingPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy = obj_
            obj_.original_tagname_ = 'scheduling_policy'
        elif nodeName_ == 'scheduling_policy_unit':
            obj_ = SchedulingPolicyUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy_unit = obj_
            obj_.original_tagname_ = 'scheduling_policy_unit'
        super(Balance, self).buildChildren(child_, node, nodeName_, True)
# end class Balance


class Balances(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, balance=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Balances, self).__init__(actions, size, total, active,  **kwargs_)
        self.balance = balance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Balances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Balances.subclass:
            return Balances.subclass(*args_, **kwargs_)
        else:
            return Balances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_balance(self):
        return self.balance
    def set_balance(self, balance):
        self.balance = balance
    balanceProp = property(get_balance, set_balance)
    def hasContent_(self):
        if (
            self.balance is not None or
            super(Balances, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='balances', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('balances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='balances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='balances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='balances'):
        super(Balances, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='balances')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='balances', fromsubclass_=False, pretty_print=True):
        super(Balances, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.balance is not None:
            self.balance.export(outfile, level, namespaceprefix_, name_='balance', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Balances, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'balance':
            obj_ = Balance.factory(parent_object_=self)
            obj_.build(child_)
            self.balance = obj_
            obj_.original_tagname_ = 'balance'
        super(Balances, self).buildChildren(child_, node, nodeName_, True)
# end class Balances


class SchedulingPolicy(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, policy=None, thresholds=None, locked=None, default_policy=None, properties=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SchedulingPolicy, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.policy = policy
        self.thresholds = thresholds
        self.locked = locked
        self.default_policy = default_policy
        self.properties = properties
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicy.subclass:
            return SchedulingPolicy.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_policy(self):
        return self.policy
    def set_policy(self, policy):
        self.policy = policy
    policyProp = property(get_policy, set_policy)
    def get_thresholds(self):
        return self.thresholds
    def set_thresholds(self, thresholds):
        self.thresholds = thresholds
    thresholdsProp = property(get_thresholds, set_thresholds)
    def get_locked(self):
        return self.locked
    def set_locked(self, locked):
        self.locked = locked
    lockedProp = property(get_locked, set_locked)
    def get_default_policy(self):
        return self.default_policy
    def set_default_policy(self, default_policy):
        self.default_policy = default_policy
    default_policyProp = property(get_default_policy, set_default_policy)
    def get_properties(self):
        return self.properties
    def set_properties(self, properties):
        self.properties = properties
    propertiesProp = property(get_properties, set_properties)
    def hasContent_(self):
        if (
            self.policy is not None or
            self.thresholds is not None or
            self.locked is not None or
            self.default_policy is not None or
            self.properties is not None or
            super(SchedulingPolicy, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='scheduling_policy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scheduling_policy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='scheduling_policy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scheduling_policy'):
        super(SchedulingPolicy, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policy')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='scheduling_policy', fromsubclass_=False, pretty_print=True):
        super(SchedulingPolicy, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolicy>%s</%spolicy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.policy), input_name='policy')), namespaceprefix_ , eol_))
        if self.thresholds is not None:
            self.thresholds.export(outfile, level, namespaceprefix_, name_='thresholds', pretty_print=pretty_print)
        if self.locked is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocked>%s</%slocked>%s' % (namespaceprefix_ , self.gds_format_boolean(self.locked, input_name='locked'), namespaceprefix_ , eol_))
        if self.default_policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdefault_policy>%s</%sdefault_policy>%s' % (namespaceprefix_ , self.gds_format_boolean(self.default_policy, input_name='default_policy'), namespaceprefix_ , eol_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespaceprefix_, name_='properties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SchedulingPolicy, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'policy':
            policy_ = child_.text
            policy_ = self.gds_validate_string(policy_, node, 'policy')
            self.policy = policy_
        elif nodeName_ == 'thresholds':
            obj_ = SchedulingPolicyThresholds.factory(parent_object_=self)
            obj_.build(child_)
            self.thresholds = obj_
            obj_.original_tagname_ = 'thresholds'
        elif nodeName_ == 'locked':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'locked')
            self.locked = ival_
        elif nodeName_ == 'default_policy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'default_policy')
            self.default_policy = ival_
        elif nodeName_ == 'properties':
            obj_ = Properties.factory(parent_object_=self)
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        super(SchedulingPolicy, self).buildChildren(child_, node, nodeName_, True)
# end class SchedulingPolicy


class Cluster(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, cpu=None, data_center=None, memory_policy=None, scheduling_policy=None, version=None, supported_versions=None, error_handling=None, virt_service=None, gluster_service=None, threads_as_cores=None, tunnel_migration=None, trusted_service=None, ha_reservation=None, optional_reason=None, maintenance_reason_required=None, ballooning_enabled=None, display=None, ksm=None, serial_number=None, required_rng_sources=None, fencing_policy=None, migration=None, management_network=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Cluster, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.cpu = cpu
        self.data_center = data_center
        self.memory_policy = memory_policy
        self.scheduling_policy = scheduling_policy
        self.version = version
        self.supported_versions = supported_versions
        self.error_handling = error_handling
        self.virt_service = virt_service
        self.gluster_service = gluster_service
        self.threads_as_cores = threads_as_cores
        self.tunnel_migration = tunnel_migration
        self.trusted_service = trusted_service
        self.ha_reservation = ha_reservation
        self.optional_reason = optional_reason
        self.maintenance_reason_required = maintenance_reason_required
        self.ballooning_enabled = ballooning_enabled
        self.display = display
        self.ksm = ksm
        self.serial_number = serial_number
        self.required_rng_sources = required_rng_sources
        self.fencing_policy = fencing_policy
        self.migration = migration
        self.management_network = management_network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cluster)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cluster.subclass:
            return Cluster.subclass(*args_, **kwargs_)
        else:
            return Cluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu(self):
        return self.cpu
    def set_cpu(self, cpu):
        self.cpu = cpu
    cpuProp = property(get_cpu, set_cpu)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_memory_policy(self):
        return self.memory_policy
    def set_memory_policy(self, memory_policy):
        self.memory_policy = memory_policy
    memory_policyProp = property(get_memory_policy, set_memory_policy)
    def get_scheduling_policy(self):
        return self.scheduling_policy
    def set_scheduling_policy(self, scheduling_policy):
        self.scheduling_policy = scheduling_policy
    scheduling_policyProp = property(get_scheduling_policy, set_scheduling_policy)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_supported_versions(self):
        return self.supported_versions
    def set_supported_versions(self, supported_versions):
        self.supported_versions = supported_versions
    supported_versionsProp = property(get_supported_versions, set_supported_versions)
    def get_error_handling(self):
        return self.error_handling
    def set_error_handling(self, error_handling):
        self.error_handling = error_handling
    error_handlingProp = property(get_error_handling, set_error_handling)
    def get_virt_service(self):
        return self.virt_service
    def set_virt_service(self, virt_service):
        self.virt_service = virt_service
    virt_serviceProp = property(get_virt_service, set_virt_service)
    def get_gluster_service(self):
        return self.gluster_service
    def set_gluster_service(self, gluster_service):
        self.gluster_service = gluster_service
    gluster_serviceProp = property(get_gluster_service, set_gluster_service)
    def get_threads_as_cores(self):
        return self.threads_as_cores
    def set_threads_as_cores(self, threads_as_cores):
        self.threads_as_cores = threads_as_cores
    threads_as_coresProp = property(get_threads_as_cores, set_threads_as_cores)
    def get_tunnel_migration(self):
        return self.tunnel_migration
    def set_tunnel_migration(self, tunnel_migration):
        self.tunnel_migration = tunnel_migration
    tunnel_migrationProp = property(get_tunnel_migration, set_tunnel_migration)
    def get_trusted_service(self):
        return self.trusted_service
    def set_trusted_service(self, trusted_service):
        self.trusted_service = trusted_service
    trusted_serviceProp = property(get_trusted_service, set_trusted_service)
    def get_ha_reservation(self):
        return self.ha_reservation
    def set_ha_reservation(self, ha_reservation):
        self.ha_reservation = ha_reservation
    ha_reservationProp = property(get_ha_reservation, set_ha_reservation)
    def get_optional_reason(self):
        return self.optional_reason
    def set_optional_reason(self, optional_reason):
        self.optional_reason = optional_reason
    optional_reasonProp = property(get_optional_reason, set_optional_reason)
    def get_maintenance_reason_required(self):
        return self.maintenance_reason_required
    def set_maintenance_reason_required(self, maintenance_reason_required):
        self.maintenance_reason_required = maintenance_reason_required
    maintenance_reason_requiredProp = property(get_maintenance_reason_required, set_maintenance_reason_required)
    def get_ballooning_enabled(self):
        return self.ballooning_enabled
    def set_ballooning_enabled(self, ballooning_enabled):
        self.ballooning_enabled = ballooning_enabled
    ballooning_enabledProp = property(get_ballooning_enabled, set_ballooning_enabled)
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    displayProp = property(get_display, set_display)
    def get_ksm(self):
        return self.ksm
    def set_ksm(self, ksm):
        self.ksm = ksm
    ksmProp = property(get_ksm, set_ksm)
    def get_serial_number(self):
        return self.serial_number
    def set_serial_number(self, serial_number):
        self.serial_number = serial_number
    serial_numberProp = property(get_serial_number, set_serial_number)
    def get_required_rng_sources(self):
        return self.required_rng_sources
    def set_required_rng_sources(self, required_rng_sources):
        self.required_rng_sources = required_rng_sources
    required_rng_sourcesProp = property(get_required_rng_sources, set_required_rng_sources)
    def get_fencing_policy(self):
        return self.fencing_policy
    def set_fencing_policy(self, fencing_policy):
        self.fencing_policy = fencing_policy
    fencing_policyProp = property(get_fencing_policy, set_fencing_policy)
    def get_migration(self):
        return self.migration
    def set_migration(self, migration):
        self.migration = migration
    migrationProp = property(get_migration, set_migration)
    def get_management_network(self):
        return self.management_network
    def set_management_network(self, management_network):
        self.management_network = management_network
    management_networkProp = property(get_management_network, set_management_network)
    def hasContent_(self):
        if (
            self.cpu is not None or
            self.data_center is not None or
            self.memory_policy is not None or
            self.scheduling_policy is not None or
            self.version is not None or
            self.supported_versions is not None or
            self.error_handling is not None or
            self.virt_service is not None or
            self.gluster_service is not None or
            self.threads_as_cores is not None or
            self.tunnel_migration is not None or
            self.trusted_service is not None or
            self.ha_reservation is not None or
            self.optional_reason is not None or
            self.maintenance_reason_required is not None or
            self.ballooning_enabled is not None or
            self.display is not None or
            self.ksm is not None or
            self.serial_number is not None or
            self.required_rng_sources is not None or
            self.fencing_policy is not None or
            self.migration is not None or
            self.management_network is not None or
            super(Cluster, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cluster', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cluster')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cluster')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cluster'):
        super(Cluster, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cluster')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cluster', fromsubclass_=False, pretty_print=True):
        super(Cluster, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cpu is not None:
            self.cpu.export(outfile, level, namespaceprefix_, name_='cpu', pretty_print=pretty_print)
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.memory_policy is not None:
            self.memory_policy.export(outfile, level, namespaceprefix_, name_='memory_policy', pretty_print=pretty_print)
        if self.scheduling_policy is not None:
            self.scheduling_policy.export(outfile, level, namespaceprefix_, name_='scheduling_policy', pretty_print=pretty_print)
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.supported_versions is not None:
            self.supported_versions.export(outfile, level, namespaceprefix_, name_='supported_versions', pretty_print=pretty_print)
        if self.error_handling is not None:
            self.error_handling.export(outfile, level, namespaceprefix_, name_='error_handling', pretty_print=pretty_print)
        if self.virt_service is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirt_service>%s</%svirt_service>%s' % (namespaceprefix_ , self.gds_format_boolean(self.virt_service, input_name='virt_service'), namespaceprefix_ , eol_))
        if self.gluster_service is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgluster_service>%s</%sgluster_service>%s' % (namespaceprefix_ , self.gds_format_boolean(self.gluster_service, input_name='gluster_service'), namespaceprefix_ , eol_))
        if self.threads_as_cores is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthreads_as_cores>%s</%sthreads_as_cores>%s' % (namespaceprefix_ , self.gds_format_boolean(self.threads_as_cores, input_name='threads_as_cores'), namespaceprefix_ , eol_))
        if self.tunnel_migration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stunnel_migration>%s</%stunnel_migration>%s' % (namespaceprefix_ , self.gds_format_boolean(self.tunnel_migration, input_name='tunnel_migration'), namespaceprefix_ , eol_))
        if self.trusted_service is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%strusted_service>%s</%strusted_service>%s' % (namespaceprefix_ , self.gds_format_boolean(self.trusted_service, input_name='trusted_service'), namespaceprefix_ , eol_))
        if self.ha_reservation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sha_reservation>%s</%sha_reservation>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ha_reservation, input_name='ha_reservation'), namespaceprefix_ , eol_))
        if self.optional_reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptional_reason>%s</%soptional_reason>%s' % (namespaceprefix_ , self.gds_format_boolean(self.optional_reason, input_name='optional_reason'), namespaceprefix_ , eol_))
        if self.maintenance_reason_required is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaintenance_reason_required>%s</%smaintenance_reason_required>%s' % (namespaceprefix_ , self.gds_format_boolean(self.maintenance_reason_required, input_name='maintenance_reason_required'), namespaceprefix_ , eol_))
        if self.ballooning_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sballooning_enabled>%s</%sballooning_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ballooning_enabled, input_name='ballooning_enabled'), namespaceprefix_ , eol_))
        if self.display is not None:
            self.display.export(outfile, level, namespaceprefix_, name_='display', pretty_print=pretty_print)
        if self.ksm is not None:
            self.ksm.export(outfile, level, namespaceprefix_, name_='ksm', pretty_print=pretty_print)
        if self.serial_number is not None:
            self.serial_number.export(outfile, level, namespaceprefix_, name_='serial_number', pretty_print=pretty_print)
        if self.required_rng_sources is not None:
            self.required_rng_sources.export(outfile, level, namespaceprefix_, name_='required_rng_sources', pretty_print=pretty_print)
        if self.fencing_policy is not None:
            self.fencing_policy.export(outfile, level, namespaceprefix_, name_='fencing_policy', pretty_print=pretty_print)
        if self.migration is not None:
            self.migration.export(outfile, level, namespaceprefix_, name_='migration', pretty_print=pretty_print)
        if self.management_network is not None:
            self.management_network.export(outfile, level, namespaceprefix_, name_='management_network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Cluster, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpu':
            obj_ = CPU.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu = obj_
            obj_.original_tagname_ = 'cpu'
        elif nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'memory_policy':
            obj_ = MemoryPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.memory_policy = obj_
            obj_.original_tagname_ = 'memory_policy'
        elif nodeName_ == 'scheduling_policy':
            obj_ = SchedulingPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy = obj_
            obj_.original_tagname_ = 'scheduling_policy'
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'supported_versions':
            obj_ = SupportedVersions.factory(parent_object_=self)
            obj_.build(child_)
            self.supported_versions = obj_
            obj_.original_tagname_ = 'supported_versions'
        elif nodeName_ == 'error_handling':
            obj_ = ErrorHandlingOptions.factory(parent_object_=self)
            obj_.build(child_)
            self.error_handling = obj_
            obj_.original_tagname_ = 'error_handling'
        elif nodeName_ == 'virt_service':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'virt_service')
            self.virt_service = ival_
        elif nodeName_ == 'gluster_service':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'gluster_service')
            self.gluster_service = ival_
        elif nodeName_ == 'threads_as_cores':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'threads_as_cores')
            self.threads_as_cores = ival_
        elif nodeName_ == 'tunnel_migration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tunnel_migration')
            self.tunnel_migration = ival_
        elif nodeName_ == 'trusted_service':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'trusted_service')
            self.trusted_service = ival_
        elif nodeName_ == 'ha_reservation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ha_reservation')
            self.ha_reservation = ival_
        elif nodeName_ == 'optional_reason':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'optional_reason')
            self.optional_reason = ival_
        elif nodeName_ == 'maintenance_reason_required':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'maintenance_reason_required')
            self.maintenance_reason_required = ival_
        elif nodeName_ == 'ballooning_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ballooning_enabled')
            self.ballooning_enabled = ival_
        elif nodeName_ == 'display':
            obj_ = Display.factory(parent_object_=self)
            obj_.build(child_)
            self.display = obj_
            obj_.original_tagname_ = 'display'
        elif nodeName_ == 'ksm':
            obj_ = KSM.factory(parent_object_=self)
            obj_.build(child_)
            self.ksm = obj_
            obj_.original_tagname_ = 'ksm'
        elif nodeName_ == 'serial_number':
            obj_ = SerialNumber.factory(parent_object_=self)
            obj_.build(child_)
            self.serial_number = obj_
            obj_.original_tagname_ = 'serial_number'
        elif nodeName_ == 'required_rng_sources':
            obj_ = RngSources.factory(parent_object_=self)
            obj_.build(child_)
            self.required_rng_sources = obj_
            obj_.original_tagname_ = 'required_rng_sources'
        elif nodeName_ == 'fencing_policy':
            obj_ = FencingPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.fencing_policy = obj_
            obj_.original_tagname_ = 'fencing_policy'
        elif nodeName_ == 'migration':
            obj_ = MigrationOptions.factory(parent_object_=self)
            obj_.build(child_)
            self.migration = obj_
            obj_.original_tagname_ = 'migration'
        elif nodeName_ == 'management_network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.management_network = obj_
            obj_.original_tagname_ = 'management_network'
        super(Cluster, self).buildChildren(child_, node, nodeName_, True)
# end class Cluster


class Clusters(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, cluster=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Clusters, self).__init__(actions, size, total, active,  **kwargs_)
        if cluster is None:
            self.cluster = []
        else:
            self.cluster = cluster
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Clusters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Clusters.subclass:
            return Clusters.subclass(*args_, **kwargs_)
        else:
            return Clusters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    def add_cluster(self, value):
        self.cluster.append(value)
    def insert_cluster_at(self, index, value):
        self.cluster.insert(index, value)
    def replace_cluster_at(self, index, value):
        self.cluster[index] = value
    clusterProp = property(get_cluster, set_cluster)
    def hasContent_(self):
        if (
            self.cluster or
            super(Clusters, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='clusters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clusters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clusters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='clusters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='clusters'):
        super(Clusters, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clusters')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='clusters', fromsubclass_=False, pretty_print=True):
        super(Clusters, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cluster_ in self.cluster:
            cluster_.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Clusters, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster.append(obj_)
            obj_.original_tagname_ = 'cluster'
        super(Clusters, self).buildChildren(child_, node, nodeName_, True)
# end class Clusters


class Agent(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, address=None, username=None, password=None, options=None, encrypt_options=None, concurrent=None, order=None, port=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Agent, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.address = address
        self.username = username
        self.password = password
        self.options = options
        self.encrypt_options = encrypt_options
        self.concurrent = concurrent
        self.order = order
        self.port = port
        self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Agent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Agent.subclass:
            return Agent.subclass(*args_, **kwargs_)
        else:
            return Agent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_options(self):
        return self.options
    def set_options(self, options):
        self.options = options
    optionsProp = property(get_options, set_options)
    def get_encrypt_options(self):
        return self.encrypt_options
    def set_encrypt_options(self, encrypt_options):
        self.encrypt_options = encrypt_options
    encrypt_optionsProp = property(get_encrypt_options, set_encrypt_options)
    def get_concurrent(self):
        return self.concurrent
    def set_concurrent(self, concurrent):
        self.concurrent = concurrent
    concurrentProp = property(get_concurrent, set_concurrent)
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    orderProp = property(get_order, set_order)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.address is not None or
            self.username is not None or
            self.password is not None or
            self.options is not None or
            self.encrypt_options is not None or
            self.concurrent is not None or
            self.order is not None or
            self.port is not None or
            self.host is not None or
            super(Agent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='agent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('agent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='agent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='agent'):
        super(Agent, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agent')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='agent', fromsubclass_=False, pretty_print=True):
        super(Agent, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.options is not None:
            self.options.export(outfile, level, namespaceprefix_, name_='options', pretty_print=pretty_print)
        if self.encrypt_options is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencrypt_options>%s</%sencrypt_options>%s' % (namespaceprefix_ , self.gds_format_boolean(self.encrypt_options, input_name='encrypt_options'), namespaceprefix_ , eol_))
        if self.concurrent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconcurrent>%s</%sconcurrent>%s' % (namespaceprefix_ , self.gds_format_boolean(self.concurrent, input_name='concurrent'), namespaceprefix_ , eol_))
        if self.order is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorder>%s</%sorder>%s' % (namespaceprefix_ , self.gds_format_integer(self.order, input_name='order'), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(Agent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'options':
            obj_ = Options.factory(parent_object_=self)
            obj_.build(child_)
            self.options = obj_
            obj_.original_tagname_ = 'options'
        elif nodeName_ == 'encrypt_options':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'encrypt_options')
            self.encrypt_options = ival_
        elif nodeName_ == 'concurrent':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'concurrent')
            self.concurrent = ival_
        elif nodeName_ == 'order' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'order')
            self.order = ival_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        super(Agent, self).buildChildren(child_, node, nodeName_, True)
# end class Agent


class Agents(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, agent=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Agents, self).__init__(actions, size, total, active,  **kwargs_)
        if agent is None:
            self.agent = []
        else:
            self.agent = agent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Agents)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Agents.subclass:
            return Agents.subclass(*args_, **kwargs_)
        else:
            return Agents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_agent(self):
        return self.agent
    def set_agent(self, agent):
        self.agent = agent
    def add_agent(self, value):
        self.agent.append(value)
    def insert_agent_at(self, index, value):
        self.agent.insert(index, value)
    def replace_agent_at(self, index, value):
        self.agent[index] = value
    agentProp = property(get_agent, set_agent)
    def hasContent_(self):
        if (
            self.agent or
            super(Agents, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='agents', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('agents')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agents')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='agents', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='agents'):
        super(Agents, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agents')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='agents', fromsubclass_=False, pretty_print=True):
        super(Agents, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for agent_ in self.agent:
            agent_.export(outfile, level, namespaceprefix_, name_='agent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Agents, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'agent':
            obj_ = Agent.factory(parent_object_=self)
            obj_.build(child_)
            self.agent.append(obj_)
            obj_.original_tagname_ = 'agent'
        super(Agents, self).buildChildren(child_, node, nodeName_, True)
# end class Agents


class PowerManagement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, enabled=None, address=None, username=None, password=None, options=None, status=None, pm_proxies=None, agents=None, automatic_pm_enabled=None, kdump_detection=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = _cast(None, type_)
        self.enabled = enabled
        self.address = address
        self.username = username
        self.password = password
        self.options = options
        self.status = status
        self.pm_proxies = pm_proxies
        self.agents = agents
        self.automatic_pm_enabled = automatic_pm_enabled
        self.kdump_detection = kdump_detection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerManagement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerManagement.subclass:
            return PowerManagement.subclass(*args_, **kwargs_)
        else:
            return PowerManagement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_options(self):
        return self.options
    def set_options(self, options):
        self.options = options
    optionsProp = property(get_options, set_options)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_pm_proxies(self):
        return self.pm_proxies
    def set_pm_proxies(self, pm_proxies):
        self.pm_proxies = pm_proxies
    pm_proxiesProp = property(get_pm_proxies, set_pm_proxies)
    def get_agents(self):
        return self.agents
    def set_agents(self, agents):
        self.agents = agents
    agentsProp = property(get_agents, set_agents)
    def get_automatic_pm_enabled(self):
        return self.automatic_pm_enabled
    def set_automatic_pm_enabled(self, automatic_pm_enabled):
        self.automatic_pm_enabled = automatic_pm_enabled
    automatic_pm_enabledProp = property(get_automatic_pm_enabled, set_automatic_pm_enabled)
    def get_kdump_detection(self):
        return self.kdump_detection
    def set_kdump_detection(self, kdump_detection):
        self.kdump_detection = kdump_detection
    kdump_detectionProp = property(get_kdump_detection, set_kdump_detection)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.address is not None or
            self.username is not None or
            self.password is not None or
            self.options is not None or
            self.status is not None or
            self.pm_proxies is not None or
            self.agents is not None or
            self.automatic_pm_enabled is not None or
            self.kdump_detection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='power_management', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('power_management')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='power_management')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='power_management', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='power_management'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='power_management', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.options is not None:
            self.options.export(outfile, level, namespaceprefix_, name_='options', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.pm_proxies is not None:
            self.pm_proxies.export(outfile, level, namespaceprefix_, name_='pm_proxies', pretty_print=pretty_print)
        if self.agents is not None:
            self.agents.export(outfile, level, namespaceprefix_, name_='agents', pretty_print=pretty_print)
        if self.automatic_pm_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautomatic_pm_enabled>%s</%sautomatic_pm_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.automatic_pm_enabled, input_name='automatic_pm_enabled'), namespaceprefix_ , eol_))
        if self.kdump_detection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skdump_detection>%s</%skdump_detection>%s' % (namespaceprefix_ , self.gds_format_boolean(self.kdump_detection, input_name='kdump_detection'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'options':
            obj_ = Options.factory(parent_object_=self)
            obj_.build(child_)
            self.options = obj_
            obj_.original_tagname_ = 'options'
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'pm_proxies':
            obj_ = PmProxies.factory(parent_object_=self)
            obj_.build(child_)
            self.pm_proxies = obj_
            obj_.original_tagname_ = 'pm_proxies'
        elif nodeName_ == 'agents':
            obj_ = Agents.factory(parent_object_=self)
            obj_.build(child_)
            self.agents = obj_
            obj_.original_tagname_ = 'agents'
        elif nodeName_ == 'automatic_pm_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'automatic_pm_enabled')
            self.automatic_pm_enabled = ival_
        elif nodeName_ == 'kdump_detection':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'kdump_detection')
            self.kdump_detection = ival_
# end class PowerManagement


class PowerManagementStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, power_management_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if power_management_state is None:
            self.power_management_state = []
        else:
            self.power_management_state = power_management_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerManagementStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerManagementStates.subclass:
            return PowerManagementStates.subclass(*args_, **kwargs_)
        else:
            return PowerManagementStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_power_management_state(self):
        return self.power_management_state
    def set_power_management_state(self, power_management_state):
        self.power_management_state = power_management_state
    def add_power_management_state(self, value):
        self.power_management_state.append(value)
    def insert_power_management_state_at(self, index, value):
        self.power_management_state.insert(index, value)
    def replace_power_management_state_at(self, index, value):
        self.power_management_state[index] = value
    power_management_stateProp = property(get_power_management_state, set_power_management_state)
    def hasContent_(self):
        if (
            self.power_management_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='power_management_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('power_management_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='power_management_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='power_management_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='power_management_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='power_management_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for power_management_state_ in self.power_management_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spower_management_state>%s</%spower_management_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(power_management_state_), input_name='power_management_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'power_management_state':
            power_management_state_ = child_.text
            power_management_state_ = self.gds_validate_string(power_management_state_, node, 'power_management_state')
            self.power_management_state.append(power_management_state_)
# end class PowerManagementStates


class HardwareInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, manufacturer=None, version=None, serial_number=None, product_name=None, uuid=None, family=None, supported_rng_sources=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.manufacturer = manufacturer
        self.version = version
        self.serial_number = serial_number
        self.product_name = product_name
        self.uuid = uuid
        self.family = family
        self.supported_rng_sources = supported_rng_sources
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HardwareInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HardwareInformation.subclass:
            return HardwareInformation.subclass(*args_, **kwargs_)
        else:
            return HardwareInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_manufacturer(self):
        return self.manufacturer
    def set_manufacturer(self, manufacturer):
        self.manufacturer = manufacturer
    manufacturerProp = property(get_manufacturer, set_manufacturer)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_serial_number(self):
        return self.serial_number
    def set_serial_number(self, serial_number):
        self.serial_number = serial_number
    serial_numberProp = property(get_serial_number, set_serial_number)
    def get_product_name(self):
        return self.product_name
    def set_product_name(self, product_name):
        self.product_name = product_name
    product_nameProp = property(get_product_name, set_product_name)
    def get_uuid(self):
        return self.uuid
    def set_uuid(self, uuid):
        self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def get_family(self):
        return self.family
    def set_family(self, family):
        self.family = family
    familyProp = property(get_family, set_family)
    def get_supported_rng_sources(self):
        return self.supported_rng_sources
    def set_supported_rng_sources(self, supported_rng_sources):
        self.supported_rng_sources = supported_rng_sources
    supported_rng_sourcesProp = property(get_supported_rng_sources, set_supported_rng_sources)
    def hasContent_(self):
        if (
            self.manufacturer is not None or
            self.version is not None or
            self.serial_number is not None or
            self.product_name is not None or
            self.uuid is not None or
            self.family is not None or
            self.supported_rng_sources is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='hardware_information', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hardware_information')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hardware_information')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='hardware_information', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hardware_information'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='hardware_information', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.manufacturer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smanufacturer>%s</%smanufacturer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.manufacturer), input_name='manufacturer')), namespaceprefix_ , eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.serial_number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserial_number>%s</%sserial_number>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serial_number), input_name='serial_number')), namespaceprefix_ , eol_))
        if self.product_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_name>%s</%sproduct_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_name), input_name='product_name')), namespaceprefix_ , eol_))
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.uuid), input_name='uuid')), namespaceprefix_ , eol_))
        if self.family is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfamily>%s</%sfamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.family), input_name='family')), namespaceprefix_ , eol_))
        if self.supported_rng_sources is not None:
            self.supported_rng_sources.export(outfile, level, namespaceprefix_, name_='supported_rng_sources', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'manufacturer':
            manufacturer_ = child_.text
            manufacturer_ = self.gds_validate_string(manufacturer_, node, 'manufacturer')
            self.manufacturer = manufacturer_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'serial_number':
            serial_number_ = child_.text
            serial_number_ = self.gds_validate_string(serial_number_, node, 'serial_number')
            self.serial_number = serial_number_
        elif nodeName_ == 'product_name':
            product_name_ = child_.text
            product_name_ = self.gds_validate_string(product_name_, node, 'product_name')
            self.product_name = product_name_
        elif nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'family':
            family_ = child_.text
            family_ = self.gds_validate_string(family_, node, 'family')
            self.family = family_
        elif nodeName_ == 'supported_rng_sources':
            obj_ = RngSources.factory(parent_object_=self)
            obj_.build(child_)
            self.supported_rng_sources = obj_
            obj_.original_tagname_ = 'supported_rng_sources'
# end class HardwareInformation


class PowerManagers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, power_management=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if power_management is None:
            self.power_management = []
        else:
            self.power_management = power_management
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerManagers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerManagers.subclass:
            return PowerManagers.subclass(*args_, **kwargs_)
        else:
            return PowerManagers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_power_management(self):
        return self.power_management
    def set_power_management(self, power_management):
        self.power_management = power_management
    def add_power_management(self, value):
        self.power_management.append(value)
    def insert_power_management_at(self, index, value):
        self.power_management.insert(index, value)
    def replace_power_management_at(self, index, value):
        self.power_management[index] = value
    power_managementProp = property(get_power_management, set_power_management)
    def hasContent_(self):
        if (
            self.power_management
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='power_managers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('power_managers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='power_managers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='power_managers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='power_managers'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='power_managers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for power_management_ in self.power_management:
            power_management_.export(outfile, level, namespaceprefix_, name_='power_management', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'power_management':
            obj_ = PowerManagement.factory(parent_object_=self)
            obj_.build(child_)
            self.power_management.append(obj_)
            obj_.original_tagname_ = 'power_management'
# end class PowerManagers


class KSM(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, merge_across_nodes=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
        self.merge_across_nodes = merge_across_nodes
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KSM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KSM.subclass:
            return KSM.subclass(*args_, **kwargs_)
        else:
            return KSM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_merge_across_nodes(self):
        return self.merge_across_nodes
    def set_merge_across_nodes(self, merge_across_nodes):
        self.merge_across_nodes = merge_across_nodes
    merge_across_nodesProp = property(get_merge_across_nodes, set_merge_across_nodes)
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.merge_across_nodes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ksm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ksm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ksm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ksm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ksm'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ksm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.merge_across_nodes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smerge_across_nodes>%s</%smerge_across_nodes>%s' % (namespaceprefix_ , self.gds_format_boolean(self.merge_across_nodes, input_name='merge_across_nodes'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'merge_across_nodes':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'merge_across_nodes')
            self.merge_across_nodes = ival_
# end class KSM


class TransparentHugePages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransparentHugePages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransparentHugePages.subclass:
            return TransparentHugePages.subclass(*args_, **kwargs_)
        else:
            return TransparentHugePages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def hasContent_(self):
        if (
            self.enabled is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='transparent_hugepages', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transparent_hugepages')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transparent_hugepages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='transparent_hugepages', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transparent_hugepages'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='transparent_hugepages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
# end class TransparentHugePages


class Certificate(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, organization=None, subject=None, content=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Certificate, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.organization = organization
        self.subject = subject
        self.content = content
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Certificate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Certificate.subclass:
            return Certificate.subclass(*args_, **kwargs_)
        else:
            return Certificate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_organization(self):
        return self.organization
    def set_organization(self, organization):
        self.organization = organization
    organizationProp = property(get_organization, set_organization)
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    subjectProp = property(get_subject, set_subject)
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    contentProp = property(get_content, set_content)
    def hasContent_(self):
        if (
            self.organization is not None or
            self.subject is not None or
            self.content is not None or
            super(Certificate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='certificate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('certificate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='certificate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='certificate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='certificate'):
        super(Certificate, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='certificate')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='certificate', fromsubclass_=False, pretty_print=True):
        super(Certificate, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.organization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganization>%s</%sorganization>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.organization), input_name='organization')), namespaceprefix_ , eol_))
        if self.subject is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubject>%s</%ssubject>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subject), input_name='subject')), namespaceprefix_ , eol_))
        if self.content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent>%s</%scontent>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.content), input_name='content')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Certificate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'organization':
            organization_ = child_.text
            organization_ = self.gds_validate_string(organization_, node, 'organization')
            self.organization = organization_
        elif nodeName_ == 'subject':
            subject_ = child_.text
            subject_ = self.gds_validate_string(subject_, node, 'subject')
            self.subject = subject_
        elif nodeName_ == 'content':
            content_ = child_.text
            content_ = self.gds_validate_string(content_, node, 'content')
            self.content = content_
        super(Certificate, self).buildChildren(child_, node, nodeName_, True)
# end class Certificate


class Certificates(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, certificate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Certificates, self).__init__(actions, size, total, active,  **kwargs_)
        if certificate is None:
            self.certificate = []
        else:
            self.certificate = certificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Certificates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Certificates.subclass:
            return Certificates.subclass(*args_, **kwargs_)
        else:
            return Certificates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_certificate(self):
        return self.certificate
    def set_certificate(self, certificate):
        self.certificate = certificate
    def add_certificate(self, value):
        self.certificate.append(value)
    def insert_certificate_at(self, index, value):
        self.certificate.insert(index, value)
    def replace_certificate_at(self, index, value):
        self.certificate[index] = value
    certificateProp = property(get_certificate, set_certificate)
    def hasContent_(self):
        if (
            self.certificate or
            super(Certificates, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='certificates', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('certificates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='certificates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='certificates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='certificates'):
        super(Certificates, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='certificates')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='certificates', fromsubclass_=False, pretty_print=True):
        super(Certificates, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for certificate_ in self.certificate:
            certificate_.export(outfile, level, namespaceprefix_, name_='certificate', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Certificates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'certificate':
            obj_ = Certificate.factory(parent_object_=self)
            obj_.build(child_)
            self.certificate.append(obj_)
            obj_.original_tagname_ = 'certificate'
        super(Certificates, self).buildChildren(child_, node, nodeName_, True)
# end class Certificates


class SELinux(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.mode = mode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SELinux)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SELinux.subclass:
            return SELinux.subclass(*args_, **kwargs_)
        else:
            return SELinux(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    modeProp = property(get_mode, set_mode)
    def hasContent_(self):
        if (
            self.mode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='selinux', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('selinux')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='selinux')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='selinux', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='selinux'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='selinux', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smode>%s</%smode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mode), input_name='mode')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mode':
            mode_ = child_.text
            mode_ = self.gds_validate_string(mode_, node, 'mode')
            self.mode = mode_
# end class SELinux


class VmSummary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, active=None, migrating=None, total=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.active = active
        self.migrating = migrating
        self.total = total
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmSummary)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmSummary.subclass:
            return VmSummary.subclass(*args_, **kwargs_)
        else:
            return VmSummary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    activeProp = property(get_active, set_active)
    def get_migrating(self):
        return self.migrating
    def set_migrating(self, migrating):
        self.migrating = migrating
    migratingProp = property(get_migrating, set_migrating)
    def get_total(self):
        return self.total
    def set_total(self, total):
        self.total = total
    totalProp = property(get_total, set_total)
    def hasContent_(self):
        if (
            self.active is not None or
            self.migrating is not None or
            self.total is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VmSummary', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VmSummary')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VmSummary')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='VmSummary', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VmSummary'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VmSummary', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.active is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactive>%s</%sactive>%s' % (namespaceprefix_ , self.gds_format_integer(self.active, input_name='active'), namespaceprefix_ , eol_))
        if self.migrating is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smigrating>%s</%smigrating>%s' % (namespaceprefix_ , self.gds_format_integer(self.migrating, input_name='migrating'), namespaceprefix_ , eol_))
        if self.total is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotal>%s</%stotal>%s' % (namespaceprefix_ , self.gds_format_integer(self.total, input_name='total'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'active' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'active')
            self.active = ival_
        elif nodeName_ == 'migrating' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'migrating')
            self.migrating = ival_
        elif nodeName_ == 'total' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'total')
            self.total = ival_
# end class VmSummary


class Host(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, address=None, certificate=None, status=None, external_status=None, cluster=None, port=None, type_=None, storage_manager=None, spm=None, version=None, hardware_information=None, power_management=None, ksm=None, transparent_hugepages=None, iscsi=None, root_password=None, ssh=None, statistics=None, cpu=None, memory=None, max_scheduling_memory=None, summary=None, override_iptables=None, protocol=None, reboot_after_installation=None, os=None, hooks=None, libvirt_version=None, display=None, hosted_engine=None, kdump_status=None, selinux=None, auto_numa_status=None, numa_supported=None, live_snapshot_support=None, katello_errata=None, external_host_provider=None, update_available=None, device_passthrough=None, storage_connection_extensions=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Host, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.address = address
        self.certificate = certificate
        self.status = status
        self.external_status = external_status
        self.cluster = cluster
        self.port = port
        self.type_ = type_
        self.storage_manager = storage_manager
        self.spm = spm
        self.version = version
        self.hardware_information = hardware_information
        self.power_management = power_management
        self.ksm = ksm
        self.transparent_hugepages = transparent_hugepages
        self.iscsi = iscsi
        self.root_password = root_password
        self.ssh = ssh
        self.statistics = statistics
        self.cpu = cpu
        self.memory = memory
        self.max_scheduling_memory = max_scheduling_memory
        self.summary = summary
        self.override_iptables = override_iptables
        self.protocol = protocol
        self.reboot_after_installation = reboot_after_installation
        self.os = os
        self.hooks = hooks
        self.libvirt_version = libvirt_version
        self.display = display
        self.hosted_engine = hosted_engine
        self.kdump_status = kdump_status
        self.selinux = selinux
        self.auto_numa_status = auto_numa_status
        self.numa_supported = numa_supported
        self.live_snapshot_support = live_snapshot_support
        self.katello_errata = katello_errata
        self.external_host_provider = external_host_provider
        self.update_available = update_available
        self.device_passthrough = device_passthrough
        self.storage_connection_extensions = storage_connection_extensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Host)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Host.subclass:
            return Host.subclass(*args_, **kwargs_)
        else:
            return Host(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_certificate(self):
        return self.certificate
    def set_certificate(self, certificate):
        self.certificate = certificate
    certificateProp = property(get_certificate, set_certificate)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_external_status(self):
        return self.external_status
    def set_external_status(self, external_status):
        self.external_status = external_status
    external_statusProp = property(get_external_status, set_external_status)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_storage_manager(self):
        return self.storage_manager
    def set_storage_manager(self, storage_manager):
        self.storage_manager = storage_manager
    storage_managerProp = property(get_storage_manager, set_storage_manager)
    def get_spm(self):
        return self.spm
    def set_spm(self, spm):
        self.spm = spm
    spmProp = property(get_spm, set_spm)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_hardware_information(self):
        return self.hardware_information
    def set_hardware_information(self, hardware_information):
        self.hardware_information = hardware_information
    hardware_informationProp = property(get_hardware_information, set_hardware_information)
    def get_power_management(self):
        return self.power_management
    def set_power_management(self, power_management):
        self.power_management = power_management
    power_managementProp = property(get_power_management, set_power_management)
    def get_ksm(self):
        return self.ksm
    def set_ksm(self, ksm):
        self.ksm = ksm
    ksmProp = property(get_ksm, set_ksm)
    def get_transparent_hugepages(self):
        return self.transparent_hugepages
    def set_transparent_hugepages(self, transparent_hugepages):
        self.transparent_hugepages = transparent_hugepages
    transparent_hugepagesProp = property(get_transparent_hugepages, set_transparent_hugepages)
    def get_iscsi(self):
        return self.iscsi
    def set_iscsi(self, iscsi):
        self.iscsi = iscsi
    iscsiProp = property(get_iscsi, set_iscsi)
    def get_root_password(self):
        return self.root_password
    def set_root_password(self, root_password):
        self.root_password = root_password
    root_passwordProp = property(get_root_password, set_root_password)
    def get_ssh(self):
        return self.ssh
    def set_ssh(self, ssh):
        self.ssh = ssh
    sshProp = property(get_ssh, set_ssh)
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    statisticsProp = property(get_statistics, set_statistics)
    def get_cpu(self):
        return self.cpu
    def set_cpu(self, cpu):
        self.cpu = cpu
    cpuProp = property(get_cpu, set_cpu)
    def get_memory(self):
        return self.memory
    def set_memory(self, memory):
        self.memory = memory
    memoryProp = property(get_memory, set_memory)
    def get_max_scheduling_memory(self):
        return self.max_scheduling_memory
    def set_max_scheduling_memory(self, max_scheduling_memory):
        self.max_scheduling_memory = max_scheduling_memory
    max_scheduling_memoryProp = property(get_max_scheduling_memory, set_max_scheduling_memory)
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    summaryProp = property(get_summary, set_summary)
    def get_override_iptables(self):
        return self.override_iptables
    def set_override_iptables(self, override_iptables):
        self.override_iptables = override_iptables
    override_iptablesProp = property(get_override_iptables, set_override_iptables)
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    protocolProp = property(get_protocol, set_protocol)
    def get_reboot_after_installation(self):
        return self.reboot_after_installation
    def set_reboot_after_installation(self, reboot_after_installation):
        self.reboot_after_installation = reboot_after_installation
    reboot_after_installationProp = property(get_reboot_after_installation, set_reboot_after_installation)
    def get_os(self):
        return self.os
    def set_os(self, os):
        self.os = os
    osProp = property(get_os, set_os)
    def get_hooks(self):
        return self.hooks
    def set_hooks(self, hooks):
        self.hooks = hooks
    hooksProp = property(get_hooks, set_hooks)
    def get_libvirt_version(self):
        return self.libvirt_version
    def set_libvirt_version(self, libvirt_version):
        self.libvirt_version = libvirt_version
    libvirt_versionProp = property(get_libvirt_version, set_libvirt_version)
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    displayProp = property(get_display, set_display)
    def get_hosted_engine(self):
        return self.hosted_engine
    def set_hosted_engine(self, hosted_engine):
        self.hosted_engine = hosted_engine
    hosted_engineProp = property(get_hosted_engine, set_hosted_engine)
    def get_kdump_status(self):
        return self.kdump_status
    def set_kdump_status(self, kdump_status):
        self.kdump_status = kdump_status
    kdump_statusProp = property(get_kdump_status, set_kdump_status)
    def get_selinux(self):
        return self.selinux
    def set_selinux(self, selinux):
        self.selinux = selinux
    selinuxProp = property(get_selinux, set_selinux)
    def get_auto_numa_status(self):
        return self.auto_numa_status
    def set_auto_numa_status(self, auto_numa_status):
        self.auto_numa_status = auto_numa_status
    auto_numa_statusProp = property(get_auto_numa_status, set_auto_numa_status)
    def get_numa_supported(self):
        return self.numa_supported
    def set_numa_supported(self, numa_supported):
        self.numa_supported = numa_supported
    numa_supportedProp = property(get_numa_supported, set_numa_supported)
    def get_live_snapshot_support(self):
        return self.live_snapshot_support
    def set_live_snapshot_support(self, live_snapshot_support):
        self.live_snapshot_support = live_snapshot_support
    live_snapshot_supportProp = property(get_live_snapshot_support, set_live_snapshot_support)
    def get_katello_errata(self):
        return self.katello_errata
    def set_katello_errata(self, katello_errata):
        self.katello_errata = katello_errata
    katello_errataProp = property(get_katello_errata, set_katello_errata)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def get_update_available(self):
        return self.update_available
    def set_update_available(self, update_available):
        self.update_available = update_available
    update_availableProp = property(get_update_available, set_update_available)
    def get_device_passthrough(self):
        return self.device_passthrough
    def set_device_passthrough(self, device_passthrough):
        self.device_passthrough = device_passthrough
    device_passthroughProp = property(get_device_passthrough, set_device_passthrough)
    def get_storage_connection_extensions(self):
        return self.storage_connection_extensions
    def set_storage_connection_extensions(self, storage_connection_extensions):
        self.storage_connection_extensions = storage_connection_extensions
    storage_connection_extensionsProp = property(get_storage_connection_extensions, set_storage_connection_extensions)
    def hasContent_(self):
        if (
            self.address is not None or
            self.certificate is not None or
            self.status is not None or
            self.external_status is not None or
            self.cluster is not None or
            self.port is not None or
            self.type_ is not None or
            self.storage_manager is not None or
            self.spm is not None or
            self.version is not None or
            self.hardware_information is not None or
            self.power_management is not None or
            self.ksm is not None or
            self.transparent_hugepages is not None or
            self.iscsi is not None or
            self.root_password is not None or
            self.ssh is not None or
            self.statistics is not None or
            self.cpu is not None or
            self.memory is not None or
            self.max_scheduling_memory is not None or
            self.summary is not None or
            self.override_iptables is not None or
            self.protocol is not None or
            self.reboot_after_installation is not None or
            self.os is not None or
            self.hooks is not None or
            self.libvirt_version is not None or
            self.display is not None or
            self.hosted_engine is not None or
            self.kdump_status is not None or
            self.selinux is not None or
            self.auto_numa_status is not None or
            self.numa_supported is not None or
            self.live_snapshot_support is not None or
            self.katello_errata is not None or
            self.external_host_provider is not None or
            self.update_available is not None or
            self.device_passthrough is not None or
            self.storage_connection_extensions is not None or
            super(Host, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host'):
        super(Host, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host', fromsubclass_=False, pretty_print=True):
        super(Host, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.certificate is not None:
            self.certificate.export(outfile, level, namespaceprefix_, name_='certificate', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.external_status is not None:
            self.external_status.export(outfile, level, namespaceprefix_, name_='external_status', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.storage_manager is not None:
            self.storage_manager.export(outfile, level, namespaceprefix_, name_='storage_manager', pretty_print=pretty_print)
        if self.spm is not None:
            self.spm.export(outfile, level, namespaceprefix_, name_='spm', pretty_print=pretty_print)
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.hardware_information is not None:
            self.hardware_information.export(outfile, level, namespaceprefix_, name_='hardware_information', pretty_print=pretty_print)
        if self.power_management is not None:
            self.power_management.export(outfile, level, namespaceprefix_, name_='power_management', pretty_print=pretty_print)
        if self.ksm is not None:
            self.ksm.export(outfile, level, namespaceprefix_, name_='ksm', pretty_print=pretty_print)
        if self.transparent_hugepages is not None:
            self.transparent_hugepages.export(outfile, level, namespaceprefix_, name_='transparent_hugepages', pretty_print=pretty_print)
        if self.iscsi is not None:
            self.iscsi.export(outfile, level, namespaceprefix_, name_='iscsi', pretty_print=pretty_print)
        if self.root_password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroot_password>%s</%sroot_password>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.root_password), input_name='root_password')), namespaceprefix_ , eol_))
        if self.ssh is not None:
            self.ssh.export(outfile, level, namespaceprefix_, name_='ssh', pretty_print=pretty_print)
        if self.statistics is not None:
            self.statistics.export(outfile, level, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
        if self.cpu is not None:
            self.cpu.export(outfile, level, namespaceprefix_, name_='cpu', pretty_print=pretty_print)
        if self.memory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemory>%s</%smemory>%s' % (namespaceprefix_ , self.gds_format_integer(self.memory, input_name='memory'), namespaceprefix_ , eol_))
        if self.max_scheduling_memory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_scheduling_memory>%s</%smax_scheduling_memory>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_scheduling_memory, input_name='max_scheduling_memory'), namespaceprefix_ , eol_))
        if self.summary is not None:
            self.summary.export(outfile, level, namespaceprefix_, name_='summary', pretty_print=pretty_print)
        if self.override_iptables is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverride_iptables>%s</%soverride_iptables>%s' % (namespaceprefix_ , self.gds_format_boolean(self.override_iptables, input_name='override_iptables'), namespaceprefix_ , eol_))
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.protocol), input_name='protocol')), namespaceprefix_ , eol_))
        if self.reboot_after_installation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreboot_after_installation>%s</%sreboot_after_installation>%s' % (namespaceprefix_ , self.gds_format_boolean(self.reboot_after_installation, input_name='reboot_after_installation'), namespaceprefix_ , eol_))
        if self.os is not None:
            self.os.export(outfile, level, namespaceprefix_, name_='os', pretty_print=pretty_print)
        if self.hooks is not None:
            self.hooks.export(outfile, level, namespaceprefix_, name_='hooks', pretty_print=pretty_print)
        if self.libvirt_version is not None:
            self.libvirt_version.export(outfile, level, namespaceprefix_, name_='libvirt_version', pretty_print=pretty_print)
        if self.display is not None:
            self.display.export(outfile, level, namespaceprefix_, name_='display', pretty_print=pretty_print)
        if self.hosted_engine is not None:
            self.hosted_engine.export(outfile, level, namespaceprefix_, name_='hosted_engine', pretty_print=pretty_print)
        if self.kdump_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skdump_status>%s</%skdump_status>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.kdump_status), input_name='kdump_status')), namespaceprefix_ , eol_))
        if self.selinux is not None:
            self.selinux.export(outfile, level, namespaceprefix_, name_='selinux', pretty_print=pretty_print)
        if self.auto_numa_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto_numa_status>%s</%sauto_numa_status>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.auto_numa_status), input_name='auto_numa_status')), namespaceprefix_ , eol_))
        if self.numa_supported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snuma_supported>%s</%snuma_supported>%s' % (namespaceprefix_ , self.gds_format_boolean(self.numa_supported, input_name='numa_supported'), namespaceprefix_ , eol_))
        if self.live_snapshot_support is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slive_snapshot_support>%s</%slive_snapshot_support>%s' % (namespaceprefix_ , self.gds_format_boolean(self.live_snapshot_support, input_name='live_snapshot_support'), namespaceprefix_ , eol_))
        if self.katello_errata is not None:
            self.katello_errata.export(outfile, level, namespaceprefix_, name_='katello_errata', pretty_print=pretty_print)
        if self.external_host_provider is not None:
            self.external_host_provider.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
        if self.update_available is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdate_available>%s</%supdate_available>%s' % (namespaceprefix_ , self.gds_format_boolean(self.update_available, input_name='update_available'), namespaceprefix_ , eol_))
        if self.device_passthrough is not None:
            self.device_passthrough.export(outfile, level, namespaceprefix_, name_='device_passthrough', pretty_print=pretty_print)
        if self.storage_connection_extensions is not None:
            self.storage_connection_extensions.export(outfile, level, namespaceprefix_, name_='storage_connection_extensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Host, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'certificate':
            obj_ = Certificate.factory(parent_object_=self)
            obj_.build(child_)
            self.certificate = obj_
            obj_.original_tagname_ = 'certificate'
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'external_status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.external_status = obj_
            obj_.original_tagname_ = 'external_status'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'storage_manager':
            obj_ = StorageManager.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_manager = obj_
            obj_.original_tagname_ = 'storage_manager'
        elif nodeName_ == 'spm':
            obj_ = SPM.factory(parent_object_=self)
            obj_.build(child_)
            self.spm = obj_
            obj_.original_tagname_ = 'spm'
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'hardware_information':
            obj_ = HardwareInformation.factory(parent_object_=self)
            obj_.build(child_)
            self.hardware_information = obj_
            obj_.original_tagname_ = 'hardware_information'
        elif nodeName_ == 'power_management':
            obj_ = PowerManagement.factory(parent_object_=self)
            obj_.build(child_)
            self.power_management = obj_
            obj_.original_tagname_ = 'power_management'
        elif nodeName_ == 'ksm':
            obj_ = KSM.factory(parent_object_=self)
            obj_.build(child_)
            self.ksm = obj_
            obj_.original_tagname_ = 'ksm'
        elif nodeName_ == 'transparent_hugepages':
            obj_ = TransparentHugePages.factory(parent_object_=self)
            obj_.build(child_)
            self.transparent_hugepages = obj_
            obj_.original_tagname_ = 'transparent_hugepages'
        elif nodeName_ == 'iscsi':
            obj_ = IscsiDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.iscsi = obj_
            obj_.original_tagname_ = 'iscsi'
        elif nodeName_ == 'root_password':
            root_password_ = child_.text
            root_password_ = self.gds_validate_string(root_password_, node, 'root_password')
            self.root_password = root_password_
        elif nodeName_ == 'ssh':
            obj_ = SSH.factory(parent_object_=self)
            obj_.build(child_)
            self.ssh = obj_
            obj_.original_tagname_ = 'ssh'
        elif nodeName_ == 'statistics':
            obj_ = Statistics.factory(parent_object_=self)
            obj_.build(child_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'cpu':
            obj_ = CPU.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu = obj_
            obj_.original_tagname_ = 'cpu'
        elif nodeName_ == 'memory' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memory')
            self.memory = ival_
        elif nodeName_ == 'max_scheduling_memory' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_scheduling_memory')
            self.max_scheduling_memory = ival_
        elif nodeName_ == 'summary':
            obj_ = ApiSummary.factory(parent_object_=self)
            obj_.build(child_)
            self.summary = obj_
            obj_.original_tagname_ = 'summary'
        elif nodeName_ == 'override_iptables':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'override_iptables')
            self.override_iptables = ival_
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'reboot_after_installation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'reboot_after_installation')
            self.reboot_after_installation = ival_
        elif nodeName_ == 'os':
            obj_ = OperatingSystem.factory(parent_object_=self)
            obj_.build(child_)
            self.os = obj_
            obj_.original_tagname_ = 'os'
        elif nodeName_ == 'hooks':
            obj_ = Hooks.factory(parent_object_=self)
            obj_.build(child_)
            self.hooks = obj_
            obj_.original_tagname_ = 'hooks'
        elif nodeName_ == 'libvirt_version':
            class_obj_ = self.get_class_obj_(child_, Version)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.libvirt_version = obj_
            obj_.original_tagname_ = 'libvirt_version'
        elif nodeName_ == 'display':
            obj_ = Display.factory(parent_object_=self)
            obj_.build(child_)
            self.display = obj_
            obj_.original_tagname_ = 'display'
        elif nodeName_ == 'hosted_engine':
            obj_ = HostedEngine.factory(parent_object_=self)
            obj_.build(child_)
            self.hosted_engine = obj_
            obj_.original_tagname_ = 'hosted_engine'
        elif nodeName_ == 'kdump_status':
            kdump_status_ = child_.text
            kdump_status_ = self.gds_validate_string(kdump_status_, node, 'kdump_status')
            self.kdump_status = kdump_status_
        elif nodeName_ == 'selinux':
            obj_ = SELinux.factory(parent_object_=self)
            obj_.build(child_)
            self.selinux = obj_
            obj_.original_tagname_ = 'selinux'
        elif nodeName_ == 'auto_numa_status':
            auto_numa_status_ = child_.text
            auto_numa_status_ = self.gds_validate_string(auto_numa_status_, node, 'auto_numa_status')
            self.auto_numa_status = auto_numa_status_
        elif nodeName_ == 'numa_supported':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'numa_supported')
            self.numa_supported = ival_
        elif nodeName_ == 'live_snapshot_support':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'live_snapshot_support')
            self.live_snapshot_support = ival_
        elif nodeName_ == 'katello_errata':
            obj_ = KatelloErrata.factory(parent_object_=self)
            obj_.build(child_)
            self.katello_errata = obj_
            obj_.original_tagname_ = 'katello_errata'
        elif nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider = obj_
            obj_.original_tagname_ = 'external_host_provider'
        elif nodeName_ == 'update_available':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'update_available')
            self.update_available = ival_
        elif nodeName_ == 'device_passthrough':
            obj_ = HostDevicePassthrough.factory(parent_object_=self)
            obj_.build(child_)
            self.device_passthrough = obj_
            obj_.original_tagname_ = 'device_passthrough'
        elif nodeName_ == 'storage_connection_extensions':
            obj_ = StorageConnectionExtensions.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_connection_extensions = obj_
            obj_.original_tagname_ = 'storage_connection_extensions'
        super(Host, self).buildChildren(child_, node, nodeName_, True)
# end class Host


class HostDevicePassthrough(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostDevicePassthrough)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostDevicePassthrough.subclass:
            return HostDevicePassthrough.subclass(*args_, **kwargs_)
        else:
            return HostDevicePassthrough(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def hasContent_(self):
        if (
            self.enabled is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='device_passthrough', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('device_passthrough')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='device_passthrough')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='device_passthrough', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='device_passthrough'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='device_passthrough', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
# end class HostDevicePassthrough


class StorageManager(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, priority=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.priority = _cast(int, priority)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageManager)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageManager.subclass:
            return StorageManager.subclass(*args_, **kwargs_)
        else:
            return StorageManager(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    priorityProp = property(get_priority, set_priority)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_manager', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_manager')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_manager')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_manager', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_manager'):
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_integer(self.priority, input_name='priority'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_manager', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            try:
                self.priority = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StorageManager


class SPM(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, priority=None, status=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.priority = priority
        self.status = status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SPM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SPM.subclass:
            return SPM.subclass(*args_, **kwargs_)
        else:
            return SPM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    priorityProp = property(get_priority, set_priority)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def hasContent_(self):
        if (
            self.priority is not None or
            self.status is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='spm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('spm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='spm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='spm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='spm'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='spm', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.priority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriority>%s</%spriority>%s' % (namespaceprefix_ , self.gds_format_integer(self.priority, input_name='priority'), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'priority' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'priority')
            self.priority = ival_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
# end class SPM


class HostedEngine(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, configured=None, active=None, score=None, global_maintenance=None, local_maintenance=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.configured = configured
        self.active = active
        self.score = score
        self.global_maintenance = global_maintenance
        self.local_maintenance = local_maintenance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostedEngine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostedEngine.subclass:
            return HostedEngine.subclass(*args_, **kwargs_)
        else:
            return HostedEngine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configured(self):
        return self.configured
    def set_configured(self, configured):
        self.configured = configured
    configuredProp = property(get_configured, set_configured)
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    activeProp = property(get_active, set_active)
    def get_score(self):
        return self.score
    def set_score(self, score):
        self.score = score
    scoreProp = property(get_score, set_score)
    def get_global_maintenance(self):
        return self.global_maintenance
    def set_global_maintenance(self, global_maintenance):
        self.global_maintenance = global_maintenance
    global_maintenanceProp = property(get_global_maintenance, set_global_maintenance)
    def get_local_maintenance(self):
        return self.local_maintenance
    def set_local_maintenance(self, local_maintenance):
        self.local_maintenance = local_maintenance
    local_maintenanceProp = property(get_local_maintenance, set_local_maintenance)
    def hasContent_(self):
        if (
            self.configured is not None or
            self.active is not None or
            self.score is not None or
            self.global_maintenance is not None or
            self.local_maintenance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='hosted_engine', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hosted_engine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hosted_engine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='hosted_engine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hosted_engine'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='hosted_engine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.configured is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconfigured>%s</%sconfigured>%s' % (namespaceprefix_ , self.gds_format_boolean(self.configured, input_name='configured'), namespaceprefix_ , eol_))
        if self.active is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactive>%s</%sactive>%s' % (namespaceprefix_ , self.gds_format_boolean(self.active, input_name='active'), namespaceprefix_ , eol_))
        if self.score is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscore>%s</%sscore>%s' % (namespaceprefix_ , self.gds_format_integer(self.score, input_name='score'), namespaceprefix_ , eol_))
        if self.global_maintenance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sglobal_maintenance>%s</%sglobal_maintenance>%s' % (namespaceprefix_ , self.gds_format_boolean(self.global_maintenance, input_name='global_maintenance'), namespaceprefix_ , eol_))
        if self.local_maintenance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocal_maintenance>%s</%slocal_maintenance>%s' % (namespaceprefix_ , self.gds_format_boolean(self.local_maintenance, input_name='local_maintenance'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configured':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'configured')
            self.configured = ival_
        elif nodeName_ == 'active':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'active')
            self.active = ival_
        elif nodeName_ == 'score' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'score')
            self.score = ival_
        elif nodeName_ == 'global_maintenance':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'global_maintenance')
            self.global_maintenance = ival_
        elif nodeName_ == 'local_maintenance':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'local_maintenance')
            self.local_maintenance = ival_
# end class HostedEngine


class HostProtocols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host_protocol=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if host_protocol is None:
            self.host_protocol = []
        else:
            self.host_protocol = host_protocol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostProtocols)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostProtocols.subclass:
            return HostProtocols.subclass(*args_, **kwargs_)
        else:
            return HostProtocols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_protocol(self):
        return self.host_protocol
    def set_host_protocol(self, host_protocol):
        self.host_protocol = host_protocol
    def add_host_protocol(self, value):
        self.host_protocol.append(value)
    def insert_host_protocol_at(self, index, value):
        self.host_protocol.insert(index, value)
    def replace_host_protocol_at(self, index, value):
        self.host_protocol[index] = value
    host_protocolProp = property(get_host_protocol, set_host_protocol)
    def hasContent_(self):
        if (
            self.host_protocol
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_protocols', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_protocols')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_protocols')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_protocols', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_protocols'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_protocols', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_protocol_ in self.host_protocol:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost_protocol>%s</%shost_protocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(host_protocol_), input_name='host_protocol')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_protocol':
            host_protocol_ = child_.text
            host_protocol_ = self.gds_validate_string(host_protocol_, node, 'host_protocol')
            self.host_protocol.append(host_protocol_)
# end class HostProtocols


class HostNonOperationalDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host_non_operational_detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if host_non_operational_detail is None:
            self.host_non_operational_detail = []
        else:
            self.host_non_operational_detail = host_non_operational_detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostNonOperationalDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostNonOperationalDetails.subclass:
            return HostNonOperationalDetails.subclass(*args_, **kwargs_)
        else:
            return HostNonOperationalDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_non_operational_detail(self):
        return self.host_non_operational_detail
    def set_host_non_operational_detail(self, host_non_operational_detail):
        self.host_non_operational_detail = host_non_operational_detail
    def add_host_non_operational_detail(self, value):
        self.host_non_operational_detail.append(value)
    def insert_host_non_operational_detail_at(self, index, value):
        self.host_non_operational_detail.insert(index, value)
    def replace_host_non_operational_detail_at(self, index, value):
        self.host_non_operational_detail[index] = value
    host_non_operational_detailProp = property(get_host_non_operational_detail, set_host_non_operational_detail)
    def hasContent_(self):
        if (
            self.host_non_operational_detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_non_operational_details', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_non_operational_details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_non_operational_details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_non_operational_details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_non_operational_details'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_non_operational_details', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_non_operational_detail_ in self.host_non_operational_detail:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost_non_operational_detail>%s</%shost_non_operational_detail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(host_non_operational_detail_), input_name='host_non_operational_detail')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_non_operational_detail':
            host_non_operational_detail_ = child_.text
            host_non_operational_detail_ = self.gds_validate_string(host_non_operational_detail_, node, 'host_non_operational_detail')
            self.host_non_operational_detail.append(host_non_operational_detail_)
# end class HostNonOperationalDetails


class Hosts(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Hosts, self).__init__(actions, size, total, active,  **kwargs_)
        if host is None:
            self.host = []
        else:
            self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hosts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hosts.subclass:
            return Hosts.subclass(*args_, **kwargs_)
        else:
            return Hosts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    def add_host(self, value):
        self.host.append(value)
    def insert_host_at(self, index, value):
        self.host.insert(index, value)
    def replace_host_at(self, index, value):
        self.host[index] = value
    hostProp = property(get_host, set_host)
    def hasContent_(self):
        if (
            self.host or
            super(Hosts, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='hosts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hosts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hosts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='hosts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hosts'):
        super(Hosts, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hosts')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='hosts', fromsubclass_=False, pretty_print=True):
        super(Hosts, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_ in self.host:
            host_.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Hosts, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host.append(obj_)
            obj_.original_tagname_ = 'host'
        super(Hosts, self).buildChildren(child_, node, nodeName_, True)
# end class Hosts


class Permit(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, administrative=None, role=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Permit, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.administrative = administrative
        self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Permit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Permit.subclass:
            return Permit.subclass(*args_, **kwargs_)
        else:
            return Permit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_administrative(self):
        return self.administrative
    def set_administrative(self, administrative):
        self.administrative = administrative
    administrativeProp = property(get_administrative, set_administrative)
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    roleProp = property(get_role, set_role)
    def hasContent_(self):
        if (
            self.administrative is not None or
            self.role is not None or
            super(Permit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='permit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('permit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='permit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='permit'):
        super(Permit, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permit')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='permit', fromsubclass_=False, pretty_print=True):
        super(Permit, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.administrative is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadministrative>%s</%sadministrative>%s' % (namespaceprefix_ , self.gds_format_boolean(self.administrative, input_name='administrative'), namespaceprefix_ , eol_))
        if self.role is not None:
            self.role.export(outfile, level, namespaceprefix_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Permit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'administrative':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'administrative')
            self.administrative = ival_
        elif nodeName_ == 'role':
            obj_ = Role.factory(parent_object_=self)
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        super(Permit, self).buildChildren(child_, node, nodeName_, True)
# end class Permit


class Permits(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, permit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Permits, self).__init__(actions, size, total, active,  **kwargs_)
        if permit is None:
            self.permit = []
        else:
            self.permit = permit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Permits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Permits.subclass:
            return Permits.subclass(*args_, **kwargs_)
        else:
            return Permits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_permit(self):
        return self.permit
    def set_permit(self, permit):
        self.permit = permit
    def add_permit(self, value):
        self.permit.append(value)
    def insert_permit_at(self, index, value):
        self.permit.insert(index, value)
    def replace_permit_at(self, index, value):
        self.permit[index] = value
    permitProp = property(get_permit, set_permit)
    def hasContent_(self):
        if (
            self.permit or
            super(Permits, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='permits', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('permits')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='permits', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='permits'):
        super(Permits, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permits')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='permits', fromsubclass_=False, pretty_print=True):
        super(Permits, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for permit_ in self.permit:
            permit_.export(outfile, level, namespaceprefix_, name_='permit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Permits, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'permit':
            obj_ = Permit.factory(parent_object_=self)
            obj_.build(child_)
            self.permit.append(obj_)
            obj_.original_tagname_ = 'permit'
        super(Permits, self).buildChildren(child_, node, nodeName_, True)
# end class Permits


class Role(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, mutable=None, administrative=None, user=None, permits=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Role, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.mutable = mutable
        self.administrative = administrative
        self.user = user
        self.permits = permits
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Role)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Role.subclass:
            return Role.subclass(*args_, **kwargs_)
        else:
            return Role(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mutable(self):
        return self.mutable
    def set_mutable(self, mutable):
        self.mutable = mutable
    mutableProp = property(get_mutable, set_mutable)
    def get_administrative(self):
        return self.administrative
    def set_administrative(self, administrative):
        self.administrative = administrative
    administrativeProp = property(get_administrative, set_administrative)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_permits(self):
        return self.permits
    def set_permits(self, permits):
        self.permits = permits
    permitsProp = property(get_permits, set_permits)
    def hasContent_(self):
        if (
            self.mutable is not None or
            self.administrative is not None or
            self.user is not None or
            self.permits is not None or
            super(Role, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='role', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('role')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='role')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='role', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='role'):
        super(Role, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='role')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='role', fromsubclass_=False, pretty_print=True):
        super(Role, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mutable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smutable>%s</%smutable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.mutable, input_name='mutable'), namespaceprefix_ , eol_))
        if self.administrative is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sadministrative>%s</%sadministrative>%s' % (namespaceprefix_ , self.gds_format_boolean(self.administrative, input_name='administrative'), namespaceprefix_ , eol_))
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
        if self.permits is not None:
            self.permits.export(outfile, level, namespaceprefix_, name_='permits', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Role, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mutable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'mutable')
            self.mutable = ival_
        elif nodeName_ == 'administrative':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'administrative')
            self.administrative = ival_
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'permits':
            obj_ = Permits.factory(parent_object_=self)
            obj_.build(child_)
            self.permits = obj_
            obj_.original_tagname_ = 'permits'
        super(Role, self).buildChildren(child_, node, nodeName_, True)
# end class Role


class Roles(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, role=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Roles, self).__init__(actions, size, total, active,  **kwargs_)
        if role is None:
            self.role = []
        else:
            self.role = role
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Roles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Roles.subclass:
            return Roles.subclass(*args_, **kwargs_)
        else:
            return Roles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    def add_role(self, value):
        self.role.append(value)
    def insert_role_at(self, index, value):
        self.role.insert(index, value)
    def replace_role_at(self, index, value):
        self.role[index] = value
    roleProp = property(get_role, set_role)
    def hasContent_(self):
        if (
            self.role or
            super(Roles, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='roles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('roles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='roles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='roles'):
        super(Roles, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='roles')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='roles', fromsubclass_=False, pretty_print=True):
        super(Roles, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for role_ in self.role:
            role_.export(outfile, level, namespaceprefix_, name_='role', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Roles, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'role':
            obj_ = Role.factory(parent_object_=self)
            obj_.build(child_)
            self.role.append(obj_)
            obj_.original_tagname_ = 'role'
        super(Roles, self).buildChildren(child_, node, nodeName_, True)
# end class Roles


class SSHPublicKey(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, content=None, user=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SSHPublicKey, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.content = content
        self.user = user
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SSHPublicKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SSHPublicKey.subclass:
            return SSHPublicKey.subclass(*args_, **kwargs_)
        else:
            return SSHPublicKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    contentProp = property(get_content, set_content)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def hasContent_(self):
        if (
            self.content is not None or
            self.user is not None or
            super(SSHPublicKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ssh_public_key', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ssh_public_key')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ssh_public_key')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ssh_public_key', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ssh_public_key'):
        super(SSHPublicKey, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ssh_public_key')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ssh_public_key', fromsubclass_=False, pretty_print=True):
        super(SSHPublicKey, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent>%s</%scontent>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.content), input_name='content')), namespaceprefix_ , eol_))
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SSHPublicKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            content_ = child_.text
            content_ = self.gds_validate_string(content_, node, 'content')
            self.content = content_
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        super(SSHPublicKey, self).buildChildren(child_, node, nodeName_, True)
# end class SSHPublicKey


class SSHPublicKeys(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, ssh_public_key=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SSHPublicKeys, self).__init__(actions, size, total, active,  **kwargs_)
        if ssh_public_key is None:
            self.ssh_public_key = []
        else:
            self.ssh_public_key = ssh_public_key
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SSHPublicKeys)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SSHPublicKeys.subclass:
            return SSHPublicKeys.subclass(*args_, **kwargs_)
        else:
            return SSHPublicKeys(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ssh_public_key(self):
        return self.ssh_public_key
    def set_ssh_public_key(self, ssh_public_key):
        self.ssh_public_key = ssh_public_key
    def add_ssh_public_key(self, value):
        self.ssh_public_key.append(value)
    def insert_ssh_public_key_at(self, index, value):
        self.ssh_public_key.insert(index, value)
    def replace_ssh_public_key_at(self, index, value):
        self.ssh_public_key[index] = value
    ssh_public_keyProp = property(get_ssh_public_key, set_ssh_public_key)
    def hasContent_(self):
        if (
            self.ssh_public_key or
            super(SSHPublicKeys, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ssh_public_keys', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ssh_public_keys')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ssh_public_keys')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ssh_public_keys', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ssh_public_keys'):
        super(SSHPublicKeys, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ssh_public_keys')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ssh_public_keys', fromsubclass_=False, pretty_print=True):
        super(SSHPublicKeys, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ssh_public_key_ in self.ssh_public_key:
            ssh_public_key_.export(outfile, level, namespaceprefix_, name_='ssh_public_key', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SSHPublicKeys, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ssh_public_key':
            obj_ = SSHPublicKey.factory(parent_object_=self)
            obj_.build(child_)
            self.ssh_public_key.append(obj_)
            obj_.original_tagname_ = 'ssh_public_key'
        super(SSHPublicKeys, self).buildChildren(child_, node, nodeName_, True)
# end class SSHPublicKeys


class User(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, domain=None, domain_entry_id=None, department=None, logged_in=None, namespace=None, last_name=None, user_name=None, principal=None, password=None, email=None, roles=None, groups=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(User, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.domain = domain
        self.domain_entry_id = domain_entry_id
        self.department = department
        self.logged_in = logged_in
        self.namespace = namespace
        self.last_name = last_name
        self.user_name = user_name
        self.principal = principal
        self.password = password
        self.email = email
        self.roles = roles
        self.groups = groups
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, User)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if User.subclass:
            return User.subclass(*args_, **kwargs_)
        else:
            return User(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domain(self):
        return self.domain
    def set_domain(self, domain):
        self.domain = domain
    domainProp = property(get_domain, set_domain)
    def get_domain_entry_id(self):
        return self.domain_entry_id
    def set_domain_entry_id(self, domain_entry_id):
        self.domain_entry_id = domain_entry_id
    domain_entry_idProp = property(get_domain_entry_id, set_domain_entry_id)
    def get_department(self):
        return self.department
    def set_department(self, department):
        self.department = department
    departmentProp = property(get_department, set_department)
    def get_logged_in(self):
        return self.logged_in
    def set_logged_in(self, logged_in):
        self.logged_in = logged_in
    logged_inProp = property(get_logged_in, set_logged_in)
    def get_namespace(self):
        return self.namespace
    def set_namespace(self, namespace):
        self.namespace = namespace
    namespaceProp = property(get_namespace, set_namespace)
    def get_last_name(self):
        return self.last_name
    def set_last_name(self, last_name):
        self.last_name = last_name
    last_nameProp = property(get_last_name, set_last_name)
    def get_user_name(self):
        return self.user_name
    def set_user_name(self, user_name):
        self.user_name = user_name
    user_nameProp = property(get_user_name, set_user_name)
    def get_principal(self):
        return self.principal
    def set_principal(self, principal):
        self.principal = principal
    principalProp = property(get_principal, set_principal)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    emailProp = property(get_email, set_email)
    def get_roles(self):
        return self.roles
    def set_roles(self, roles):
        self.roles = roles
    rolesProp = property(get_roles, set_roles)
    def get_groups(self):
        return self.groups
    def set_groups(self, groups):
        self.groups = groups
    groupsProp = property(get_groups, set_groups)
    def hasContent_(self):
        if (
            self.domain is not None or
            self.domain_entry_id is not None or
            self.department is not None or
            self.logged_in is not None or
            self.namespace is not None or
            self.last_name is not None or
            self.user_name is not None or
            self.principal is not None or
            self.password is not None or
            self.email is not None or
            self.roles is not None or
            self.groups is not None or
            super(User, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='user', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('user')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='user')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='user', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='user'):
        super(User, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='user')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='user', fromsubclass_=False, pretty_print=True):
        super(User, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.domain is not None:
            self.domain.export(outfile, level, namespaceprefix_, name_='domain', pretty_print=pretty_print)
        if self.domain_entry_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain_entry_id>%s</%sdomain_entry_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.domain_entry_id), input_name='domain_entry_id')), namespaceprefix_ , eol_))
        if self.department is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdepartment>%s</%sdepartment>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.department), input_name='department')), namespaceprefix_ , eol_))
        if self.logged_in is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogged_in>%s</%slogged_in>%s' % (namespaceprefix_ , self.gds_format_boolean(self.logged_in, input_name='logged_in'), namespaceprefix_ , eol_))
        if self.namespace is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snamespace>%s</%snamespace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.namespace), input_name='namespace')), namespaceprefix_ , eol_))
        if self.last_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast_name>%s</%slast_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.last_name), input_name='last_name')), namespaceprefix_ , eol_))
        if self.user_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser_name>%s</%suser_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.user_name), input_name='user_name')), namespaceprefix_ , eol_))
        if self.principal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprincipal>%s</%sprincipal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.principal), input_name='principal')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
        if self.roles is not None:
            self.roles.export(outfile, level, namespaceprefix_, name_='roles', pretty_print=pretty_print)
        if self.groups is not None:
            self.groups.export(outfile, level, namespaceprefix_, name_='groups', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(User, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.domain = obj_
            obj_.original_tagname_ = 'domain'
        elif nodeName_ == 'domain_entry_id':
            domain_entry_id_ = child_.text
            domain_entry_id_ = self.gds_validate_string(domain_entry_id_, node, 'domain_entry_id')
            self.domain_entry_id = domain_entry_id_
        elif nodeName_ == 'department':
            department_ = child_.text
            department_ = self.gds_validate_string(department_, node, 'department')
            self.department = department_
        elif nodeName_ == 'logged_in':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'logged_in')
            self.logged_in = ival_
        elif nodeName_ == 'namespace':
            namespace_ = child_.text
            namespace_ = self.gds_validate_string(namespace_, node, 'namespace')
            self.namespace = namespace_
        elif nodeName_ == 'last_name':
            last_name_ = child_.text
            last_name_ = self.gds_validate_string(last_name_, node, 'last_name')
            self.last_name = last_name_
        elif nodeName_ == 'user_name':
            user_name_ = child_.text
            user_name_ = self.gds_validate_string(user_name_, node, 'user_name')
            self.user_name = user_name_
        elif nodeName_ == 'principal':
            principal_ = child_.text
            principal_ = self.gds_validate_string(principal_, node, 'principal')
            self.principal = principal_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
        elif nodeName_ == 'roles':
            obj_ = Roles.factory(parent_object_=self)
            obj_.build(child_)
            self.roles = obj_
            obj_.original_tagname_ = 'roles'
        elif nodeName_ == 'groups':
            obj_ = Groups.factory(parent_object_=self)
            obj_.build(child_)
            self.groups = obj_
            obj_.original_tagname_ = 'groups'
        super(User, self).buildChildren(child_, node, nodeName_, True)
# end class User


class Users(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, user=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Users, self).__init__(actions, size, total, active,  **kwargs_)
        if user is None:
            self.user = []
        else:
            self.user = user
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Users)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Users.subclass:
            return Users.subclass(*args_, **kwargs_)
        else:
            return Users(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    def add_user(self, value):
        self.user.append(value)
    def insert_user_at(self, index, value):
        self.user.insert(index, value)
    def replace_user_at(self, index, value):
        self.user[index] = value
    userProp = property(get_user, set_user)
    def hasContent_(self):
        if (
            self.user or
            super(Users, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='users', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('users')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='users')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='users', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='users'):
        super(Users, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='users')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='users', fromsubclass_=False, pretty_print=True):
        super(Users, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for user_ in self.user:
            user_.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Users, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user.append(obj_)
            obj_.original_tagname_ = 'user'
        super(Users, self).buildChildren(child_, node, nodeName_, True)
# end class Users


class AuthenticationMethod(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, authentication_method=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if authentication_method is None:
            self.authentication_method = []
        else:
            self.authentication_method = authentication_method
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthenticationMethod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthenticationMethod.subclass:
            return AuthenticationMethod.subclass(*args_, **kwargs_)
        else:
            return AuthenticationMethod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authentication_method(self):
        return self.authentication_method
    def set_authentication_method(self, authentication_method):
        self.authentication_method = authentication_method
    def add_authentication_method(self, value):
        self.authentication_method.append(value)
    def insert_authentication_method_at(self, index, value):
        self.authentication_method.insert(index, value)
    def replace_authentication_method_at(self, index, value):
        self.authentication_method[index] = value
    authentication_methodProp = property(get_authentication_method, set_authentication_method)
    def hasContent_(self):
        if (
            self.authentication_method
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='authentication_methods', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('authentication_methods')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='authentication_methods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='authentication_methods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='authentication_methods'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='authentication_methods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for authentication_method_ in self.authentication_method:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauthentication_method>%s</%sauthentication_method>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(authentication_method_), input_name='authentication_method')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'authentication_method':
            authentication_method_ = child_.text
            authentication_method_ = self.gds_validate_string(authentication_method_, node, 'authentication_method')
            self.authentication_method.append(authentication_method_)
# end class AuthenticationMethod


class SSH(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, port=None, fingerprint=None, authentication_method=None, user=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SSH, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.port = port
        self.fingerprint = fingerprint
        self.authentication_method = authentication_method
        self.user = user
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SSH)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SSH.subclass:
            return SSH.subclass(*args_, **kwargs_)
        else:
            return SSH(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_fingerprint(self):
        return self.fingerprint
    def set_fingerprint(self, fingerprint):
        self.fingerprint = fingerprint
    fingerprintProp = property(get_fingerprint, set_fingerprint)
    def get_authentication_method(self):
        return self.authentication_method
    def set_authentication_method(self, authentication_method):
        self.authentication_method = authentication_method
    authentication_methodProp = property(get_authentication_method, set_authentication_method)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def hasContent_(self):
        if (
            self.port is not None or
            self.fingerprint is not None or
            self.authentication_method is not None or
            self.user is not None or
            super(SSH, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ssh', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ssh')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ssh')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ssh', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ssh'):
        super(SSH, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ssh')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ssh', fromsubclass_=False, pretty_print=True):
        super(SSH, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.fingerprint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfingerprint>%s</%sfingerprint>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fingerprint), input_name='fingerprint')), namespaceprefix_ , eol_))
        if self.authentication_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauthentication_method>%s</%sauthentication_method>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.authentication_method), input_name='authentication_method')), namespaceprefix_ , eol_))
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SSH, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'fingerprint':
            fingerprint_ = child_.text
            fingerprint_ = self.gds_validate_string(fingerprint_, node, 'fingerprint')
            self.fingerprint = fingerprint_
        elif nodeName_ == 'authentication_method':
            authentication_method_ = child_.text
            authentication_method_ = self.gds_validate_string(authentication_method_, node, 'authentication_method')
            self.authentication_method = authentication_method_
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        super(SSH, self).buildChildren(child_, node, nodeName_, True)
# end class SSH


class Group(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, domain=None, domain_entry_id=None, namespace=None, roles=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Group, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.domain = domain
        self.domain_entry_id = domain_entry_id
        self.namespace = namespace
        self.roles = roles
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Group.subclass:
            return Group.subclass(*args_, **kwargs_)
        else:
            return Group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domain(self):
        return self.domain
    def set_domain(self, domain):
        self.domain = domain
    domainProp = property(get_domain, set_domain)
    def get_domain_entry_id(self):
        return self.domain_entry_id
    def set_domain_entry_id(self, domain_entry_id):
        self.domain_entry_id = domain_entry_id
    domain_entry_idProp = property(get_domain_entry_id, set_domain_entry_id)
    def get_namespace(self):
        return self.namespace
    def set_namespace(self, namespace):
        self.namespace = namespace
    namespaceProp = property(get_namespace, set_namespace)
    def get_roles(self):
        return self.roles
    def set_roles(self, roles):
        self.roles = roles
    rolesProp = property(get_roles, set_roles)
    def hasContent_(self):
        if (
            self.domain is not None or
            self.domain_entry_id is not None or
            self.namespace is not None or
            self.roles is not None or
            super(Group, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='group', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='group'):
        super(Group, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='group')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='group', fromsubclass_=False, pretty_print=True):
        super(Group, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.domain is not None:
            self.domain.export(outfile, level, namespaceprefix_, name_='domain', pretty_print=pretty_print)
        if self.domain_entry_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain_entry_id>%s</%sdomain_entry_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.domain_entry_id), input_name='domain_entry_id')), namespaceprefix_ , eol_))
        if self.namespace is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snamespace>%s</%snamespace>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.namespace), input_name='namespace')), namespaceprefix_ , eol_))
        if self.roles is not None:
            self.roles.export(outfile, level, namespaceprefix_, name_='roles', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Group, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.domain = obj_
            obj_.original_tagname_ = 'domain'
        elif nodeName_ == 'domain_entry_id':
            domain_entry_id_ = child_.text
            domain_entry_id_ = self.gds_validate_string(domain_entry_id_, node, 'domain_entry_id')
            self.domain_entry_id = domain_entry_id_
        elif nodeName_ == 'namespace':
            namespace_ = child_.text
            namespace_ = self.gds_validate_string(namespace_, node, 'namespace')
            self.namespace = namespace_
        elif nodeName_ == 'roles':
            obj_ = Roles.factory(parent_object_=self)
            obj_.build(child_)
            self.roles = obj_
            obj_.original_tagname_ = 'roles'
        super(Group, self).buildChildren(child_, node, nodeName_, True)
# end class Group


class Groups(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, group=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Groups, self).__init__(actions, size, total, active,  **kwargs_)
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Groups)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Groups.subclass:
            return Groups.subclass(*args_, **kwargs_)
        else:
            return Groups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    groupProp = property(get_group, set_group)
    def hasContent_(self):
        if (
            self.group or
            super(Groups, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='groups', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groups')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='groups', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='groups'):
        super(Groups, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groups')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='groups', fromsubclass_=False, pretty_print=True):
        super(Groups, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            group_.export(outfile, level, namespaceprefix_, name_='group', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Groups, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            obj_ = Group.factory(parent_object_=self)
            obj_.build(child_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        super(Groups, self).buildChildren(child_, node, nodeName_, True)
# end class Groups


class Permission(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, role=None, user=None, group=None, data_center=None, cluster=None, host=None, storage_domain=None, vm=None, vmpool=None, template=None, disk=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Permission, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.role = role
        self.user = user
        self.group = group
        self.data_center = data_center
        self.cluster = cluster
        self.host = host
        self.storage_domain = storage_domain
        self.vm = vm
        self.vmpool = vmpool
        self.template = template
        self.disk = disk
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Permission)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Permission.subclass:
            return Permission.subclass(*args_, **kwargs_)
        else:
            return Permission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role(self):
        return self.role
    def set_role(self, role):
        self.role = role
    roleProp = property(get_role, set_role)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    groupProp = property(get_group, set_group)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_vmpool(self):
        return self.vmpool
    def set_vmpool(self, vmpool):
        self.vmpool = vmpool
    vmpoolProp = property(get_vmpool, set_vmpool)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_disk(self):
        return self.disk
    def set_disk(self, disk):
        self.disk = disk
    diskProp = property(get_disk, set_disk)
    def hasContent_(self):
        if (
            self.role is not None or
            self.user is not None or
            self.group is not None or
            self.data_center is not None or
            self.cluster is not None or
            self.host is not None or
            self.storage_domain is not None or
            self.vm is not None or
            self.vmpool is not None or
            self.template is not None or
            self.disk is not None or
            super(Permission, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='permission', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('permission')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='permission', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='permission'):
        super(Permission, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permission')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='permission', fromsubclass_=False, pretty_print=True):
        super(Permission, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            self.role.export(outfile, level, namespaceprefix_, name_='role', pretty_print=pretty_print)
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
        if self.group is not None:
            self.group.export(outfile, level, namespaceprefix_, name_='group', pretty_print=pretty_print)
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.vmpool is not None:
            self.vmpool.export(outfile, level, namespaceprefix_, name_='vmpool', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.disk is not None:
            self.disk.export(outfile, level, namespaceprefix_, name_='disk', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Permission, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'role':
            obj_ = Role.factory(parent_object_=self)
            obj_.build(child_)
            self.role = obj_
            obj_.original_tagname_ = 'role'
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'group':
            obj_ = Group.factory(parent_object_=self)
            obj_.build(child_)
            self.group = obj_
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'vmpool':
            obj_ = VmPool.factory(parent_object_=self)
            obj_.build(child_)
            self.vmpool = obj_
            obj_.original_tagname_ = 'vmpool'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'disk':
            class_obj_ = self.get_class_obj_(child_, Disk)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.disk = obj_
            obj_.original_tagname_ = 'disk'
        super(Permission, self).buildChildren(child_, node, nodeName_, True)
# end class Permission


class Permissions(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, permission=None, clone=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Permissions, self).__init__(actions, size, total, active,  **kwargs_)
        if permission is None:
            self.permission = []
        else:
            self.permission = permission
        self.clone = clone
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Permissions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Permissions.subclass:
            return Permissions.subclass(*args_, **kwargs_)
        else:
            return Permissions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_permission(self):
        return self.permission
    def set_permission(self, permission):
        self.permission = permission
    def add_permission(self, value):
        self.permission.append(value)
    def insert_permission_at(self, index, value):
        self.permission.insert(index, value)
    def replace_permission_at(self, index, value):
        self.permission[index] = value
    permissionProp = property(get_permission, set_permission)
    def get_clone(self):
        return self.clone
    def set_clone(self, clone):
        self.clone = clone
    cloneProp = property(get_clone, set_clone)
    def hasContent_(self):
        if (
            self.permission or
            self.clone is not None or
            super(Permissions, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='permissions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('permissions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permissions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='permissions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='permissions'):
        super(Permissions, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='permissions')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='permissions', fromsubclass_=False, pretty_print=True):
        super(Permissions, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for permission_ in self.permission:
            permission_.export(outfile, level, namespaceprefix_, name_='permission', pretty_print=pretty_print)
        if self.clone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclone>%s</%sclone>%s' % (namespaceprefix_ , self.gds_format_boolean(self.clone, input_name='clone'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Permissions, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'permission':
            obj_ = Permission.factory(parent_object_=self)
            obj_.build(child_)
            self.permission.append(obj_)
            obj_.original_tagname_ = 'permission'
        elif nodeName_ == 'clone':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'clone')
            self.clone = ival_
        super(Permissions, self).buildChildren(child_, node, nodeName_, True)
# end class Permissions


class Domain(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, user=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Domain, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.user = user
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Domain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Domain.subclass:
            return Domain.subclass(*args_, **kwargs_)
        else:
            return Domain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def hasContent_(self):
        if (
            self.user is not None or
            super(Domain, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='domain', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('domain')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='domain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='domain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='domain'):
        super(Domain, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='domain')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='domain', fromsubclass_=False, pretty_print=True):
        super(Domain, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Domain, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        super(Domain, self).buildChildren(child_, node, nodeName_, True)
# end class Domain


class Domains(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Domains, self).__init__(actions, size, total, active,  **kwargs_)
        if domain is None:
            self.domain = []
        else:
            self.domain = domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Domains)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Domains.subclass:
            return Domains.subclass(*args_, **kwargs_)
        else:
            return Domains(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domain(self):
        return self.domain
    def set_domain(self, domain):
        self.domain = domain
    def add_domain(self, value):
        self.domain.append(value)
    def insert_domain_at(self, index, value):
        self.domain.insert(index, value)
    def replace_domain_at(self, index, value):
        self.domain[index] = value
    domainProp = property(get_domain, set_domain)
    def hasContent_(self):
        if (
            self.domain or
            super(Domains, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='domains', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('domains')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='domains')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='domains', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='domains'):
        super(Domains, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='domains')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='domains', fromsubclass_=False, pretty_print=True):
        super(Domains, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for domain_ in self.domain:
            domain_.export(outfile, level, namespaceprefix_, name_='domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Domains, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.domain.append(obj_)
            obj_.original_tagname_ = 'domain'
        super(Domains, self).buildChildren(child_, node, nodeName_, True)
# end class Domains


class Event(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, code=None, severity=None, time=None, correlation_id=None, user=None, vm=None, storage_domain=None, host=None, template=None, cluster=None, data_center=None, origin=None, custom_id=None, flood_rate=None, custom_data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Event, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.code = code
        self.severity = severity
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
        self.correlation_id = correlation_id
        self.user = user
        self.vm = vm
        self.storage_domain = storage_domain
        self.host = host
        self.template = template
        self.cluster = cluster
        self.data_center = data_center
        self.origin = origin
        self.custom_id = custom_id
        self.flood_rate = flood_rate
        self.custom_data = custom_data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    codeProp = property(get_code, set_code)
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    severityProp = property(get_severity, set_severity)
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    timeProp = property(get_time, set_time)
    def get_correlation_id(self):
        return self.correlation_id
    def set_correlation_id(self, correlation_id):
        self.correlation_id = correlation_id
    correlation_idProp = property(get_correlation_id, set_correlation_id)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    originProp = property(get_origin, set_origin)
    def get_custom_id(self):
        return self.custom_id
    def set_custom_id(self, custom_id):
        self.custom_id = custom_id
    custom_idProp = property(get_custom_id, set_custom_id)
    def get_flood_rate(self):
        return self.flood_rate
    def set_flood_rate(self, flood_rate):
        self.flood_rate = flood_rate
    flood_rateProp = property(get_flood_rate, set_flood_rate)
    def get_custom_data(self):
        return self.custom_data
    def set_custom_data(self, custom_data):
        self.custom_data = custom_data
    custom_dataProp = property(get_custom_data, set_custom_data)
    def hasContent_(self):
        if (
            self.code is not None or
            self.severity is not None or
            self.time is not None or
            self.correlation_id is not None or
            self.user is not None or
            self.vm is not None or
            self.storage_domain is not None or
            self.host is not None or
            self.template is not None or
            self.cluster is not None or
            self.data_center is not None or
            self.origin is not None or
            self.custom_id is not None or
            self.flood_rate is not None or
            self.custom_data is not None or
            super(Event, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='event', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='event'):
        super(Event, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='event')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='event', fromsubclass_=False, pretty_print=True):
        super(Event, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scode>%s</%scode>%s' % (namespaceprefix_ , self.gds_format_integer(self.code, input_name='code'), namespaceprefix_ , eol_))
        if self.severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseverity>%s</%sseverity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.severity), input_name='severity')), namespaceprefix_ , eol_))
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.time, input_name='time'), namespaceprefix_ , eol_))
        if self.correlation_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scorrelation_id>%s</%scorrelation_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.correlation_id), input_name='correlation_id')), namespaceprefix_ , eol_))
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorigin>%s</%sorigin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.origin), input_name='origin')), namespaceprefix_ , eol_))
        if self.custom_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustom_id>%s</%scustom_id>%s' % (namespaceprefix_ , self.gds_format_integer(self.custom_id, input_name='custom_id'), namespaceprefix_ , eol_))
        if self.flood_rate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflood_rate>%s</%sflood_rate>%s' % (namespaceprefix_ , self.gds_format_integer(self.flood_rate, input_name='flood_rate'), namespaceprefix_ , eol_))
        if self.custom_data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustom_data>%s</%scustom_data>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.custom_data), input_name='custom_data')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Event, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'code')
            self.code = ival_
        elif nodeName_ == 'severity':
            severity_ = child_.text
            severity_ = self.gds_validate_string(severity_, node, 'severity')
            self.severity = severity_
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        elif nodeName_ == 'correlation_id':
            correlation_id_ = child_.text
            correlation_id_ = self.gds_validate_string(correlation_id_, node, 'correlation_id')
            self.correlation_id = correlation_id_
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'origin':
            origin_ = child_.text
            origin_ = self.gds_validate_string(origin_, node, 'origin')
            self.origin = origin_
        elif nodeName_ == 'custom_id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'custom_id')
            self.custom_id = ival_
        elif nodeName_ == 'flood_rate' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'flood_rate')
            self.flood_rate = ival_
        elif nodeName_ == 'custom_data':
            custom_data_ = child_.text
            custom_data_ = self.gds_validate_string(custom_data_, node, 'custom_data')
            self.custom_data = custom_data_
        super(Event, self).buildChildren(child_, node, nodeName_, True)
# end class Event


class Events(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, event=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Events, self).__init__(actions, size, total, active,  **kwargs_)
        if event is None:
            self.event = []
        else:
            self.event = event
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Events)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Events.subclass:
            return Events.subclass(*args_, **kwargs_)
        else:
            return Events(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event(self):
        return self.event
    def set_event(self, event):
        self.event = event
    def add_event(self, value):
        self.event.append(value)
    def insert_event_at(self, index, value):
        self.event.insert(index, value)
    def replace_event_at(self, index, value):
        self.event[index] = value
    eventProp = property(get_event, set_event)
    def hasContent_(self):
        if (
            self.event or
            super(Events, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='events', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('events')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='events')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='events', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='events'):
        super(Events, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='events')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='events', fromsubclass_=False, pretty_print=True):
        super(Events, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for event_ in self.event:
            event_.export(outfile, level, namespaceprefix_, name_='event', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Events, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event':
            obj_ = Event.factory(parent_object_=self)
            obj_.build(child_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
        super(Events, self).buildChildren(child_, node, nodeName_, True)
# end class Events


class File(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, content=None, type_=None, storage_domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(File, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.content = content
        self.type_ = type_
        self.storage_domain = storage_domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, File)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if File.subclass:
            return File.subclass(*args_, **kwargs_)
        else:
            return File(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    contentProp = property(get_content, set_content)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def hasContent_(self):
        if (
            self.content is not None or
            self.type_ is not None or
            self.storage_domain is not None or
            super(File, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='file', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('file')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='file')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='file', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='file'):
        super(File, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='file')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='file', fromsubclass_=False, pretty_print=True):
        super(File, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent>%s</%scontent>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.content), input_name='content')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(File, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            content_ = child_.text
            content_ = self.gds_validate_string(content_, node, 'content')
            self.content = content_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        super(File, self).buildChildren(child_, node, nodeName_, True)
# end class File


class Files(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, file=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Files, self).__init__(actions, size, total, active,  **kwargs_)
        if file is None:
            self.file = []
        else:
            self.file = file
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Files)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Files.subclass:
            return Files.subclass(*args_, **kwargs_)
        else:
            return Files(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def add_file(self, value):
        self.file.append(value)
    def insert_file_at(self, index, value):
        self.file.insert(index, value)
    def replace_file_at(self, index, value):
        self.file[index] = value
    fileProp = property(get_file, set_file)
    def hasContent_(self):
        if (
            self.file or
            super(Files, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='files', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('files')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='files')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='files', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='files'):
        super(Files, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='files')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='files', fromsubclass_=False, pretty_print=True):
        super(Files, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for file_ in self.file:
            file_.export(outfile, level, namespaceprefix_, name_='file', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Files, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'file':
            obj_ = File.factory(parent_object_=self)
            obj_.build(child_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
        super(Files, self).buildChildren(child_, node, nodeName_, True)
# end class Files


class Image(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, storage_domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Image, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.storage_domain = storage_domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Image)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Image.subclass:
            return Image.subclass(*args_, **kwargs_)
        else:
            return Image(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def hasContent_(self):
        if (
            self.storage_domain is not None or
            super(Image, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='image', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='image')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='image', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='image'):
        super(Image, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='image')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='image', fromsubclass_=False, pretty_print=True):
        super(Image, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Image, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        super(Image, self).buildChildren(child_, node, nodeName_, True)
# end class Image


class Images(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, image=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Images, self).__init__(actions, size, total, active,  **kwargs_)
        if image is None:
            self.image = []
        else:
            self.image = image
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Images)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Images.subclass:
            return Images.subclass(*args_, **kwargs_)
        else:
            return Images(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def add_image(self, value):
        self.image.append(value)
    def insert_image_at(self, index, value):
        self.image.insert(index, value)
    def replace_image_at(self, index, value):
        self.image[index] = value
    imageProp = property(get_image, set_image)
    def hasContent_(self):
        if (
            self.image or
            super(Images, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='images', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('images')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='images')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='images', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='images'):
        super(Images, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='images')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='images', fromsubclass_=False, pretty_print=True):
        super(Images, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for image_ in self.image:
            image_.export(outfile, level, namespaceprefix_, name_='image', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Images, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'image':
            obj_ = Image.factory(parent_object_=self)
            obj_.build(child_)
            self.image.append(obj_)
            obj_.original_tagname_ = 'image'
        super(Images, self).buildChildren(child_, node, nodeName_, True)
# end class Images


class Hook(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, event_name=None, md5=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Hook, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.event_name = event_name
        self.md5 = md5
        self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hook)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hook.subclass:
            return Hook.subclass(*args_, **kwargs_)
        else:
            return Hook(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_event_name(self):
        return self.event_name
    def set_event_name(self, event_name):
        self.event_name = event_name
    event_nameProp = property(get_event_name, set_event_name)
    def get_md5(self):
        return self.md5
    def set_md5(self, md5):
        self.md5 = md5
    md5Prop = property(get_md5, set_md5)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def hasContent_(self):
        if (
            self.event_name is not None or
            self.md5 is not None or
            self.host is not None or
            super(Hook, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='hook', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hook')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hook')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='hook', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hook'):
        super(Hook, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hook')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='hook', fromsubclass_=False, pretty_print=True):
        super(Hook, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.event_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sevent_name>%s</%sevent_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.event_name), input_name='event_name')), namespaceprefix_ , eol_))
        if self.md5 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5>%s</%smd5>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.md5), input_name='md5')), namespaceprefix_ , eol_))
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Hook, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'event_name':
            event_name_ = child_.text
            event_name_ = self.gds_validate_string(event_name_, node, 'event_name')
            self.event_name = event_name_
        elif nodeName_ == 'md5':
            md5_ = child_.text
            md5_ = self.gds_validate_string(md5_, node, 'md5')
            self.md5 = md5_
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        super(Hook, self).buildChildren(child_, node, nodeName_, True)
# end class Hook


class Hooks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, hook=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Hooks, self).__init__(actions, size, total, active,  **kwargs_)
        if hook is None:
            self.hook = []
        else:
            self.hook = hook
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Hooks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Hooks.subclass:
            return Hooks.subclass(*args_, **kwargs_)
        else:
            return Hooks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hook(self):
        return self.hook
    def set_hook(self, hook):
        self.hook = hook
    def add_hook(self, value):
        self.hook.append(value)
    def insert_hook_at(self, index, value):
        self.hook.insert(index, value)
    def replace_hook_at(self, index, value):
        self.hook[index] = value
    hookProp = property(get_hook, set_hook)
    def hasContent_(self):
        if (
            self.hook or
            super(Hooks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='hooks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hooks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hooks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='hooks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hooks'):
        super(Hooks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hooks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='hooks', fromsubclass_=False, pretty_print=True):
        super(Hooks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for hook_ in self.hook:
            hook_.export(outfile, level, namespaceprefix_, name_='hook', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Hooks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hook':
            obj_ = Hook.factory(parent_object_=self)
            obj_.build(child_)
            self.hook.append(obj_)
            obj_.original_tagname_ = 'hook'
        super(Hooks, self).buildChildren(child_, node, nodeName_, True)
# end class Hooks


class IP(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, address=None, netmask=None, gateway=None, version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.address = _cast(None, address)
        self.netmask = _cast(None, netmask)
        self.gateway = _cast(None, gateway)
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IP.subclass:
            return IP.subclass(*args_, **kwargs_)
        else:
            return IP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_netmask(self):
        return self.netmask
    def set_netmask(self, netmask):
        self.netmask = netmask
    netmaskProp = property(get_netmask, set_netmask)
    def get_gateway(self):
        return self.gateway
    def set_gateway(self, gateway):
        self.gateway = gateway
    gatewayProp = property(get_gateway, set_gateway)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ip', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ip')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ip')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ip', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ip'):
        if self.address is not None and 'address' not in already_processed:
            already_processed.add('address')
            outfile.write(' address=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.address), input_name='address')), ))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.netmask), input_name='netmask')), ))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            outfile.write(' gateway=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.gateway), input_name='gateway')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ip', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.add('address')
            self.address = value
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('gateway', node)
        if value is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            self.gateway = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IP


class IPs(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, ip=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(IPs, self).__init__(actions, size, total, active,  **kwargs_)
        if ip is None:
            self.ip = []
        else:
            self.ip = ip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPs.subclass:
            return IPs.subclass(*args_, **kwargs_)
        else:
            return IPs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    def add_ip(self, value):
        self.ip.append(value)
    def insert_ip_at(self, index, value):
        self.ip.insert(index, value)
    def replace_ip_at(self, index, value):
        self.ip[index] = value
    ipProp = property(get_ip, set_ip)
    def hasContent_(self):
        if (
            self.ip or
            super(IPs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ips', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ips')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ips')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ips', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ips'):
        super(IPs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ips')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ips', fromsubclass_=False, pretty_print=True):
        super(IPs, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ip_ in self.ip:
            ip_.export(outfile, level, namespaceprefix_, name_='ip', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip':
            obj_ = IP.factory(parent_object_=self)
            obj_.build(child_)
            self.ip.append(obj_)
            obj_.original_tagname_ = 'ip'
        super(IPs, self).buildChildren(child_, node, nodeName_, True)
# end class IPs


class MAC(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, address=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.address = _cast(None, address)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MAC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MAC.subclass:
            return MAC.subclass(*args_, **kwargs_)
        else:
            return MAC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='mac', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mac')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mac')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='mac', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mac'):
        if self.address is not None and 'address' not in already_processed:
            already_processed.add('address')
            outfile.write(' address=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.address), input_name='address')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='mac', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.add('address')
            self.address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MAC


class VLAN(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(int, id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VLAN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VLAN.subclass:
            return VLAN.subclass(*args_, **kwargs_)
        else:
            return VLAN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    idProp = property(get_id, set_id)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vlan', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vlan')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vlan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vlan', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vlan'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vlan', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VLAN


class Network(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, data_center=None, cluster=None, ip=None, vlan=None, stp=None, status=None, display=None, mtu=None, usages=None, required=None, profile_required=None, labels=None, qos=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Network, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.data_center = data_center
        self.cluster = cluster
        self.ip = ip
        self.vlan = vlan
        self.stp = stp
        self.status = status
        self.display = display
        self.mtu = mtu
        self.usages = usages
        self.required = required
        self.profile_required = profile_required
        self.labels = labels
        self.qos = qos
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Network)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Network.subclass:
            return Network.subclass(*args_, **kwargs_)
        else:
            return Network(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    ipProp = property(get_ip, set_ip)
    def get_vlan(self):
        return self.vlan
    def set_vlan(self, vlan):
        self.vlan = vlan
    vlanProp = property(get_vlan, set_vlan)
    def get_stp(self):
        return self.stp
    def set_stp(self, stp):
        self.stp = stp
    stpProp = property(get_stp, set_stp)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    displayProp = property(get_display, set_display)
    def get_mtu(self):
        return self.mtu
    def set_mtu(self, mtu):
        self.mtu = mtu
    mtuProp = property(get_mtu, set_mtu)
    def get_usages(self):
        return self.usages
    def set_usages(self, usages):
        self.usages = usages
    usagesProp = property(get_usages, set_usages)
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    requiredProp = property(get_required, set_required)
    def get_profile_required(self):
        return self.profile_required
    def set_profile_required(self, profile_required):
        self.profile_required = profile_required
    profile_requiredProp = property(get_profile_required, set_profile_required)
    def get_labels(self):
        return self.labels
    def set_labels(self, labels):
        self.labels = labels
    labelsProp = property(get_labels, set_labels)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    qosProp = property(get_qos, set_qos)
    def hasContent_(self):
        if (
            self.data_center is not None or
            self.cluster is not None or
            self.ip is not None or
            self.vlan is not None or
            self.stp is not None or
            self.status is not None or
            self.display is not None or
            self.mtu is not None or
            self.usages is not None or
            self.required is not None or
            self.profile_required is not None or
            self.labels is not None or
            self.qos is not None or
            super(Network, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='network', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('network')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='network', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='network'):
        super(Network, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='network', fromsubclass_=False, pretty_print=True):
        super(Network, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.ip is not None:
            self.ip.export(outfile, level, namespaceprefix_, name_='ip', pretty_print=pretty_print)
        if self.vlan is not None:
            self.vlan.export(outfile, level, namespaceprefix_, name_='vlan', pretty_print=pretty_print)
        if self.stp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstp>%s</%sstp>%s' % (namespaceprefix_ , self.gds_format_boolean(self.stp, input_name='stp'), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.display is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay>%s</%sdisplay>%s' % (namespaceprefix_ , self.gds_format_boolean(self.display, input_name='display'), namespaceprefix_ , eol_))
        if self.mtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smtu>%s</%smtu>%s' % (namespaceprefix_ , self.gds_format_integer(self.mtu, input_name='mtu'), namespaceprefix_ , eol_))
        if self.usages is not None:
            self.usages.export(outfile, level, namespaceprefix_, name_='usages', pretty_print=pretty_print)
        if self.required is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequired>%s</%srequired>%s' % (namespaceprefix_ , self.gds_format_boolean(self.required, input_name='required'), namespaceprefix_ , eol_))
        if self.profile_required is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprofile_required>%s</%sprofile_required>%s' % (namespaceprefix_ , self.gds_format_boolean(self.profile_required, input_name='profile_required'), namespaceprefix_ , eol_))
        if self.labels is not None:
            self.labels.export(outfile, level, namespaceprefix_, name_='labels', pretty_print=pretty_print)
        if self.qos is not None:
            self.qos.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Network, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'ip':
            obj_ = IP.factory(parent_object_=self)
            obj_.build(child_)
            self.ip = obj_
            obj_.original_tagname_ = 'ip'
        elif nodeName_ == 'vlan':
            obj_ = VLAN.factory(parent_object_=self)
            obj_.build(child_)
            self.vlan = obj_
            obj_.original_tagname_ = 'vlan'
        elif nodeName_ == 'stp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'stp')
            self.stp = ival_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'display':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'display')
            self.display = ival_
        elif nodeName_ == 'mtu' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mtu')
            self.mtu = ival_
        elif nodeName_ == 'usages':
            obj_ = Usages.factory(parent_object_=self)
            obj_.build(child_)
            self.usages = obj_
            obj_.original_tagname_ = 'usages'
        elif nodeName_ == 'required':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'required')
            self.required = ival_
        elif nodeName_ == 'profile_required':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'profile_required')
            self.profile_required = ival_
        elif nodeName_ == 'labels':
            obj_ = Labels.factory(parent_object_=self)
            obj_.build(child_)
            self.labels = obj_
            obj_.original_tagname_ = 'labels'
        elif nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos = obj_
            obj_.original_tagname_ = 'qos'
        super(Network, self).buildChildren(child_, node, nodeName_, True)
# end class Network


class NetworkStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, network_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if network_state is None:
            self.network_state = []
        else:
            self.network_state = network_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetworkStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetworkStates.subclass:
            return NetworkStates.subclass(*args_, **kwargs_)
        else:
            return NetworkStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_state(self):
        return self.network_state
    def set_network_state(self, network_state):
        self.network_state = network_state
    def add_network_state(self, value):
        self.network_state.append(value)
    def insert_network_state_at(self, index, value):
        self.network_state.insert(index, value)
    def replace_network_state_at(self, index, value):
        self.network_state[index] = value
    network_stateProp = property(get_network_state, set_network_state)
    def hasContent_(self):
        if (
            self.network_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='network_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('network_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='network_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='network_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='network_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for network_state_ in self.network_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork_state>%s</%snetwork_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(network_state_), input_name='network_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network_state':
            network_state_ = child_.text
            network_state_ = self.gds_validate_string(network_state_, node, 'network_state')
            self.network_state.append(network_state_)
# end class NetworkStates


class Networks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, network=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Networks, self).__init__(actions, size, total, active,  **kwargs_)
        if network is None:
            self.network = []
        else:
            self.network = network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Networks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Networks.subclass:
            return Networks.subclass(*args_, **kwargs_)
        else:
            return Networks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    def add_network(self, value):
        self.network.append(value)
    def insert_network_at(self, index, value):
        self.network.insert(index, value)
    def replace_network_at(self, index, value):
        self.network[index] = value
    networkProp = property(get_network, set_network)
    def hasContent_(self):
        if (
            self.network or
            super(Networks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='networks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('networks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='networks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='networks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='networks'):
        super(Networks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='networks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='networks', fromsubclass_=False, pretty_print=True):
        super(Networks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for network_ in self.network:
            network_.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Networks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network.append(obj_)
            obj_.original_tagname_ = 'network'
        super(Networks, self).buildChildren(child_, node, nodeName_, True)
# end class Networks


class Label(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, network=None, host_nic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Label, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.network = network
        self.host_nic = host_nic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Label)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Label.subclass:
            return Label.subclass(*args_, **kwargs_)
        else:
            return Label(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    networkProp = property(get_network, set_network)
    def get_host_nic(self):
        return self.host_nic
    def set_host_nic(self, host_nic):
        self.host_nic = host_nic
    host_nicProp = property(get_host_nic, set_host_nic)
    def hasContent_(self):
        if (
            self.network is not None or
            self.host_nic is not None or
            super(Label, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='label', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('label')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='label', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='label'):
        super(Label, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='label')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='label', fromsubclass_=False, pretty_print=True):
        super(Label, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network is not None:
            self.network.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
        if self.host_nic is not None:
            self.host_nic.export(outfile, level, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Label, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network = obj_
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'host_nic':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic = obj_
            obj_.original_tagname_ = 'host_nic'
        super(Label, self).buildChildren(child_, node, nodeName_, True)
# end class Label


class Labels(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, label=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Labels, self).__init__(actions, size, total, active,  **kwargs_)
        if label is None:
            self.label = []
        else:
            self.label = label
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Labels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Labels.subclass:
            return Labels.subclass(*args_, **kwargs_)
        else:
            return Labels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def add_label(self, value):
        self.label.append(value)
    def insert_label_at(self, index, value):
        self.label.insert(index, value)
    def replace_label_at(self, index, value):
        self.label[index] = value
    labelProp = property(get_label, set_label)
    def hasContent_(self):
        if (
            self.label or
            super(Labels, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='labels', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('labels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='labels')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='labels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='labels'):
        super(Labels, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='labels')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='labels', fromsubclass_=False, pretty_print=True):
        super(Labels, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for label_ in self.label:
            label_.export(outfile, level, namespaceprefix_, name_='label', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Labels, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            obj_ = Label.factory(parent_object_=self)
            obj_.build(child_)
            self.label.append(obj_)
            obj_.original_tagname_ = 'label'
        super(Labels, self).buildChildren(child_, node, nodeName_, True)
# end class Labels


class VnicProfile(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, network=None, port_mirroring=None, custom_properties=None, pass_through=None, qos=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VnicProfile, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.network = network
        self.port_mirroring = port_mirroring
        self.custom_properties = custom_properties
        self.pass_through = pass_through
        self.qos = qos
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VnicProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VnicProfile.subclass:
            return VnicProfile.subclass(*args_, **kwargs_)
        else:
            return VnicProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    networkProp = property(get_network, set_network)
    def get_port_mirroring(self):
        return self.port_mirroring
    def set_port_mirroring(self, port_mirroring):
        self.port_mirroring = port_mirroring
    port_mirroringProp = property(get_port_mirroring, set_port_mirroring)
    def get_custom_properties(self):
        return self.custom_properties
    def set_custom_properties(self, custom_properties):
        self.custom_properties = custom_properties
    custom_propertiesProp = property(get_custom_properties, set_custom_properties)
    def get_pass_through(self):
        return self.pass_through
    def set_pass_through(self, pass_through):
        self.pass_through = pass_through
    pass_throughProp = property(get_pass_through, set_pass_through)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    qosProp = property(get_qos, set_qos)
    def hasContent_(self):
        if (
            self.network is not None or
            self.port_mirroring is not None or
            self.custom_properties is not None or
            self.pass_through is not None or
            self.qos is not None or
            super(VnicProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vnic_profile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vnic_profile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vnic_profile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vnic_profile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vnic_profile'):
        super(VnicProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vnic_profile')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vnic_profile', fromsubclass_=False, pretty_print=True):
        super(VnicProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network is not None:
            self.network.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
        if self.port_mirroring is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport_mirroring>%s</%sport_mirroring>%s' % (namespaceprefix_ , self.gds_format_boolean(self.port_mirroring, input_name='port_mirroring'), namespaceprefix_ , eol_))
        if self.custom_properties is not None:
            self.custom_properties.export(outfile, level, namespaceprefix_, name_='custom_properties', pretty_print=pretty_print)
        if self.pass_through is not None:
            self.pass_through.export(outfile, level, namespaceprefix_, name_='pass_through', pretty_print=pretty_print)
        if self.qos is not None:
            self.qos.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VnicProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network = obj_
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'port_mirroring':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'port_mirroring')
            self.port_mirroring = ival_
        elif nodeName_ == 'custom_properties':
            obj_ = CustomProperties.factory(parent_object_=self)
            obj_.build(child_)
            self.custom_properties = obj_
            obj_.original_tagname_ = 'custom_properties'
        elif nodeName_ == 'pass_through':
            obj_ = VnicPassThrough.factory(parent_object_=self)
            obj_.build(child_)
            self.pass_through = obj_
            obj_.original_tagname_ = 'pass_through'
        elif nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos = obj_
            obj_.original_tagname_ = 'qos'
        super(VnicProfile, self).buildChildren(child_, node, nodeName_, True)
# end class VnicProfile


class VnicProfiles(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, vnic_profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VnicProfiles, self).__init__(actions, size, total, active,  **kwargs_)
        if vnic_profile is None:
            self.vnic_profile = []
        else:
            self.vnic_profile = vnic_profile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VnicProfiles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VnicProfiles.subclass:
            return VnicProfiles.subclass(*args_, **kwargs_)
        else:
            return VnicProfiles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vnic_profile(self):
        return self.vnic_profile
    def set_vnic_profile(self, vnic_profile):
        self.vnic_profile = vnic_profile
    def add_vnic_profile(self, value):
        self.vnic_profile.append(value)
    def insert_vnic_profile_at(self, index, value):
        self.vnic_profile.insert(index, value)
    def replace_vnic_profile_at(self, index, value):
        self.vnic_profile[index] = value
    vnic_profileProp = property(get_vnic_profile, set_vnic_profile)
    def hasContent_(self):
        if (
            self.vnic_profile or
            super(VnicProfiles, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vnic_profiles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vnic_profiles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vnic_profiles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vnic_profiles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vnic_profiles'):
        super(VnicProfiles, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vnic_profiles')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vnic_profiles', fromsubclass_=False, pretty_print=True):
        super(VnicProfiles, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vnic_profile_ in self.vnic_profile:
            vnic_profile_.export(outfile, level, namespaceprefix_, name_='vnic_profile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VnicProfiles, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vnic_profile':
            obj_ = VnicProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.vnic_profile.append(obj_)
            obj_.original_tagname_ = 'vnic_profile'
        super(VnicProfiles, self).buildChildren(child_, node, nodeName_, True)
# end class VnicProfiles


class VnicPassThrough(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.mode = mode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VnicPassThrough)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VnicPassThrough.subclass:
            return VnicPassThrough.subclass(*args_, **kwargs_)
        else:
            return VnicPassThrough(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mode(self):
        return self.mode
    def set_mode(self, mode):
        self.mode = mode
    modeProp = property(get_mode, set_mode)
    def hasContent_(self):
        if (
            self.mode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vnic_pass_through', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vnic_pass_through')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vnic_pass_through')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vnic_pass_through', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vnic_pass_through'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vnic_pass_through', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smode>%s</%smode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mode), input_name='mode')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mode':
            mode_ = child_.text
            mode_ = self.gds_validate_string(mode_, node, 'mode')
            self.mode = mode_
# end class VnicPassThrough


class StorageConnectionExtensions(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, storage_connection_extension=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StorageConnectionExtensions, self).__init__(actions, size, total, active,  **kwargs_)
        if storage_connection_extension is None:
            self.storage_connection_extension = []
        else:
            self.storage_connection_extension = storage_connection_extension
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageConnectionExtensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageConnectionExtensions.subclass:
            return StorageConnectionExtensions.subclass(*args_, **kwargs_)
        else:
            return StorageConnectionExtensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_connection_extension(self):
        return self.storage_connection_extension
    def set_storage_connection_extension(self, storage_connection_extension):
        self.storage_connection_extension = storage_connection_extension
    def add_storage_connection_extension(self, value):
        self.storage_connection_extension.append(value)
    def insert_storage_connection_extension_at(self, index, value):
        self.storage_connection_extension.insert(index, value)
    def replace_storage_connection_extension_at(self, index, value):
        self.storage_connection_extension[index] = value
    storage_connection_extensionProp = property(get_storage_connection_extension, set_storage_connection_extension)
    def hasContent_(self):
        if (
            self.storage_connection_extension or
            super(StorageConnectionExtensions, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_connection_extensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_connection_extensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connection_extensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_connection_extensions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_connection_extensions'):
        super(StorageConnectionExtensions, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connection_extensions')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_connection_extensions', fromsubclass_=False, pretty_print=True):
        super(StorageConnectionExtensions, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_connection_extension_ in self.storage_connection_extension:
            storage_connection_extension_.export(outfile, level, namespaceprefix_, name_='storage_connection_extension', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageConnectionExtensions, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_connection_extension':
            obj_ = StorageConnectionExtension.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_connection_extension.append(obj_)
            obj_.original_tagname_ = 'storage_connection_extension'
        super(StorageConnectionExtensions, self).buildChildren(child_, node, nodeName_, True)
# end class StorageConnectionExtensions


class StorageConnectionExtension(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, target=None, username=None, password=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StorageConnectionExtension, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.target = target
        self.username = username
        self.password = password
        self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageConnectionExtension)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageConnectionExtension.subclass:
            return StorageConnectionExtension.subclass(*args_, **kwargs_)
        else:
            return StorageConnectionExtension(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    targetProp = property(get_target, set_target)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def hasContent_(self):
        if (
            self.target is not None or
            self.username is not None or
            self.password is not None or
            self.host is not None or
            super(StorageConnectionExtension, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_connection_extension', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_connection_extension')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connection_extension')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_connection_extension', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_connection_extension'):
        super(StorageConnectionExtension, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connection_extension')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_connection_extension', fromsubclass_=False, pretty_print=True):
        super(StorageConnectionExtension, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.target), input_name='target')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageConnectionExtension, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        super(StorageConnectionExtension, self).buildChildren(child_, node, nodeName_, True)
# end class StorageConnectionExtension


class LogicalUnit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, port=None, target=None, username=None, password=None, portal=None, address=None, serial=None, vendor_id=None, product_id=None, lun_mapping=None, size=None, paths=None, status=None, volume_group_id=None, storage_domain_id=None, disk_id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.port = port
        self.target = target
        self.username = username
        self.password = password
        self.portal = portal
        self.address = address
        self.serial = serial
        self.vendor_id = vendor_id
        self.product_id = product_id
        self.lun_mapping = lun_mapping
        self.size = size
        self.paths = paths
        self.status = status
        self.volume_group_id = volume_group_id
        self.storage_domain_id = storage_domain_id
        self.disk_id = disk_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalUnit.subclass:
            return LogicalUnit.subclass(*args_, **kwargs_)
        else:
            return LogicalUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    targetProp = property(get_target, set_target)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_portal(self):
        return self.portal
    def set_portal(self, portal):
        self.portal = portal
    portalProp = property(get_portal, set_portal)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_serial(self):
        return self.serial
    def set_serial(self, serial):
        self.serial = serial
    serialProp = property(get_serial, set_serial)
    def get_vendor_id(self):
        return self.vendor_id
    def set_vendor_id(self, vendor_id):
        self.vendor_id = vendor_id
    vendor_idProp = property(get_vendor_id, set_vendor_id)
    def get_product_id(self):
        return self.product_id
    def set_product_id(self, product_id):
        self.product_id = product_id
    product_idProp = property(get_product_id, set_product_id)
    def get_lun_mapping(self):
        return self.lun_mapping
    def set_lun_mapping(self, lun_mapping):
        self.lun_mapping = lun_mapping
    lun_mappingProp = property(get_lun_mapping, set_lun_mapping)
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    sizeProp = property(get_size, set_size)
    def get_paths(self):
        return self.paths
    def set_paths(self, paths):
        self.paths = paths
    pathsProp = property(get_paths, set_paths)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_volume_group_id(self):
        return self.volume_group_id
    def set_volume_group_id(self, volume_group_id):
        self.volume_group_id = volume_group_id
    volume_group_idProp = property(get_volume_group_id, set_volume_group_id)
    def get_storage_domain_id(self):
        return self.storage_domain_id
    def set_storage_domain_id(self, storage_domain_id):
        self.storage_domain_id = storage_domain_id
    storage_domain_idProp = property(get_storage_domain_id, set_storage_domain_id)
    def get_disk_id(self):
        return self.disk_id
    def set_disk_id(self, disk_id):
        self.disk_id = disk_id
    disk_idProp = property(get_disk_id, set_disk_id)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    idProp = property(get_id, set_id)
    def hasContent_(self):
        if (
            self.port is not None or
            self.target is not None or
            self.username is not None or
            self.password is not None or
            self.portal is not None or
            self.address is not None or
            self.serial is not None or
            self.vendor_id is not None or
            self.product_id is not None or
            self.lun_mapping is not None or
            self.size is not None or
            self.paths is not None or
            self.status is not None or
            self.volume_group_id is not None or
            self.storage_domain_id is not None or
            self.disk_id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='logical_unit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('logical_unit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='logical_unit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='logical_unit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='logical_unit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='logical_unit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.target), input_name='target')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.portal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sportal>%s</%sportal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.portal), input_name='portal')), namespaceprefix_ , eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.serial is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserial>%s</%sserial>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serial), input_name='serial')), namespaceprefix_ , eol_))
        if self.vendor_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor_id>%s</%svendor_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor_id), input_name='vendor_id')), namespaceprefix_ , eol_))
        if self.product_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduct_id>%s</%sproduct_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.product_id), input_name='product_id')), namespaceprefix_ , eol_))
        if self.lun_mapping is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slun_mapping>%s</%slun_mapping>%s' % (namespaceprefix_ , self.gds_format_integer(self.lun_mapping, input_name='lun_mapping'), namespaceprefix_ , eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_format_integer(self.size, input_name='size'), namespaceprefix_ , eol_))
        if self.paths is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spaths>%s</%spaths>%s' % (namespaceprefix_ , self.gds_format_integer(self.paths, input_name='paths'), namespaceprefix_ , eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.status), input_name='status')), namespaceprefix_ , eol_))
        if self.volume_group_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume_group_id>%s</%svolume_group_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume_group_id), input_name='volume_group_id')), namespaceprefix_ , eol_))
        if self.storage_domain_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_domain_id>%s</%sstorage_domain_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.storage_domain_id), input_name='storage_domain_id')), namespaceprefix_ , eol_))
        if self.disk_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisk_id>%s</%sdisk_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disk_id), input_name='disk_id')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'portal':
            portal_ = child_.text
            portal_ = self.gds_validate_string(portal_, node, 'portal')
            self.portal = portal_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'serial':
            serial_ = child_.text
            serial_ = self.gds_validate_string(serial_, node, 'serial')
            self.serial = serial_
        elif nodeName_ == 'vendor_id':
            vendor_id_ = child_.text
            vendor_id_ = self.gds_validate_string(vendor_id_, node, 'vendor_id')
            self.vendor_id = vendor_id_
        elif nodeName_ == 'product_id':
            product_id_ = child_.text
            product_id_ = self.gds_validate_string(product_id_, node, 'product_id')
            self.product_id = product_id_
        elif nodeName_ == 'lun_mapping' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lun_mapping')
            self.lun_mapping = ival_
        elif nodeName_ == 'size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'paths' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'paths')
            self.paths = ival_
        elif nodeName_ == 'status':
            status_ = child_.text
            status_ = self.gds_validate_string(status_, node, 'status')
            self.status = status_
        elif nodeName_ == 'volume_group_id':
            volume_group_id_ = child_.text
            volume_group_id_ = self.gds_validate_string(volume_group_id_, node, 'volume_group_id')
            self.volume_group_id = volume_group_id_
        elif nodeName_ == 'storage_domain_id':
            storage_domain_id_ = child_.text
            storage_domain_id_ = self.gds_validate_string(storage_domain_id_, node, 'storage_domain_id')
            self.storage_domain_id = storage_domain_id_
        elif nodeName_ == 'disk_id':
            disk_id_ = child_.text
            disk_id_ = self.gds_validate_string(disk_id_, node, 'disk_id')
            self.disk_id = disk_id_
# end class LogicalUnit


class LogicalUnits(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, logical_unit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(LogicalUnits, self).__init__(actions, size, total, active,  **kwargs_)
        if logical_unit is None:
            self.logical_unit = []
        else:
            self.logical_unit = logical_unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalUnits.subclass:
            return LogicalUnits.subclass(*args_, **kwargs_)
        else:
            return LogicalUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logical_unit(self):
        return self.logical_unit
    def set_logical_unit(self, logical_unit):
        self.logical_unit = logical_unit
    def add_logical_unit(self, value):
        self.logical_unit.append(value)
    def insert_logical_unit_at(self, index, value):
        self.logical_unit.insert(index, value)
    def replace_logical_unit_at(self, index, value):
        self.logical_unit[index] = value
    logical_unitProp = property(get_logical_unit, set_logical_unit)
    def hasContent_(self):
        if (
            self.logical_unit or
            super(LogicalUnits, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='logical_units', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('logical_units')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='logical_units')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='logical_units', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='logical_units'):
        super(LogicalUnits, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='logical_units')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='logical_units', fromsubclass_=False, pretty_print=True):
        super(LogicalUnits, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for logical_unit_ in self.logical_unit:
            logical_unit_.export(outfile, level, namespaceprefix_, name_='logical_unit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LogicalUnits, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'logical_unit':
            obj_ = LogicalUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.logical_unit.append(obj_)
            obj_.original_tagname_ = 'logical_unit'
        super(LogicalUnits, self).buildChildren(child_, node, nodeName_, True)
# end class LogicalUnits


class VolumeGroup(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, logical_unit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = name
        if logical_unit is None:
            self.logical_unit = []
        else:
            self.logical_unit = logical_unit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VolumeGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VolumeGroup.subclass:
            return VolumeGroup.subclass(*args_, **kwargs_)
        else:
            return VolumeGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_logical_unit(self):
        return self.logical_unit
    def set_logical_unit(self, logical_unit):
        self.logical_unit = logical_unit
    def add_logical_unit(self, value):
        self.logical_unit.append(value)
    def insert_logical_unit_at(self, index, value):
        self.logical_unit.insert(index, value)
    def replace_logical_unit_at(self, index, value):
        self.logical_unit[index] = value
    logical_unitProp = property(get_logical_unit, set_logical_unit)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    idProp = property(get_id, set_id)
    def hasContent_(self):
        if (
            self.name is not None or
            self.logical_unit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='volume_group', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('volume_group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='volume_group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='volume_group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='volume_group'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='volume_group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        for logical_unit_ in self.logical_unit:
            logical_unit_.export(outfile, level, namespaceprefix_, name_='logical_unit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'logical_unit':
            obj_ = LogicalUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.logical_unit.append(obj_)
            obj_.original_tagname_ = 'logical_unit'
# end class VolumeGroup


class Storage(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, address=None, type_=None, path=None, mount_options=None, vfs_type=None, nfs_version=None, nfs_timeo=None, nfs_retrans=None, logical_unit=None, volume_group=None, override_luns=None, port=None, target=None, username=None, password=None, portal=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Storage, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.address = address
        self.type_ = type_
        self.path = path
        self.mount_options = mount_options
        self.vfs_type = vfs_type
        self.nfs_version = nfs_version
        self.nfs_timeo = nfs_timeo
        self.nfs_retrans = nfs_retrans
        if logical_unit is None:
            self.logical_unit = []
        else:
            self.logical_unit = logical_unit
        self.volume_group = volume_group
        self.override_luns = override_luns
        self.port = port
        self.target = target
        self.username = username
        self.password = password
        self.portal = portal
        self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Storage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Storage.subclass:
            return Storage.subclass(*args_, **kwargs_)
        else:
            return Storage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_path(self):
        return self.path
    def set_path(self, path):
        self.path = path
    pathProp = property(get_path, set_path)
    def get_mount_options(self):
        return self.mount_options
    def set_mount_options(self, mount_options):
        self.mount_options = mount_options
    mount_optionsProp = property(get_mount_options, set_mount_options)
    def get_vfs_type(self):
        return self.vfs_type
    def set_vfs_type(self, vfs_type):
        self.vfs_type = vfs_type
    vfs_typeProp = property(get_vfs_type, set_vfs_type)
    def get_nfs_version(self):
        return self.nfs_version
    def set_nfs_version(self, nfs_version):
        self.nfs_version = nfs_version
    nfs_versionProp = property(get_nfs_version, set_nfs_version)
    def get_nfs_timeo(self):
        return self.nfs_timeo
    def set_nfs_timeo(self, nfs_timeo):
        self.nfs_timeo = nfs_timeo
    nfs_timeoProp = property(get_nfs_timeo, set_nfs_timeo)
    def get_nfs_retrans(self):
        return self.nfs_retrans
    def set_nfs_retrans(self, nfs_retrans):
        self.nfs_retrans = nfs_retrans
    nfs_retransProp = property(get_nfs_retrans, set_nfs_retrans)
    def get_logical_unit(self):
        return self.logical_unit
    def set_logical_unit(self, logical_unit):
        self.logical_unit = logical_unit
    def add_logical_unit(self, value):
        self.logical_unit.append(value)
    def insert_logical_unit_at(self, index, value):
        self.logical_unit.insert(index, value)
    def replace_logical_unit_at(self, index, value):
        self.logical_unit[index] = value
    logical_unitProp = property(get_logical_unit, set_logical_unit)
    def get_volume_group(self):
        return self.volume_group
    def set_volume_group(self, volume_group):
        self.volume_group = volume_group
    volume_groupProp = property(get_volume_group, set_volume_group)
    def get_override_luns(self):
        return self.override_luns
    def set_override_luns(self, override_luns):
        self.override_luns = override_luns
    override_lunsProp = property(get_override_luns, set_override_luns)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    targetProp = property(get_target, set_target)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_portal(self):
        return self.portal
    def set_portal(self, portal):
        self.portal = portal
    portalProp = property(get_portal, set_portal)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def hasContent_(self):
        if (
            self.address is not None or
            self.type_ is not None or
            self.path is not None or
            self.mount_options is not None or
            self.vfs_type is not None or
            self.nfs_version is not None or
            self.nfs_timeo is not None or
            self.nfs_retrans is not None or
            self.logical_unit or
            self.volume_group is not None or
            self.override_luns is not None or
            self.port is not None or
            self.target is not None or
            self.username is not None or
            self.password is not None or
            self.portal is not None or
            self.host is not None or
            super(Storage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage'):
        super(Storage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage', fromsubclass_=False, pretty_print=True):
        super(Storage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spath>%s</%spath>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.path), input_name='path')), namespaceprefix_ , eol_))
        if self.mount_options is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smount_options>%s</%smount_options>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mount_options), input_name='mount_options')), namespaceprefix_ , eol_))
        if self.vfs_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svfs_type>%s</%svfs_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vfs_type), input_name='vfs_type')), namespaceprefix_ , eol_))
        if self.nfs_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_version>%s</%snfs_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nfs_version), input_name='nfs_version')), namespaceprefix_ , eol_))
        if self.nfs_timeo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_timeo>%s</%snfs_timeo>%s' % (namespaceprefix_ , self.gds_format_integer(self.nfs_timeo, input_name='nfs_timeo'), namespaceprefix_ , eol_))
        if self.nfs_retrans is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_retrans>%s</%snfs_retrans>%s' % (namespaceprefix_ , self.gds_format_integer(self.nfs_retrans, input_name='nfs_retrans'), namespaceprefix_ , eol_))
        for logical_unit_ in self.logical_unit:
            logical_unit_.export(outfile, level, namespaceprefix_, name_='logical_unit', pretty_print=pretty_print)
        if self.volume_group is not None:
            self.volume_group.export(outfile, level, namespaceprefix_, name_='volume_group', pretty_print=pretty_print)
        if self.override_luns is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverride_luns>%s</%soverride_luns>%s' % (namespaceprefix_ , self.gds_format_boolean(self.override_luns, input_name='override_luns'), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.target), input_name='target')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.portal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sportal>%s</%sportal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.portal), input_name='portal')), namespaceprefix_ , eol_))
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Storage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'path':
            path_ = child_.text
            path_ = self.gds_validate_string(path_, node, 'path')
            self.path = path_
        elif nodeName_ == 'mount_options':
            mount_options_ = child_.text
            mount_options_ = self.gds_validate_string(mount_options_, node, 'mount_options')
            self.mount_options = mount_options_
        elif nodeName_ == 'vfs_type':
            vfs_type_ = child_.text
            vfs_type_ = self.gds_validate_string(vfs_type_, node, 'vfs_type')
            self.vfs_type = vfs_type_
        elif nodeName_ == 'nfs_version':
            nfs_version_ = child_.text
            nfs_version_ = self.gds_validate_string(nfs_version_, node, 'nfs_version')
            self.nfs_version = nfs_version_
        elif nodeName_ == 'nfs_timeo' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nfs_timeo')
            self.nfs_timeo = ival_
        elif nodeName_ == 'nfs_retrans' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nfs_retrans')
            self.nfs_retrans = ival_
        elif nodeName_ == 'logical_unit':
            obj_ = LogicalUnit.factory(parent_object_=self)
            obj_.build(child_)
            self.logical_unit.append(obj_)
            obj_.original_tagname_ = 'logical_unit'
        elif nodeName_ == 'volume_group':
            obj_ = VolumeGroup.factory(parent_object_=self)
            obj_.build(child_)
            self.volume_group = obj_
            obj_.original_tagname_ = 'volume_group'
        elif nodeName_ == 'override_luns':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'override_luns')
            self.override_luns = ival_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'portal':
            portal_ = child_.text
            portal_ = self.gds_validate_string(portal_, node, 'portal')
            self.portal = portal_
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        super(Storage, self).buildChildren(child_, node, nodeName_, True)
# end class Storage


class StorageConnection(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, address=None, type_=None, path=None, mount_options=None, vfs_type=None, nfs_version=None, nfs_timeo=None, nfs_retrans=None, port=None, target=None, username=None, password=None, portal=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StorageConnection, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.address = address
        self.type_ = type_
        self.path = path
        self.mount_options = mount_options
        self.vfs_type = vfs_type
        self.nfs_version = nfs_version
        self.nfs_timeo = nfs_timeo
        self.nfs_retrans = nfs_retrans
        self.port = port
        self.target = target
        self.username = username
        self.password = password
        self.portal = portal
        self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageConnection.subclass:
            return StorageConnection.subclass(*args_, **kwargs_)
        else:
            return StorageConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_path(self):
        return self.path
    def set_path(self, path):
        self.path = path
    pathProp = property(get_path, set_path)
    def get_mount_options(self):
        return self.mount_options
    def set_mount_options(self, mount_options):
        self.mount_options = mount_options
    mount_optionsProp = property(get_mount_options, set_mount_options)
    def get_vfs_type(self):
        return self.vfs_type
    def set_vfs_type(self, vfs_type):
        self.vfs_type = vfs_type
    vfs_typeProp = property(get_vfs_type, set_vfs_type)
    def get_nfs_version(self):
        return self.nfs_version
    def set_nfs_version(self, nfs_version):
        self.nfs_version = nfs_version
    nfs_versionProp = property(get_nfs_version, set_nfs_version)
    def get_nfs_timeo(self):
        return self.nfs_timeo
    def set_nfs_timeo(self, nfs_timeo):
        self.nfs_timeo = nfs_timeo
    nfs_timeoProp = property(get_nfs_timeo, set_nfs_timeo)
    def get_nfs_retrans(self):
        return self.nfs_retrans
    def set_nfs_retrans(self, nfs_retrans):
        self.nfs_retrans = nfs_retrans
    nfs_retransProp = property(get_nfs_retrans, set_nfs_retrans)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    targetProp = property(get_target, set_target)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_portal(self):
        return self.portal
    def set_portal(self, portal):
        self.portal = portal
    portalProp = property(get_portal, set_portal)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def hasContent_(self):
        if (
            self.address is not None or
            self.type_ is not None or
            self.path is not None or
            self.mount_options is not None or
            self.vfs_type is not None or
            self.nfs_version is not None or
            self.nfs_timeo is not None or
            self.nfs_retrans is not None or
            self.port is not None or
            self.target is not None or
            self.username is not None or
            self.password is not None or
            self.portal is not None or
            self.host is not None or
            super(StorageConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_connection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_connection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_connection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_connection'):
        super(StorageConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connection')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_connection', fromsubclass_=False, pretty_print=True):
        super(StorageConnection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.path is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spath>%s</%spath>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.path), input_name='path')), namespaceprefix_ , eol_))
        if self.mount_options is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smount_options>%s</%smount_options>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mount_options), input_name='mount_options')), namespaceprefix_ , eol_))
        if self.vfs_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svfs_type>%s</%svfs_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vfs_type), input_name='vfs_type')), namespaceprefix_ , eol_))
        if self.nfs_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_version>%s</%snfs_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nfs_version), input_name='nfs_version')), namespaceprefix_ , eol_))
        if self.nfs_timeo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_timeo>%s</%snfs_timeo>%s' % (namespaceprefix_ , self.gds_format_integer(self.nfs_timeo, input_name='nfs_timeo'), namespaceprefix_ , eol_))
        if self.nfs_retrans is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_retrans>%s</%snfs_retrans>%s' % (namespaceprefix_ , self.gds_format_integer(self.nfs_retrans, input_name='nfs_retrans'), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.target), input_name='target')), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.portal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sportal>%s</%sportal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.portal), input_name='portal')), namespaceprefix_ , eol_))
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'path':
            path_ = child_.text
            path_ = self.gds_validate_string(path_, node, 'path')
            self.path = path_
        elif nodeName_ == 'mount_options':
            mount_options_ = child_.text
            mount_options_ = self.gds_validate_string(mount_options_, node, 'mount_options')
            self.mount_options = mount_options_
        elif nodeName_ == 'vfs_type':
            vfs_type_ = child_.text
            vfs_type_ = self.gds_validate_string(vfs_type_, node, 'vfs_type')
            self.vfs_type = vfs_type_
        elif nodeName_ == 'nfs_version':
            nfs_version_ = child_.text
            nfs_version_ = self.gds_validate_string(nfs_version_, node, 'nfs_version')
            self.nfs_version = nfs_version_
        elif nodeName_ == 'nfs_timeo' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nfs_timeo')
            self.nfs_timeo = ival_
        elif nodeName_ == 'nfs_retrans' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nfs_retrans')
            self.nfs_retrans = ival_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'portal':
            portal_ = child_.text
            portal_ = self.gds_validate_string(portal_, node, 'portal')
            self.portal = portal_
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        super(StorageConnection, self).buildChildren(child_, node, nodeName_, True)
# end class StorageConnection


class StorageDomain(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, data_center=None, data_centers=None, type_=None, status=None, external_status=None, master=None, storage=None, host=None, format=None, destroy=None, available=None, used=None, committed=None, storage_format=None, wipe_after_delete=None, import_=None, warning_low_space_indicator=None, critical_space_action_blocker=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StorageDomain, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.data_center = data_center
        self.data_centers = data_centers
        self.type_ = type_
        self.status = status
        self.external_status = external_status
        self.master = master
        self.storage = storage
        self.host = host
        self.format = format
        self.destroy = destroy
        self.available = available
        self.used = used
        self.committed = committed
        self.storage_format = storage_format
        self.wipe_after_delete = wipe_after_delete
        self.import_ = import_
        self.warning_low_space_indicator = warning_low_space_indicator
        self.critical_space_action_blocker = critical_space_action_blocker
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageDomain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageDomain.subclass:
            return StorageDomain.subclass(*args_, **kwargs_)
        else:
            return StorageDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_data_centers(self):
        return self.data_centers
    def set_data_centers(self, data_centers):
        self.data_centers = data_centers
    data_centersProp = property(get_data_centers, set_data_centers)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_external_status(self):
        return self.external_status
    def set_external_status(self, external_status):
        self.external_status = external_status
    external_statusProp = property(get_external_status, set_external_status)
    def get_master(self):
        return self.master
    def set_master(self, master):
        self.master = master
    masterProp = property(get_master, set_master)
    def get_storage(self):
        return self.storage
    def set_storage(self, storage):
        self.storage = storage
    storageProp = property(get_storage, set_storage)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_format(self):
        return self.format
    def set_format(self, format):
        self.format = format
    formatProp = property(get_format, set_format)
    def get_destroy(self):
        return self.destroy
    def set_destroy(self, destroy):
        self.destroy = destroy
    destroyProp = property(get_destroy, set_destroy)
    def get_available(self):
        return self.available
    def set_available(self, available):
        self.available = available
    availableProp = property(get_available, set_available)
    def get_used(self):
        return self.used
    def set_used(self, used):
        self.used = used
    usedProp = property(get_used, set_used)
    def get_committed(self):
        return self.committed
    def set_committed(self, committed):
        self.committed = committed
    committedProp = property(get_committed, set_committed)
    def get_storage_format(self):
        return self.storage_format
    def set_storage_format(self, storage_format):
        self.storage_format = storage_format
    storage_formatProp = property(get_storage_format, set_storage_format)
    def get_wipe_after_delete(self):
        return self.wipe_after_delete
    def set_wipe_after_delete(self, wipe_after_delete):
        self.wipe_after_delete = wipe_after_delete
    wipe_after_deleteProp = property(get_wipe_after_delete, set_wipe_after_delete)
    def get_import(self):
        return self.import_
    def set_import(self, import_):
        self.import_ = import_
    importProp = property(get_import, set_import)
    def get_warning_low_space_indicator(self):
        return self.warning_low_space_indicator
    def set_warning_low_space_indicator(self, warning_low_space_indicator):
        self.warning_low_space_indicator = warning_low_space_indicator
    warning_low_space_indicatorProp = property(get_warning_low_space_indicator, set_warning_low_space_indicator)
    def get_critical_space_action_blocker(self):
        return self.critical_space_action_blocker
    def set_critical_space_action_blocker(self, critical_space_action_blocker):
        self.critical_space_action_blocker = critical_space_action_blocker
    critical_space_action_blockerProp = property(get_critical_space_action_blocker, set_critical_space_action_blocker)
    def hasContent_(self):
        if (
            self.data_center is not None or
            self.data_centers is not None or
            self.type_ is not None or
            self.status is not None or
            self.external_status is not None or
            self.master is not None or
            self.storage is not None or
            self.host is not None or
            self.format is not None or
            self.destroy is not None or
            self.available is not None or
            self.used is not None or
            self.committed is not None or
            self.storage_format is not None or
            self.wipe_after_delete is not None or
            self.import_ is not None or
            self.warning_low_space_indicator is not None or
            self.critical_space_action_blocker is not None or
            super(StorageDomain, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_domain', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_domain')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_domain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_domain'):
        super(StorageDomain, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_domain')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_domain', fromsubclass_=False, pretty_print=True):
        super(StorageDomain, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.data_centers is not None:
            self.data_centers.export(outfile, level, namespaceprefix_, name_='data_centers', pretty_print=pretty_print)
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.external_status is not None:
            self.external_status.export(outfile, level, namespaceprefix_, name_='external_status', pretty_print=pretty_print)
        if self.master is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaster>%s</%smaster>%s' % (namespaceprefix_ , self.gds_format_boolean(self.master, input_name='master'), namespaceprefix_ , eol_))
        if self.storage is not None:
            self.storage.export(outfile, level, namespaceprefix_, name_='storage', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformat>%s</%sformat>%s' % (namespaceprefix_ , self.gds_format_boolean(self.format, input_name='format'), namespaceprefix_ , eol_))
        if self.destroy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestroy>%s</%sdestroy>%s' % (namespaceprefix_ , self.gds_format_boolean(self.destroy, input_name='destroy'), namespaceprefix_ , eol_))
        if self.available is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailable>%s</%savailable>%s' % (namespaceprefix_ , self.gds_format_integer(self.available, input_name='available'), namespaceprefix_ , eol_))
        if self.used is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sused>%s</%sused>%s' % (namespaceprefix_ , self.gds_format_integer(self.used, input_name='used'), namespaceprefix_ , eol_))
        if self.committed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scommitted>%s</%scommitted>%s' % (namespaceprefix_ , self.gds_format_integer(self.committed, input_name='committed'), namespaceprefix_ , eol_))
        if self.storage_format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_format>%s</%sstorage_format>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.storage_format), input_name='storage_format')), namespaceprefix_ , eol_))
        if self.wipe_after_delete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swipe_after_delete>%s</%swipe_after_delete>%s' % (namespaceprefix_ , self.gds_format_boolean(self.wipe_after_delete, input_name='wipe_after_delete'), namespaceprefix_ , eol_))
        if self.import_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simport>%s</%simport>%s' % (namespaceprefix_ , self.gds_format_boolean(self.import_, input_name='import'), namespaceprefix_ , eol_))
        if self.warning_low_space_indicator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swarning_low_space_indicator>%s</%swarning_low_space_indicator>%s' % (namespaceprefix_ , self.gds_format_integer(self.warning_low_space_indicator, input_name='warning_low_space_indicator'), namespaceprefix_ , eol_))
        if self.critical_space_action_blocker is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scritical_space_action_blocker>%s</%scritical_space_action_blocker>%s' % (namespaceprefix_ , self.gds_format_integer(self.critical_space_action_blocker, input_name='critical_space_action_blocker'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageDomain, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'data_centers':
            obj_ = DataCenters.factory(parent_object_=self)
            obj_.build(child_)
            self.data_centers = obj_
            obj_.original_tagname_ = 'data_centers'
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'external_status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.external_status = obj_
            obj_.original_tagname_ = 'external_status'
        elif nodeName_ == 'master':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'master')
            self.master = ival_
        elif nodeName_ == 'storage':
            obj_ = Storage.factory(parent_object_=self)
            obj_.build(child_)
            self.storage = obj_
            obj_.original_tagname_ = 'storage'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'format':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'format')
            self.format = ival_
        elif nodeName_ == 'destroy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'destroy')
            self.destroy = ival_
        elif nodeName_ == 'available' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'available')
            self.available = ival_
        elif nodeName_ == 'used' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'used')
            self.used = ival_
        elif nodeName_ == 'committed' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'committed')
            self.committed = ival_
        elif nodeName_ == 'storage_format':
            storage_format_ = child_.text
            storage_format_ = self.gds_validate_string(storage_format_, node, 'storage_format')
            self.storage_format = storage_format_
        elif nodeName_ == 'wipe_after_delete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'wipe_after_delete')
            self.wipe_after_delete = ival_
        elif nodeName_ == 'import':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'import')
            self.import_ = ival_
        elif nodeName_ == 'warning_low_space_indicator' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'warning_low_space_indicator')
            self.warning_low_space_indicator = ival_
        elif nodeName_ == 'critical_space_action_blocker' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'critical_space_action_blocker')
            self.critical_space_action_blocker = ival_
        super(StorageDomain, self).buildChildren(child_, node, nodeName_, True)
# end class StorageDomain


class StorageDomainStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, storage_domain_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if storage_domain_state is None:
            self.storage_domain_state = []
        else:
            self.storage_domain_state = storage_domain_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageDomainStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageDomainStates.subclass:
            return StorageDomainStates.subclass(*args_, **kwargs_)
        else:
            return StorageDomainStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_domain_state(self):
        return self.storage_domain_state
    def set_storage_domain_state(self, storage_domain_state):
        self.storage_domain_state = storage_domain_state
    def add_storage_domain_state(self, value):
        self.storage_domain_state.append(value)
    def insert_storage_domain_state_at(self, index, value):
        self.storage_domain_state.insert(index, value)
    def replace_storage_domain_state_at(self, index, value):
        self.storage_domain_state[index] = value
    storage_domain_stateProp = property(get_storage_domain_state, set_storage_domain_state)
    def hasContent_(self):
        if (
            self.storage_domain_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_domain_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_domain_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_domain_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_domain_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_domain_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_domain_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_domain_state_ in self.storage_domain_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_domain_state>%s</%sstorage_domain_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(storage_domain_state_), input_name='storage_domain_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_domain_state':
            storage_domain_state_ = child_.text
            storage_domain_state_ = self.gds_validate_string(storage_domain_state_, node, 'storage_domain_state')
            self.storage_domain_state.append(storage_domain_state_)
# end class StorageDomainStates


class StorageDomains(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, storage_domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StorageDomains, self).__init__(actions, size, total, active,  **kwargs_)
        if storage_domain is None:
            self.storage_domain = []
        else:
            self.storage_domain = storage_domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageDomains)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageDomains.subclass:
            return StorageDomains.subclass(*args_, **kwargs_)
        else:
            return StorageDomains(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    def add_storage_domain(self, value):
        self.storage_domain.append(value)
    def insert_storage_domain_at(self, index, value):
        self.storage_domain.insert(index, value)
    def replace_storage_domain_at(self, index, value):
        self.storage_domain[index] = value
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def hasContent_(self):
        if (
            self.storage_domain or
            super(StorageDomains, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_domains', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_domains')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_domains')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_domains', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_domains'):
        super(StorageDomains, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_domains')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_domains', fromsubclass_=False, pretty_print=True):
        super(StorageDomains, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_domain_ in self.storage_domain:
            storage_domain_.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageDomains, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain.append(obj_)
            obj_.original_tagname_ = 'storage_domain'
        super(StorageDomains, self).buildChildren(child_, node, nodeName_, True)
# end class StorageDomains


class StorageConnections(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, storage_connection=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StorageConnections, self).__init__(actions, size, total, active,  **kwargs_)
        if storage_connection is None:
            self.storage_connection = []
        else:
            self.storage_connection = storage_connection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageConnections)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageConnections.subclass:
            return StorageConnections.subclass(*args_, **kwargs_)
        else:
            return StorageConnections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_connection(self):
        return self.storage_connection
    def set_storage_connection(self, storage_connection):
        self.storage_connection = storage_connection
    def add_storage_connection(self, value):
        self.storage_connection.append(value)
    def insert_storage_connection_at(self, index, value):
        self.storage_connection.insert(index, value)
    def replace_storage_connection_at(self, index, value):
        self.storage_connection[index] = value
    storage_connectionProp = property(get_storage_connection, set_storage_connection)
    def hasContent_(self):
        if (
            self.storage_connection or
            super(StorageConnections, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_connections', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_connections')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connections')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_connections', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_connections'):
        super(StorageConnections, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_connections')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_connections', fromsubclass_=False, pretty_print=True):
        super(StorageConnections, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_connection_ in self.storage_connection:
            storage_connection_.export(outfile, level, namespaceprefix_, name_='storage_connection', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StorageConnections, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_connection':
            obj_ = StorageConnection.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_connection.append(obj_)
            obj_.original_tagname_ = 'storage_connection'
        super(StorageConnections, self).buildChildren(child_, node, nodeName_, True)
# end class StorageConnections


class InstanceTypes(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, instance_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(InstanceTypes, self).__init__(actions, size, total, active,  **kwargs_)
        if instance_type is None:
            self.instance_type = []
        else:
            self.instance_type = instance_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceTypes.subclass:
            return InstanceTypes.subclass(*args_, **kwargs_)
        else:
            return InstanceTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instance_type(self):
        return self.instance_type
    def set_instance_type(self, instance_type):
        self.instance_type = instance_type
    def add_instance_type(self, value):
        self.instance_type.append(value)
    def insert_instance_type_at(self, index, value):
        self.instance_type.insert(index, value)
    def replace_instance_type_at(self, index, value):
        self.instance_type[index] = value
    instance_typeProp = property(get_instance_type, set_instance_type)
    def hasContent_(self):
        if (
            self.instance_type or
            super(InstanceTypes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='instance_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instance_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instance_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='instance_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instance_types'):
        super(InstanceTypes, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instance_types')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='instance_types', fromsubclass_=False, pretty_print=True):
        super(InstanceTypes, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for instance_type_ in self.instance_type:
            instance_type_.export(outfile, level, namespaceprefix_, name_='instance_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstanceTypes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instance_type':
            obj_ = InstanceType.factory(parent_object_=self)
            obj_.build(child_)
            self.instance_type.append(obj_)
            obj_.original_tagname_ = 'instance_type'
        super(InstanceTypes, self).buildChildren(child_, node, nodeName_, True)
# end class InstanceTypes


class Templates(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, template=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Templates, self).__init__(actions, size, total, active,  **kwargs_)
        if template is None:
            self.template = []
        else:
            self.template = template
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Templates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Templates.subclass:
            return Templates.subclass(*args_, **kwargs_)
        else:
            return Templates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    def add_template(self, value):
        self.template.append(value)
    def insert_template_at(self, index, value):
        self.template.insert(index, value)
    def replace_template_at(self, index, value):
        self.template[index] = value
    templateProp = property(get_template, set_template)
    def hasContent_(self):
        if (
            self.template or
            super(Templates, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='templates', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('templates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='templates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='templates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='templates'):
        super(Templates, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='templates')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='templates', fromsubclass_=False, pretty_print=True):
        super(Templates, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for template_ in self.template:
            template_.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Templates, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template.append(obj_)
            obj_.original_tagname_ = 'template'
        super(Templates, self).buildChildren(child_, node, nodeName_, True)
# end class Templates


class TemplateStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, template_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if template_state is None:
            self.template_state = []
        else:
            self.template_state = template_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TemplateStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TemplateStates.subclass:
            return TemplateStates.subclass(*args_, **kwargs_)
        else:
            return TemplateStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_template_state(self):
        return self.template_state
    def set_template_state(self, template_state):
        self.template_state = template_state
    def add_template_state(self, value):
        self.template_state.append(value)
    def insert_template_state_at(self, index, value):
        self.template_state.insert(index, value)
    def replace_template_state_at(self, index, value):
        self.template_state[index] = value
    template_stateProp = property(get_template_state, set_template_state)
    def hasContent_(self):
        if (
            self.template_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='template_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('template_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='template_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='template_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='template_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='template_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for template_state_ in self.template_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stemplate_state>%s</%stemplate_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(template_state_), input_name='template_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'template_state':
            template_state_ = child_.text
            template_state_ = self.gds_validate_string(template_state_, node, 'template_state')
            self.template_state.append(template_state_)
# end class TemplateStates


class Bios(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, boot_menu=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.boot_menu = boot_menu
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bios)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bios.subclass:
            return Bios.subclass(*args_, **kwargs_)
        else:
            return Bios(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boot_menu(self):
        return self.boot_menu
    def set_boot_menu(self, boot_menu):
        self.boot_menu = boot_menu
    boot_menuProp = property(get_boot_menu, set_boot_menu)
    def hasContent_(self):
        if (
            self.boot_menu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Bios', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Bios')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Bios')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Bios', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Bios'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Bios', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.boot_menu is not None:
            self.boot_menu.export(outfile, level, namespaceprefix_, name_='boot_menu', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boot_menu':
            obj_ = BootMenu.factory(parent_object_=self)
            obj_.build(child_)
            self.boot_menu = obj_
            obj_.original_tagname_ = 'boot_menu'
# end class Bios


class BootMenu(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BootMenu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BootMenu.subclass:
            return BootMenu.subclass(*args_, **kwargs_)
        else:
            return BootMenu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def hasContent_(self):
        if (
            self.enabled is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='boot_menu', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('boot_menu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='boot_menu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='boot_menu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='boot_menu'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='boot_menu', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
# end class BootMenu


class Boot(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dev=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.dev = _cast(None, dev)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Boot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Boot.subclass:
            return Boot.subclass(*args_, **kwargs_)
        else:
            return Boot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dev(self):
        return self.dev
    def set_dev(self, dev):
        self.dev = dev
    devProp = property(get_dev, set_dev)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Boot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Boot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Boot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Boot', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Boot'):
        if self.dev is not None and 'dev' not in already_processed:
            already_processed.add('dev')
            outfile.write(' dev=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dev), input_name='dev')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Boot', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dev', node)
        if value is not None and 'dev' not in already_processed:
            already_processed.add('dev')
            self.dev = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Boot


class OperatingSystem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, boot=None, kernel=None, initrd=None, cmdline=None, version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = _cast(None, type_)
        if boot is None:
            self.boot = []
        else:
            self.boot = boot
        self.kernel = kernel
        self.initrd = initrd
        self.cmdline = cmdline
        self.version = version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperatingSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperatingSystem.subclass:
            return OperatingSystem.subclass(*args_, **kwargs_)
        else:
            return OperatingSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boot(self):
        return self.boot
    def set_boot(self, boot):
        self.boot = boot
    def add_boot(self, value):
        self.boot.append(value)
    def insert_boot_at(self, index, value):
        self.boot.insert(index, value)
    def replace_boot_at(self, index, value):
        self.boot[index] = value
    bootProp = property(get_boot, set_boot)
    def get_kernel(self):
        return self.kernel
    def set_kernel(self, kernel):
        self.kernel = kernel
    kernelProp = property(get_kernel, set_kernel)
    def get_initrd(self):
        return self.initrd
    def set_initrd(self, initrd):
        self.initrd = initrd
    initrdProp = property(get_initrd, set_initrd)
    def get_cmdline(self):
        return self.cmdline
    def set_cmdline(self, cmdline):
        self.cmdline = cmdline
    cmdlineProp = property(get_cmdline, set_cmdline)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.boot or
            self.kernel is not None or
            self.initrd is not None or
            self.cmdline is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='OperatingSystem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OperatingSystem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OperatingSystem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='OperatingSystem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OperatingSystem'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='OperatingSystem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for boot_ in self.boot:
            boot_.export(outfile, level, namespaceprefix_, name_='boot', pretty_print=pretty_print)
        if self.kernel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skernel>%s</%skernel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.kernel), input_name='kernel')), namespaceprefix_ , eol_))
        if self.initrd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitrd>%s</%sinitrd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.initrd), input_name='initrd')), namespaceprefix_ , eol_))
        if self.cmdline is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scmdline>%s</%scmdline>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cmdline), input_name='cmdline')), namespaceprefix_ , eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boot':
            obj_ = Boot.factory(parent_object_=self)
            obj_.build(child_)
            self.boot.append(obj_)
            obj_.original_tagname_ = 'boot'
        elif nodeName_ == 'kernel':
            kernel_ = child_.text
            kernel_ = self.gds_validate_string(kernel_, node, 'kernel')
            self.kernel = kernel_
        elif nodeName_ == 'initrd':
            initrd_ = child_.text
            initrd_ = self.gds_validate_string(initrd_, node, 'initrd')
            self.initrd = initrd_
        elif nodeName_ == 'cmdline':
            cmdline_ = child_.text
            cmdline_ = self.gds_validate_string(cmdline_, node, 'cmdline')
            self.cmdline = cmdline_
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
# end class OperatingSystem


class Sso(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, methods=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.methods = methods
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sso)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sso.subclass:
            return Sso.subclass(*args_, **kwargs_)
        else:
            return Sso(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_methods(self):
        return self.methods
    def set_methods(self, methods):
        self.methods = methods
    methodsProp = property(get_methods, set_methods)
    def hasContent_(self):
        if (
            self.methods is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='sso', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sso')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sso')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='sso', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sso'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='sso', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.methods is not None:
            self.methods.export(outfile, level, namespaceprefix_, name_='methods', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'methods':
            obj_ = Methods.factory(parent_object_=self)
            obj_.build(child_)
            self.methods = obj_
            obj_.original_tagname_ = 'methods'
# end class Sso


class Methods(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, method=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if method is None:
            self.method = []
        else:
            self.method = method
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Methods)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Methods.subclass:
            return Methods.subclass(*args_, **kwargs_)
        else:
            return Methods(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_method(self):
        return self.method
    def set_method(self, method):
        self.method = method
    def add_method(self, value):
        self.method.append(value)
    def insert_method_at(self, index, value):
        self.method.insert(index, value)
    def replace_method_at(self, index, value):
        self.method[index] = value
    methodProp = property(get_method, set_method)
    def hasContent_(self):
        if (
            self.method
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='methods', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('methods')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='methods')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='methods', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='methods'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='methods', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for method_ in self.method:
            method_.export(outfile, level, namespaceprefix_, name_='method', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'method':
            obj_ = Method.factory(parent_object_=self)
            obj_.build(child_)
            self.method.append(obj_)
            obj_.original_tagname_ = 'method'
# end class Methods


class Method(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Method)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Method.subclass:
            return Method.subclass(*args_, **kwargs_)
        else:
            return Method(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    idProp = property(get_id, set_id)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='method', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('method')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='method')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='method', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='method'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='method', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Method


class Rate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bytes=None, period=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.bytes = bytes
        self.period = period
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Rate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Rate.subclass:
            return Rate.subclass(*args_, **kwargs_)
        else:
            return Rate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bytes(self):
        return self.bytes
    def set_bytes(self, bytes):
        self.bytes = bytes
    bytesProp = property(get_bytes, set_bytes)
    def get_period(self):
        return self.period
    def set_period(self, period):
        self.period = period
    periodProp = property(get_period, set_period)
    def hasContent_(self):
        if (
            self.bytes is not None or
            self.period is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Rate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Rate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Rate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Rate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Rate'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Rate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.bytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbytes>%s</%sbytes>%s' % (namespaceprefix_ , self.gds_format_integer(self.bytes, input_name='bytes'), namespaceprefix_ , eol_))
        if self.period is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%speriod>%s</%speriod>%s' % (namespaceprefix_ , self.gds_format_integer(self.period, input_name='period'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bytes' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bytes')
            self.bytes = ival_
        elif nodeName_ == 'period' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'period')
            self.period = ival_
# end class Rate


class RngSources(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if source is None:
            self.source = []
        else:
            self.source = source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RngSources)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RngSources.subclass:
            return RngSources.subclass(*args_, **kwargs_)
        else:
            return RngSources(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def add_source(self, value):
        self.source.append(value)
    def insert_source_at(self, index, value):
        self.source.insert(index, value)
    def replace_source_at(self, index, value):
        self.source[index] = value
    sourceProp = property(get_source, set_source)
    def hasContent_(self):
        if (
            self.source
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='rng_sources', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rng_sources')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rng_sources')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='rng_sources', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rng_sources'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='rng_sources', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for source_ in self.source:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(source_), input_name='source')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source.append(source_)
# end class RngSources


class RngDevice(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rate=None, source=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.rate = rate
        self.source = source
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RngDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RngDevice.subclass:
            return RngDevice.subclass(*args_, **kwargs_)
        else:
            return RngDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rate(self):
        return self.rate
    def set_rate(self, rate):
        self.rate = rate
    rateProp = property(get_rate, set_rate)
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    sourceProp = property(get_source, set_source)
    def hasContent_(self):
        if (
            self.rate is not None or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='rng_device', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rng_device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rng_device')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='rng_device', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rng_device'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='rng_device', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rate is not None:
            self.rate.export(outfile, level, namespaceprefix_, name_='rate', pretty_print=pretty_print)
        if self.source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssource>%s</%ssource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.source), input_name='source')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rate':
            obj_ = Rate.factory(parent_object_=self)
            obj_.build(child_)
            self.rate = obj_
            obj_.original_tagname_ = 'rate'
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source = source_
# end class RngDevice


class HighAvailability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, priority=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
        self.priority = priority
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HighAvailability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HighAvailability.subclass:
            return HighAvailability.subclass(*args_, **kwargs_)
        else:
            return HighAvailability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    priorityProp = property(get_priority, set_priority)
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.priority is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='HighAvailability', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HighAvailability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HighAvailability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='HighAvailability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HighAvailability'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='HighAvailability', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.priority is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spriority>%s</%spriority>%s' % (namespaceprefix_ , self.gds_format_integer(self.priority, input_name='priority'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'priority' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'priority')
            self.priority = ival_
# end class HighAvailability


class Display(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, address=None, port=None, secure_port=None, monitors=None, single_qxl_pci=None, allow_override=None, certificate=None, smartcard_enabled=None, keyboard_layout=None, proxy=None, file_transfer_enabled=None, copy_paste_enabled=None, disconnect_action=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = type_
        self.address = address
        self.port = port
        self.secure_port = secure_port
        self.monitors = monitors
        self.single_qxl_pci = single_qxl_pci
        self.allow_override = allow_override
        self.certificate = certificate
        self.smartcard_enabled = smartcard_enabled
        self.keyboard_layout = keyboard_layout
        self.proxy = proxy
        self.file_transfer_enabled = file_transfer_enabled
        self.copy_paste_enabled = copy_paste_enabled
        self.disconnect_action = disconnect_action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Display)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Display.subclass:
            return Display.subclass(*args_, **kwargs_)
        else:
            return Display(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_secure_port(self):
        return self.secure_port
    def set_secure_port(self, secure_port):
        self.secure_port = secure_port
    secure_portProp = property(get_secure_port, set_secure_port)
    def get_monitors(self):
        return self.monitors
    def set_monitors(self, monitors):
        self.monitors = monitors
    monitorsProp = property(get_monitors, set_monitors)
    def get_single_qxl_pci(self):
        return self.single_qxl_pci
    def set_single_qxl_pci(self, single_qxl_pci):
        self.single_qxl_pci = single_qxl_pci
    single_qxl_pciProp = property(get_single_qxl_pci, set_single_qxl_pci)
    def get_allow_override(self):
        return self.allow_override
    def set_allow_override(self, allow_override):
        self.allow_override = allow_override
    allow_overrideProp = property(get_allow_override, set_allow_override)
    def get_certificate(self):
        return self.certificate
    def set_certificate(self, certificate):
        self.certificate = certificate
    certificateProp = property(get_certificate, set_certificate)
    def get_smartcard_enabled(self):
        return self.smartcard_enabled
    def set_smartcard_enabled(self, smartcard_enabled):
        self.smartcard_enabled = smartcard_enabled
    smartcard_enabledProp = property(get_smartcard_enabled, set_smartcard_enabled)
    def get_keyboard_layout(self):
        return self.keyboard_layout
    def set_keyboard_layout(self, keyboard_layout):
        self.keyboard_layout = keyboard_layout
    keyboard_layoutProp = property(get_keyboard_layout, set_keyboard_layout)
    def get_proxy(self):
        return self.proxy
    def set_proxy(self, proxy):
        self.proxy = proxy
    proxyProp = property(get_proxy, set_proxy)
    def get_file_transfer_enabled(self):
        return self.file_transfer_enabled
    def set_file_transfer_enabled(self, file_transfer_enabled):
        self.file_transfer_enabled = file_transfer_enabled
    file_transfer_enabledProp = property(get_file_transfer_enabled, set_file_transfer_enabled)
    def get_copy_paste_enabled(self):
        return self.copy_paste_enabled
    def set_copy_paste_enabled(self, copy_paste_enabled):
        self.copy_paste_enabled = copy_paste_enabled
    copy_paste_enabledProp = property(get_copy_paste_enabled, set_copy_paste_enabled)
    def get_disconnect_action(self):
        return self.disconnect_action
    def set_disconnect_action(self, disconnect_action):
        self.disconnect_action = disconnect_action
    disconnect_actionProp = property(get_disconnect_action, set_disconnect_action)
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.address is not None or
            self.port is not None or
            self.secure_port is not None or
            self.monitors is not None or
            self.single_qxl_pci is not None or
            self.allow_override is not None or
            self.certificate is not None or
            self.smartcard_enabled is not None or
            self.keyboard_layout is not None or
            self.proxy is not None or
            self.file_transfer_enabled is not None or
            self.copy_paste_enabled is not None or
            self.disconnect_action is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='display', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('display')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='display')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='display', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='display'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='display', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.secure_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecure_port>%s</%ssecure_port>%s' % (namespaceprefix_ , self.gds_format_integer(self.secure_port, input_name='secure_port'), namespaceprefix_ , eol_))
        if self.monitors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smonitors>%s</%smonitors>%s' % (namespaceprefix_ , self.gds_format_integer(self.monitors, input_name='monitors'), namespaceprefix_ , eol_))
        if self.single_qxl_pci is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssingle_qxl_pci>%s</%ssingle_qxl_pci>%s' % (namespaceprefix_ , self.gds_format_boolean(self.single_qxl_pci, input_name='single_qxl_pci'), namespaceprefix_ , eol_))
        if self.allow_override is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sallow_override>%s</%sallow_override>%s' % (namespaceprefix_ , self.gds_format_boolean(self.allow_override, input_name='allow_override'), namespaceprefix_ , eol_))
        if self.certificate is not None:
            self.certificate.export(outfile, level, namespaceprefix_, name_='certificate', pretty_print=pretty_print)
        if self.smartcard_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmartcard_enabled>%s</%ssmartcard_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.smartcard_enabled, input_name='smartcard_enabled'), namespaceprefix_ , eol_))
        if self.keyboard_layout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skeyboard_layout>%s</%skeyboard_layout>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.keyboard_layout), input_name='keyboard_layout')), namespaceprefix_ , eol_))
        if self.proxy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproxy>%s</%sproxy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.proxy), input_name='proxy')), namespaceprefix_ , eol_))
        if self.file_transfer_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfile_transfer_enabled>%s</%sfile_transfer_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.file_transfer_enabled, input_name='file_transfer_enabled'), namespaceprefix_ , eol_))
        if self.copy_paste_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scopy_paste_enabled>%s</%scopy_paste_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.copy_paste_enabled, input_name='copy_paste_enabled'), namespaceprefix_ , eol_))
        if self.disconnect_action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisconnect_action>%s</%sdisconnect_action>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.disconnect_action), input_name='disconnect_action')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'secure_port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'secure_port')
            self.secure_port = ival_
        elif nodeName_ == 'monitors' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'monitors')
            self.monitors = ival_
        elif nodeName_ == 'single_qxl_pci':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'single_qxl_pci')
            self.single_qxl_pci = ival_
        elif nodeName_ == 'allow_override':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'allow_override')
            self.allow_override = ival_
        elif nodeName_ == 'certificate':
            obj_ = Certificate.factory(parent_object_=self)
            obj_.build(child_)
            self.certificate = obj_
            obj_.original_tagname_ = 'certificate'
        elif nodeName_ == 'smartcard_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'smartcard_enabled')
            self.smartcard_enabled = ival_
        elif nodeName_ == 'keyboard_layout':
            keyboard_layout_ = child_.text
            keyboard_layout_ = self.gds_validate_string(keyboard_layout_, node, 'keyboard_layout')
            self.keyboard_layout = keyboard_layout_
        elif nodeName_ == 'proxy':
            proxy_ = child_.text
            proxy_ = self.gds_validate_string(proxy_, node, 'proxy')
            self.proxy = proxy_
        elif nodeName_ == 'file_transfer_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'file_transfer_enabled')
            self.file_transfer_enabled = ival_
        elif nodeName_ == 'copy_paste_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'copy_paste_enabled')
            self.copy_paste_enabled = ival_
        elif nodeName_ == 'disconnect_action':
            disconnect_action_ = child_.text
            disconnect_action_ = self.gds_validate_string(disconnect_action_, node, 'disconnect_action')
            self.disconnect_action = disconnect_action_
# end class Display


class GraphicsConsoles(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, graphics_console=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GraphicsConsoles, self).__init__(actions, size, total, active,  **kwargs_)
        if graphics_console is None:
            self.graphics_console = []
        else:
            self.graphics_console = graphics_console
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GraphicsConsoles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GraphicsConsoles.subclass:
            return GraphicsConsoles.subclass(*args_, **kwargs_)
        else:
            return GraphicsConsoles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_graphics_console(self):
        return self.graphics_console
    def set_graphics_console(self, graphics_console):
        self.graphics_console = graphics_console
    def add_graphics_console(self, value):
        self.graphics_console.append(value)
    def insert_graphics_console_at(self, index, value):
        self.graphics_console.insert(index, value)
    def replace_graphics_console_at(self, index, value):
        self.graphics_console[index] = value
    graphics_consoleProp = property(get_graphics_console, set_graphics_console)
    def hasContent_(self):
        if (
            self.graphics_console or
            super(GraphicsConsoles, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='graphics_consoles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('graphics_consoles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='graphics_consoles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='graphics_consoles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='graphics_consoles'):
        super(GraphicsConsoles, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='graphics_consoles')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='graphics_consoles', fromsubclass_=False, pretty_print=True):
        super(GraphicsConsoles, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for graphics_console_ in self.graphics_console:
            graphics_console_.export(outfile, level, namespaceprefix_, name_='graphics_console', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GraphicsConsoles, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'graphics_console':
            obj_ = GraphicsConsole.factory(parent_object_=self)
            obj_.build(child_)
            self.graphics_console.append(obj_)
            obj_.original_tagname_ = 'graphics_console'
        super(GraphicsConsoles, self).buildChildren(child_, node, nodeName_, True)
# end class GraphicsConsoles


class GraphicsConsole(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, vm=None, template=None, instance_type=None, protocol=None, port=None, tls_port=None, address=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GraphicsConsole, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.vm = vm
        self.template = template
        self.instance_type = instance_type
        self.protocol = protocol
        self.port = port
        self.tls_port = tls_port
        self.address = address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GraphicsConsole)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GraphicsConsole.subclass:
            return GraphicsConsole.subclass(*args_, **kwargs_)
        else:
            return GraphicsConsole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_instance_type(self):
        return self.instance_type
    def set_instance_type(self, instance_type):
        self.instance_type = instance_type
    instance_typeProp = property(get_instance_type, set_instance_type)
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    protocolProp = property(get_protocol, set_protocol)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_tls_port(self):
        return self.tls_port
    def set_tls_port(self, tls_port):
        self.tls_port = tls_port
    tls_portProp = property(get_tls_port, set_tls_port)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def hasContent_(self):
        if (
            self.vm is not None or
            self.template is not None or
            self.instance_type is not None or
            self.protocol is not None or
            self.port is not None or
            self.tls_port is not None or
            self.address is not None or
            super(GraphicsConsole, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='graphics_console', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('graphics_console')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='graphics_console')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='graphics_console', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='graphics_console'):
        super(GraphicsConsole, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='graphics_console')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='graphics_console', fromsubclass_=False, pretty_print=True):
        super(GraphicsConsole, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.instance_type is not None:
            self.instance_type.export(outfile, level, namespaceprefix_, name_='instance_type', pretty_print=pretty_print)
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.protocol), input_name='protocol')), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.tls_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stls_port>%s</%stls_port>%s' % (namespaceprefix_ , self.gds_format_integer(self.tls_port, input_name='tls_port'), namespaceprefix_ , eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GraphicsConsole, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'instance_type':
            obj_ = InstanceType.factory(parent_object_=self)
            obj_.build(child_)
            self.instance_type = obj_
            obj_.original_tagname_ = 'instance_type'
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'tls_port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'tls_port')
            self.tls_port = ival_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        super(GraphicsConsole, self).buildChildren(child_, node, nodeName_, True)
# end class GraphicsConsole


class Ticket(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, expiry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.value = value
        self.expiry = expiry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Ticket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Ticket.subclass:
            return Ticket.subclass(*args_, **kwargs_)
        else:
            return Ticket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_expiry(self):
        return self.expiry
    def set_expiry(self, expiry):
        self.expiry = expiry
    expiryProp = property(get_expiry, set_expiry)
    def hasContent_(self):
        if (
            self.value is not None or
            self.expiry is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Ticket', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Ticket')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Ticket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Ticket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Ticket'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Ticket', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
        if self.expiry is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpiry>%s</%sexpiry>%s' % (namespaceprefix_ , self.gds_format_integer(self.expiry, input_name='expiry'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'expiry' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'expiry')
            self.expiry = ival_
# end class Ticket


class CustomProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, regexp=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        self.regexp = _cast(None, regexp)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomProperty)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomProperty.subclass:
            return CustomProperty.subclass(*args_, **kwargs_)
        else:
            return CustomProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_regexp(self):
        return self.regexp
    def set_regexp(self, regexp):
        self.regexp = regexp
    regexpProp = property(get_regexp, set_regexp)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='CustomProperty', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomProperty')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomProperty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='CustomProperty', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomProperty'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
        if self.regexp is not None and 'regexp' not in already_processed:
            already_processed.add('regexp')
            outfile.write(' regexp=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.regexp), input_name='regexp')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='CustomProperty', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('regexp', node)
        if value is not None and 'regexp' not in already_processed:
            already_processed.add('regexp')
            self.regexp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CustomProperty


class CustomProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, custom_property=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if custom_property is None:
            self.custom_property = []
        else:
            self.custom_property = custom_property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomProperties.subclass:
            return CustomProperties.subclass(*args_, **kwargs_)
        else:
            return CustomProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_custom_property(self):
        return self.custom_property
    def set_custom_property(self, custom_property):
        self.custom_property = custom_property
    def add_custom_property(self, value):
        self.custom_property.append(value)
    def insert_custom_property_at(self, index, value):
        self.custom_property.insert(index, value)
    def replace_custom_property_at(self, index, value):
        self.custom_property[index] = value
    custom_propertyProp = property(get_custom_property, set_custom_property)
    def hasContent_(self):
        if (
            self.custom_property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='custom_properties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('custom_properties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='custom_properties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='custom_properties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='custom_properties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='custom_properties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for custom_property_ in self.custom_property:
            custom_property_.export(outfile, level, namespaceprefix_, name_='custom_property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'custom_property':
            obj_ = CustomProperty.factory(parent_object_=self)
            obj_.build(child_)
            self.custom_property.append(obj_)
            obj_.original_tagname_ = 'custom_property'
# end class CustomProperties


class Property(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Property)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Property.subclass:
            return Property.subclass(*args_, **kwargs_)
        else:
            return Property(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='property', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('property')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='property')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='property', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='property'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='property', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class Property


class Properties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, property=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Properties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Properties.subclass:
            return Properties.subclass(*args_, **kwargs_)
        else:
            return Properties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_property(self):
        return self.property
    def set_property(self, property):
        self.property = property
    def add_property(self, value):
        self.property.append(value)
    def insert_property_at(self, index, value):
        self.property.insert(index, value)
    def replace_property_at(self, index, value):
        self.property[index] = value
    propertyProp = property(get_property, set_property)
    def hasContent_(self):
        if (
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='properties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('properties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='properties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='properties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='properties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='properties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for property_ in self.property:
            property_.export(outfile, level, namespaceprefix_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'property':
            obj_ = Property.factory(parent_object_=self)
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class Properties


class Payloads(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, payload=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if payload is None:
            self.payload = []
        else:
            self.payload = payload
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payloads)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payloads.subclass:
            return Payloads.subclass(*args_, **kwargs_)
        else:
            return Payloads(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_payload(self):
        return self.payload
    def set_payload(self, payload):
        self.payload = payload
    def add_payload(self, value):
        self.payload.append(value)
    def insert_payload_at(self, index, value):
        self.payload.insert(index, value)
    def replace_payload_at(self, index, value):
        self.payload[index] = value
    payloadProp = property(get_payload, set_payload)
    def hasContent_(self):
        if (
            self.payload
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='payloads', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('payloads')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='payloads')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='payloads', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='payloads'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='payloads', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for payload_ in self.payload:
            payload_.export(outfile, level, namespaceprefix_, name_='payload', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'payload':
            obj_ = Payload.factory(parent_object_=self)
            obj_.build(child_)
            self.payload.append(obj_)
            obj_.original_tagname_ = 'payload'
# end class Payloads


class Payload(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, files=None, volume_id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = _cast(None, type_)
        self.files = files
        self.volume_id = volume_id
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Payload)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Payload.subclass:
            return Payload.subclass(*args_, **kwargs_)
        else:
            return Payload(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_files(self):
        return self.files
    def set_files(self, files):
        self.files = files
    filesProp = property(get_files, set_files)
    def get_volume_id(self):
        return self.volume_id
    def set_volume_id(self, volume_id):
        self.volume_id = volume_id
    volume_idProp = property(get_volume_id, set_volume_id)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.files is not None or
            self.volume_id is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='payload', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('payload')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='payload')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='payload', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='payload'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='payload', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.files is not None:
            self.files.export(outfile, level, namespaceprefix_, name_='files', pretty_print=pretty_print)
        if self.volume_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume_id>%s</%svolume_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume_id), input_name='volume_id')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'files':
            obj_ = Files.factory(parent_object_=self)
            obj_.build(child_)
            self.files = obj_
            obj_.original_tagname_ = 'files'
        elif nodeName_ == 'volume_id':
            volume_id_ = child_.text
            volume_id_ = self.gds_validate_string(volume_id_, node, 'volume_id')
            self.volume_id = volume_id_
# end class Payload


class VmDeviceTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vm_device_types=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vm_device_types is None:
            self.vm_device_types = []
        else:
            self.vm_device_types = vm_device_types
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmDeviceTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmDeviceTypes.subclass:
            return VmDeviceTypes.subclass(*args_, **kwargs_)
        else:
            return VmDeviceTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm_device_types(self):
        return self.vm_device_types
    def set_vm_device_types(self, vm_device_types):
        self.vm_device_types = vm_device_types
    def add_vm_device_types(self, value):
        self.vm_device_types.append(value)
    def insert_vm_device_types_at(self, index, value):
        self.vm_device_types.insert(index, value)
    def replace_vm_device_types_at(self, index, value):
        self.vm_device_types[index] = value
    vm_device_typesProp = property(get_vm_device_types, set_vm_device_types)
    def hasContent_(self):
        if (
            self.vm_device_types
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_device_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_device_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_device_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_device_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_device_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_device_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_device_types_ in self.vm_device_types:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svm_device_types>%s</%svm_device_types>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(vm_device_types_), input_name='vm_device_types')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm_device_types':
            vm_device_types_ = child_.text
            vm_device_types_ = self.gds_validate_string(vm_device_types_, node, 'vm_device_types')
            self.vm_device_types.append(vm_device_types_)
# end class VmDeviceTypes


class Configuration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = type_
        self.data = data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Configuration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Configuration.subclass:
            return Configuration.subclass(*args_, **kwargs_)
        else:
            return Configuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    dataProp = property(get_data, set_data)
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='configuration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='configuration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='configuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.data), input_name='data')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data = data_
# end class Configuration


class Initialization(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, configuration=None, cloud_init=None, host_name=None, domain=None, timezone=None, authorized_ssh_keys=None, regenerate_ssh_keys=None, regenerate_ids=None, dns_servers=None, dns_search=None, nic_configurations=None, windows_license_key=None, root_password=None, custom_script=None, input_locale=None, ui_language=None, system_locale=None, user_locale=None, user_name=None, active_directory_ou=None, org_name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.configuration = configuration
        self.cloud_init = cloud_init
        self.host_name = host_name
        self.domain = domain
        self.timezone = timezone
        self.authorized_ssh_keys = authorized_ssh_keys
        self.regenerate_ssh_keys = regenerate_ssh_keys
        self.regenerate_ids = regenerate_ids
        self.dns_servers = dns_servers
        self.dns_search = dns_search
        self.nic_configurations = nic_configurations
        self.windows_license_key = windows_license_key
        self.root_password = root_password
        self.custom_script = custom_script
        self.input_locale = input_locale
        self.ui_language = ui_language
        self.system_locale = system_locale
        self.user_locale = user_locale
        self.user_name = user_name
        self.active_directory_ou = active_directory_ou
        self.org_name = org_name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Initialization)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Initialization.subclass:
            return Initialization.subclass(*args_, **kwargs_)
        else:
            return Initialization(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configuration(self):
        return self.configuration
    def set_configuration(self, configuration):
        self.configuration = configuration
    configurationProp = property(get_configuration, set_configuration)
    def get_cloud_init(self):
        return self.cloud_init
    def set_cloud_init(self, cloud_init):
        self.cloud_init = cloud_init
    cloud_initProp = property(get_cloud_init, set_cloud_init)
    def get_host_name(self):
        return self.host_name
    def set_host_name(self, host_name):
        self.host_name = host_name
    host_nameProp = property(get_host_name, set_host_name)
    def get_domain(self):
        return self.domain
    def set_domain(self, domain):
        self.domain = domain
    domainProp = property(get_domain, set_domain)
    def get_timezone(self):
        return self.timezone
    def set_timezone(self, timezone):
        self.timezone = timezone
    timezoneProp = property(get_timezone, set_timezone)
    def get_authorized_ssh_keys(self):
        return self.authorized_ssh_keys
    def set_authorized_ssh_keys(self, authorized_ssh_keys):
        self.authorized_ssh_keys = authorized_ssh_keys
    authorized_ssh_keysProp = property(get_authorized_ssh_keys, set_authorized_ssh_keys)
    def get_regenerate_ssh_keys(self):
        return self.regenerate_ssh_keys
    def set_regenerate_ssh_keys(self, regenerate_ssh_keys):
        self.regenerate_ssh_keys = regenerate_ssh_keys
    regenerate_ssh_keysProp = property(get_regenerate_ssh_keys, set_regenerate_ssh_keys)
    def get_regenerate_ids(self):
        return self.regenerate_ids
    def set_regenerate_ids(self, regenerate_ids):
        self.regenerate_ids = regenerate_ids
    regenerate_idsProp = property(get_regenerate_ids, set_regenerate_ids)
    def get_dns_servers(self):
        return self.dns_servers
    def set_dns_servers(self, dns_servers):
        self.dns_servers = dns_servers
    dns_serversProp = property(get_dns_servers, set_dns_servers)
    def get_dns_search(self):
        return self.dns_search
    def set_dns_search(self, dns_search):
        self.dns_search = dns_search
    dns_searchProp = property(get_dns_search, set_dns_search)
    def get_nic_configurations(self):
        return self.nic_configurations
    def set_nic_configurations(self, nic_configurations):
        self.nic_configurations = nic_configurations
    nic_configurationsProp = property(get_nic_configurations, set_nic_configurations)
    def get_windows_license_key(self):
        return self.windows_license_key
    def set_windows_license_key(self, windows_license_key):
        self.windows_license_key = windows_license_key
    windows_license_keyProp = property(get_windows_license_key, set_windows_license_key)
    def get_root_password(self):
        return self.root_password
    def set_root_password(self, root_password):
        self.root_password = root_password
    root_passwordProp = property(get_root_password, set_root_password)
    def get_custom_script(self):
        return self.custom_script
    def set_custom_script(self, custom_script):
        self.custom_script = custom_script
    custom_scriptProp = property(get_custom_script, set_custom_script)
    def get_input_locale(self):
        return self.input_locale
    def set_input_locale(self, input_locale):
        self.input_locale = input_locale
    input_localeProp = property(get_input_locale, set_input_locale)
    def get_ui_language(self):
        return self.ui_language
    def set_ui_language(self, ui_language):
        self.ui_language = ui_language
    ui_languageProp = property(get_ui_language, set_ui_language)
    def get_system_locale(self):
        return self.system_locale
    def set_system_locale(self, system_locale):
        self.system_locale = system_locale
    system_localeProp = property(get_system_locale, set_system_locale)
    def get_user_locale(self):
        return self.user_locale
    def set_user_locale(self, user_locale):
        self.user_locale = user_locale
    user_localeProp = property(get_user_locale, set_user_locale)
    def get_user_name(self):
        return self.user_name
    def set_user_name(self, user_name):
        self.user_name = user_name
    user_nameProp = property(get_user_name, set_user_name)
    def get_active_directory_ou(self):
        return self.active_directory_ou
    def set_active_directory_ou(self, active_directory_ou):
        self.active_directory_ou = active_directory_ou
    active_directory_ouProp = property(get_active_directory_ou, set_active_directory_ou)
    def get_org_name(self):
        return self.org_name
    def set_org_name(self, org_name):
        self.org_name = org_name
    org_nameProp = property(get_org_name, set_org_name)
    def hasContent_(self):
        if (
            self.configuration is not None or
            self.cloud_init is not None or
            self.host_name is not None or
            self.domain is not None or
            self.timezone is not None or
            self.authorized_ssh_keys is not None or
            self.regenerate_ssh_keys is not None or
            self.regenerate_ids is not None or
            self.dns_servers is not None or
            self.dns_search is not None or
            self.nic_configurations is not None or
            self.windows_license_key is not None or
            self.root_password is not None or
            self.custom_script is not None or
            self.input_locale is not None or
            self.ui_language is not None or
            self.system_locale is not None or
            self.user_locale is not None or
            self.user_name is not None or
            self.active_directory_ou is not None or
            self.org_name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='initialization', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('initialization')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='initialization')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='initialization', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='initialization'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='initialization', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.configuration is not None:
            self.configuration.export(outfile, level, namespaceprefix_, name_='configuration', pretty_print=pretty_print)
        if self.cloud_init is not None:
            self.cloud_init.export(outfile, level, namespaceprefix_, name_='cloud_init', pretty_print=pretty_print)
        if self.host_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost_name>%s</%shost_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.host_name), input_name='host_name')), namespaceprefix_ , eol_))
        if self.domain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain>%s</%sdomain>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.domain), input_name='domain')), namespaceprefix_ , eol_))
        if self.timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimezone>%s</%stimezone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timezone), input_name='timezone')), namespaceprefix_ , eol_))
        if self.authorized_ssh_keys is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauthorized_ssh_keys>%s</%sauthorized_ssh_keys>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.authorized_ssh_keys), input_name='authorized_ssh_keys')), namespaceprefix_ , eol_))
        if self.regenerate_ssh_keys is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregenerate_ssh_keys>%s</%sregenerate_ssh_keys>%s' % (namespaceprefix_ , self.gds_format_boolean(self.regenerate_ssh_keys, input_name='regenerate_ssh_keys'), namespaceprefix_ , eol_))
        if self.regenerate_ids is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregenerate_ids>%s</%sregenerate_ids>%s' % (namespaceprefix_ , self.gds_format_boolean(self.regenerate_ids, input_name='regenerate_ids'), namespaceprefix_ , eol_))
        if self.dns_servers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns_servers>%s</%sdns_servers>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dns_servers), input_name='dns_servers')), namespaceprefix_ , eol_))
        if self.dns_search is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns_search>%s</%sdns_search>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dns_search), input_name='dns_search')), namespaceprefix_ , eol_))
        if self.nic_configurations is not None:
            self.nic_configurations.export(outfile, level, namespaceprefix_, name_='nic_configurations', pretty_print=pretty_print)
        if self.windows_license_key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swindows_license_key>%s</%swindows_license_key>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.windows_license_key), input_name='windows_license_key')), namespaceprefix_ , eol_))
        if self.root_password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroot_password>%s</%sroot_password>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.root_password), input_name='root_password')), namespaceprefix_ , eol_))
        if self.custom_script is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustom_script>%s</%scustom_script>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.custom_script), input_name='custom_script')), namespaceprefix_ , eol_))
        if self.input_locale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinput_locale>%s</%sinput_locale>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.input_locale), input_name='input_locale')), namespaceprefix_ , eol_))
        if self.ui_language is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sui_language>%s</%sui_language>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ui_language), input_name='ui_language')), namespaceprefix_ , eol_))
        if self.system_locale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssystem_locale>%s</%ssystem_locale>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.system_locale), input_name='system_locale')), namespaceprefix_ , eol_))
        if self.user_locale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser_locale>%s</%suser_locale>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.user_locale), input_name='user_locale')), namespaceprefix_ , eol_))
        if self.user_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser_name>%s</%suser_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.user_name), input_name='user_name')), namespaceprefix_ , eol_))
        if self.active_directory_ou is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactive_directory_ou>%s</%sactive_directory_ou>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.active_directory_ou), input_name='active_directory_ou')), namespaceprefix_ , eol_))
        if self.org_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorg_name>%s</%sorg_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.org_name), input_name='org_name')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configuration':
            obj_ = Configuration.factory(parent_object_=self)
            obj_.build(child_)
            self.configuration = obj_
            obj_.original_tagname_ = 'configuration'
        elif nodeName_ == 'cloud_init':
            obj_ = CloudInit.factory(parent_object_=self)
            obj_.build(child_)
            self.cloud_init = obj_
            obj_.original_tagname_ = 'cloud_init'
        elif nodeName_ == 'host_name':
            host_name_ = child_.text
            host_name_ = self.gds_validate_string(host_name_, node, 'host_name')
            self.host_name = host_name_
        elif nodeName_ == 'domain':
            domain_ = child_.text
            domain_ = self.gds_validate_string(domain_, node, 'domain')
            self.domain = domain_
        elif nodeName_ == 'timezone':
            timezone_ = child_.text
            timezone_ = self.gds_validate_string(timezone_, node, 'timezone')
            self.timezone = timezone_
        elif nodeName_ == 'authorized_ssh_keys':
            authorized_ssh_keys_ = child_.text
            authorized_ssh_keys_ = self.gds_validate_string(authorized_ssh_keys_, node, 'authorized_ssh_keys')
            self.authorized_ssh_keys = authorized_ssh_keys_
        elif nodeName_ == 'regenerate_ssh_keys':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'regenerate_ssh_keys')
            self.regenerate_ssh_keys = ival_
        elif nodeName_ == 'regenerate_ids':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'regenerate_ids')
            self.regenerate_ids = ival_
        elif nodeName_ == 'dns_servers':
            dns_servers_ = child_.text
            dns_servers_ = self.gds_validate_string(dns_servers_, node, 'dns_servers')
            self.dns_servers = dns_servers_
        elif nodeName_ == 'dns_search':
            dns_search_ = child_.text
            dns_search_ = self.gds_validate_string(dns_search_, node, 'dns_search')
            self.dns_search = dns_search_
        elif nodeName_ == 'nic_configurations':
            obj_ = GuestNicsConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.nic_configurations = obj_
            obj_.original_tagname_ = 'nic_configurations'
        elif nodeName_ == 'windows_license_key':
            windows_license_key_ = child_.text
            windows_license_key_ = self.gds_validate_string(windows_license_key_, node, 'windows_license_key')
            self.windows_license_key = windows_license_key_
        elif nodeName_ == 'root_password':
            root_password_ = child_.text
            root_password_ = self.gds_validate_string(root_password_, node, 'root_password')
            self.root_password = root_password_
        elif nodeName_ == 'custom_script':
            custom_script_ = child_.text
            custom_script_ = self.gds_validate_string(custom_script_, node, 'custom_script')
            self.custom_script = custom_script_
        elif nodeName_ == 'input_locale':
            input_locale_ = child_.text
            input_locale_ = self.gds_validate_string(input_locale_, node, 'input_locale')
            self.input_locale = input_locale_
        elif nodeName_ == 'ui_language':
            ui_language_ = child_.text
            ui_language_ = self.gds_validate_string(ui_language_, node, 'ui_language')
            self.ui_language = ui_language_
        elif nodeName_ == 'system_locale':
            system_locale_ = child_.text
            system_locale_ = self.gds_validate_string(system_locale_, node, 'system_locale')
            self.system_locale = system_locale_
        elif nodeName_ == 'user_locale':
            user_locale_ = child_.text
            user_locale_ = self.gds_validate_string(user_locale_, node, 'user_locale')
            self.user_locale = user_locale_
        elif nodeName_ == 'user_name':
            user_name_ = child_.text
            user_name_ = self.gds_validate_string(user_name_, node, 'user_name')
            self.user_name = user_name_
        elif nodeName_ == 'active_directory_ou':
            active_directory_ou_ = child_.text
            active_directory_ou_ = self.gds_validate_string(active_directory_ou_, node, 'active_directory_ou')
            self.active_directory_ou = active_directory_ou_
        elif nodeName_ == 'org_name':
            org_name_ = child_.text
            org_name_ = self.gds_validate_string(org_name_, node, 'org_name')
            self.org_name = org_name_
# end class Initialization


class DNS(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, servers=None, search_domains=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.servers = servers
        self.search_domains = search_domains
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DNS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DNS.subclass:
            return DNS.subclass(*args_, **kwargs_)
        else:
            return DNS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_servers(self):
        return self.servers
    def set_servers(self, servers):
        self.servers = servers
    serversProp = property(get_servers, set_servers)
    def get_search_domains(self):
        return self.search_domains
    def set_search_domains(self, search_domains):
        self.search_domains = search_domains
    search_domainsProp = property(get_search_domains, set_search_domains)
    def hasContent_(self):
        if (
            self.servers is not None or
            self.search_domains is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='dns', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dns')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dns')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='dns', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dns'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='dns', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.servers is not None:
            self.servers.export(outfile, level, namespaceprefix_, name_='servers', pretty_print=pretty_print)
        if self.search_domains is not None:
            self.search_domains.export(outfile, level, namespaceprefix_, name_='search_domains', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'servers':
            obj_ = Hosts.factory(parent_object_=self)
            obj_.build(child_)
            self.servers = obj_
            obj_.original_tagname_ = 'servers'
        elif nodeName_ == 'search_domains':
            obj_ = Hosts.factory(parent_object_=self)
            obj_.build(child_)
            self.search_domains = obj_
            obj_.original_tagname_ = 'search_domains'
# end class DNS


class AuthorizedKey(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, user=None, key=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AuthorizedKey, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.user = user
        self.key = key
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthorizedKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthorizedKey.subclass:
            return AuthorizedKey.subclass(*args_, **kwargs_)
        else:
            return AuthorizedKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_key(self):
        return self.key
    def set_key(self, key):
        self.key = key
    keyProp = property(get_key, set_key)
    def hasContent_(self):
        if (
            self.user is not None or
            self.key is not None or
            super(AuthorizedKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='authorized_key', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('authorized_key')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='authorized_key')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='authorized_key', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='authorized_key'):
        super(AuthorizedKey, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='authorized_key')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='authorized_key', fromsubclass_=False, pretty_print=True):
        super(AuthorizedKey, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
        if self.key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skey>%s</%skey>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.key), input_name='key')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AuthorizedKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'key':
            key_ = child_.text
            key_ = self.gds_validate_string(key_, node, 'key')
            self.key = key_
        super(AuthorizedKey, self).buildChildren(child_, node, nodeName_, True)
# end class AuthorizedKey


class AuthorizedKeys(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, authorized_key=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AuthorizedKeys, self).__init__(actions, size, total, active,  **kwargs_)
        if authorized_key is None:
            self.authorized_key = []
        else:
            self.authorized_key = authorized_key
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthorizedKeys)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthorizedKeys.subclass:
            return AuthorizedKeys.subclass(*args_, **kwargs_)
        else:
            return AuthorizedKeys(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_authorized_key(self):
        return self.authorized_key
    def set_authorized_key(self, authorized_key):
        self.authorized_key = authorized_key
    def add_authorized_key(self, value):
        self.authorized_key.append(value)
    def insert_authorized_key_at(self, index, value):
        self.authorized_key.insert(index, value)
    def replace_authorized_key_at(self, index, value):
        self.authorized_key[index] = value
    authorized_keyProp = property(get_authorized_key, set_authorized_key)
    def hasContent_(self):
        if (
            self.authorized_key or
            super(AuthorizedKeys, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='authorized_keys', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('authorized_keys')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='authorized_keys')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='authorized_keys', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='authorized_keys'):
        super(AuthorizedKeys, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='authorized_keys')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='authorized_keys', fromsubclass_=False, pretty_print=True):
        super(AuthorizedKeys, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for authorized_key_ in self.authorized_key:
            authorized_key_.export(outfile, level, namespaceprefix_, name_='authorized_key', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AuthorizedKeys, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'authorized_key':
            obj_ = AuthorizedKey.factory(parent_object_=self)
            obj_.build(child_)
            self.authorized_key.append(obj_)
            obj_.original_tagname_ = 'authorized_key'
        super(AuthorizedKeys, self).buildChildren(child_, node, nodeName_, True)
# end class AuthorizedKeys


class CloudInit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host=None, authorized_keys=None, network_configuration=None, regenerate_ssh_keys=None, timezone=None, users=None, files=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.host = host
        self.authorized_keys = authorized_keys
        self.network_configuration = network_configuration
        self.regenerate_ssh_keys = regenerate_ssh_keys
        self.timezone = timezone
        self.users = users
        self.files = files
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CloudInit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CloudInit.subclass:
            return CloudInit.subclass(*args_, **kwargs_)
        else:
            return CloudInit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_authorized_keys(self):
        return self.authorized_keys
    def set_authorized_keys(self, authorized_keys):
        self.authorized_keys = authorized_keys
    authorized_keysProp = property(get_authorized_keys, set_authorized_keys)
    def get_network_configuration(self):
        return self.network_configuration
    def set_network_configuration(self, network_configuration):
        self.network_configuration = network_configuration
    network_configurationProp = property(get_network_configuration, set_network_configuration)
    def get_regenerate_ssh_keys(self):
        return self.regenerate_ssh_keys
    def set_regenerate_ssh_keys(self, regenerate_ssh_keys):
        self.regenerate_ssh_keys = regenerate_ssh_keys
    regenerate_ssh_keysProp = property(get_regenerate_ssh_keys, set_regenerate_ssh_keys)
    def get_timezone(self):
        return self.timezone
    def set_timezone(self, timezone):
        self.timezone = timezone
    timezoneProp = property(get_timezone, set_timezone)
    def get_users(self):
        return self.users
    def set_users(self, users):
        self.users = users
    usersProp = property(get_users, set_users)
    def get_files(self):
        return self.files
    def set_files(self, files):
        self.files = files
    filesProp = property(get_files, set_files)
    def hasContent_(self):
        if (
            self.host is not None or
            self.authorized_keys is not None or
            self.network_configuration is not None or
            self.regenerate_ssh_keys is not None or
            self.timezone is not None or
            self.users is not None or
            self.files is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cloud_init', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cloud_init')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cloud_init')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cloud_init', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cloud_init'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cloud_init', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.authorized_keys is not None:
            self.authorized_keys.export(outfile, level, namespaceprefix_, name_='authorized_keys', pretty_print=pretty_print)
        if self.network_configuration is not None:
            self.network_configuration.export(outfile, level, namespaceprefix_, name_='network_configuration', pretty_print=pretty_print)
        if self.regenerate_ssh_keys is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregenerate_ssh_keys>%s</%sregenerate_ssh_keys>%s' % (namespaceprefix_ , self.gds_format_boolean(self.regenerate_ssh_keys, input_name='regenerate_ssh_keys'), namespaceprefix_ , eol_))
        if self.timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimezone>%s</%stimezone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timezone), input_name='timezone')), namespaceprefix_ , eol_))
        if self.users is not None:
            self.users.export(outfile, level, namespaceprefix_, name_='users', pretty_print=pretty_print)
        if self.files is not None:
            self.files.export(outfile, level, namespaceprefix_, name_='files', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'authorized_keys':
            obj_ = AuthorizedKeys.factory(parent_object_=self)
            obj_.build(child_)
            self.authorized_keys = obj_
            obj_.original_tagname_ = 'authorized_keys'
        elif nodeName_ == 'network_configuration':
            obj_ = NetworkConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.network_configuration = obj_
            obj_.original_tagname_ = 'network_configuration'
        elif nodeName_ == 'regenerate_ssh_keys':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'regenerate_ssh_keys')
            self.regenerate_ssh_keys = ival_
        elif nodeName_ == 'timezone':
            timezone_ = child_.text
            timezone_ = self.gds_validate_string(timezone_, node, 'timezone')
            self.timezone = timezone_
        elif nodeName_ == 'users':
            obj_ = Users.factory(parent_object_=self)
            obj_.build(child_)
            self.users = obj_
            obj_.original_tagname_ = 'users'
        elif nodeName_ == 'files':
            obj_ = Files.factory(parent_object_=self)
            obj_.build(child_)
            self.files = obj_
            obj_.original_tagname_ = 'files'
# end class CloudInit


class NetworkConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nics=None, dns=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nics = nics
        self.dns = dns
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetworkConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetworkConfiguration.subclass:
            return NetworkConfiguration.subclass(*args_, **kwargs_)
        else:
            return NetworkConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nics(self):
        return self.nics
    def set_nics(self, nics):
        self.nics = nics
    nicsProp = property(get_nics, set_nics)
    def get_dns(self):
        return self.dns
    def set_dns(self, dns):
        self.dns = dns
    dnsProp = property(get_dns, set_dns)
    def hasContent_(self):
        if (
            self.nics is not None or
            self.dns is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='network_configuration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('network_configuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='network_configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='network_configuration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='network_configuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nics is not None:
            self.nics.export(outfile, level, namespaceprefix_, name_='nics', pretty_print=pretty_print)
        if self.dns is not None:
            self.dns.export(outfile, level, namespaceprefix_, name_='dns', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nics':
            obj_ = Nics.factory(parent_object_=self)
            obj_.build(child_)
            self.nics = obj_
            obj_.original_tagname_ = 'nics'
        elif nodeName_ == 'dns':
            obj_ = DNS.factory(parent_object_=self)
            obj_.build(child_)
            self.dns = obj_
            obj_.original_tagname_ = 'dns'
# end class NetworkConfiguration


class VmPlacementPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hosts=None, host=None, affinity=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.hosts = hosts
        self.host = host
        self.affinity = affinity
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmPlacementPolicy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmPlacementPolicy.subclass:
            return VmPlacementPolicy.subclass(*args_, **kwargs_)
        else:
            return VmPlacementPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hosts(self):
        return self.hosts
    def set_hosts(self, hosts):
        self.hosts = hosts
    hostsProp = property(get_hosts, set_hosts)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_affinity(self):
        return self.affinity
    def set_affinity(self, affinity):
        self.affinity = affinity
    affinityProp = property(get_affinity, set_affinity)
    def hasContent_(self):
        if (
            self.hosts is not None or
            self.host is not None or
            self.affinity is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VmPlacementPolicy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VmPlacementPolicy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VmPlacementPolicy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='VmPlacementPolicy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VmPlacementPolicy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VmPlacementPolicy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hosts is not None:
            self.hosts.export(outfile, level, namespaceprefix_, name_='hosts', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.affinity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saffinity>%s</%saffinity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.affinity), input_name='affinity')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hosts':
            obj_ = Hosts.factory(parent_object_=self)
            obj_.build(child_)
            self.hosts = obj_
            obj_.original_tagname_ = 'hosts'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'affinity':
            affinity_ = child_.text
            affinity_ = self.gds_validate_string(affinity_, node, 'affinity')
            self.affinity = affinity_
# end class VmPlacementPolicy


class TimeZone(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, utc_offset=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.utc_offset = utc_offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeZone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeZone.subclass:
            return TimeZone.subclass(*args_, **kwargs_)
        else:
            return TimeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_utc_offset(self):
        return self.utc_offset
    def set_utc_offset(self, utc_offset):
        self.utc_offset = utc_offset
    utc_offsetProp = property(get_utc_offset, set_utc_offset)
    def hasContent_(self):
        if (
            self.name is not None or
            self.utc_offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='TimeZone', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeZone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='TimeZone', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeZone'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TimeZone', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.utc_offset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sutc_offset>%s</%sutc_offset>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.utc_offset), input_name='utc_offset')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'utc_offset':
            utc_offset_ = child_.text
            utc_offset_ = self.gds_validate_string(utc_offset_, node, 'utc_offset')
            self.utc_offset = utc_offset_
# end class TimeZone


class Kernel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.version = version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Kernel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Kernel.subclass:
            return Kernel.subclass(*args_, **kwargs_)
        else:
            return Kernel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def hasContent_(self):
        if (
            self.version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='Kernel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Kernel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Kernel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='Kernel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Kernel'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='Kernel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
# end class Kernel


class GuestOperatingSystem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, architecture=None, codename=None, distribution=None, kernel=None, family=None, version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.architecture = architecture
        self.codename = codename
        self.distribution = distribution
        self.kernel = kernel
        self.family = family
        self.version = version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GuestOperatingSystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GuestOperatingSystem.subclass:
            return GuestOperatingSystem.subclass(*args_, **kwargs_)
        else:
            return GuestOperatingSystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_architecture(self):
        return self.architecture
    def set_architecture(self, architecture):
        self.architecture = architecture
    architectureProp = property(get_architecture, set_architecture)
    def get_codename(self):
        return self.codename
    def set_codename(self, codename):
        self.codename = codename
    codenameProp = property(get_codename, set_codename)
    def get_distribution(self):
        return self.distribution
    def set_distribution(self, distribution):
        self.distribution = distribution
    distributionProp = property(get_distribution, set_distribution)
    def get_kernel(self):
        return self.kernel
    def set_kernel(self, kernel):
        self.kernel = kernel
    kernelProp = property(get_kernel, set_kernel)
    def get_family(self):
        return self.family
    def set_family(self, family):
        self.family = family
    familyProp = property(get_family, set_family)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def hasContent_(self):
        if (
            self.architecture is not None or
            self.codename is not None or
            self.distribution is not None or
            self.kernel is not None or
            self.family is not None or
            self.version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='GuestOperatingSystem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GuestOperatingSystem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GuestOperatingSystem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='GuestOperatingSystem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GuestOperatingSystem'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='GuestOperatingSystem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.architecture is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarchitecture>%s</%sarchitecture>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.architecture), input_name='architecture')), namespaceprefix_ , eol_))
        if self.codename is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodename>%s</%scodename>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.codename), input_name='codename')), namespaceprefix_ , eol_))
        if self.distribution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdistribution>%s</%sdistribution>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.distribution), input_name='distribution')), namespaceprefix_ , eol_))
        if self.kernel is not None:
            self.kernel.export(outfile, level, namespaceprefix_, name_='kernel', pretty_print=pretty_print)
        if self.family is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfamily>%s</%sfamily>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.family), input_name='family')), namespaceprefix_ , eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'architecture':
            architecture_ = child_.text
            architecture_ = self.gds_validate_string(architecture_, node, 'architecture')
            self.architecture = architecture_
        elif nodeName_ == 'codename':
            codename_ = child_.text
            codename_ = self.gds_validate_string(codename_, node, 'codename')
            self.codename = codename_
        elif nodeName_ == 'distribution':
            distribution_ = child_.text
            distribution_ = self.gds_validate_string(distribution_, node, 'distribution')
            self.distribution = distribution_
        elif nodeName_ == 'kernel':
            obj_ = Kernel.factory(parent_object_=self)
            obj_.build(child_)
            self.kernel = obj_
            obj_.original_tagname_ = 'kernel'
        elif nodeName_ == 'family':
            family_ = child_.text
            family_ = self.gds_validate_string(family_, node, 'family')
            self.family = family_
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
# end class GuestOperatingSystem


class GuestInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ips=None, fqdn=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ips = ips
        self.fqdn = fqdn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GuestInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GuestInfo.subclass:
            return GuestInfo.subclass(*args_, **kwargs_)
        else:
            return GuestInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ips(self):
        return self.ips
    def set_ips(self, ips):
        self.ips = ips
    ipsProp = property(get_ips, set_ips)
    def get_fqdn(self):
        return self.fqdn
    def set_fqdn(self, fqdn):
        self.fqdn = fqdn
    fqdnProp = property(get_fqdn, set_fqdn)
    def hasContent_(self):
        if (
            self.ips is not None or
            self.fqdn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='GuestInfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GuestInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GuestInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='GuestInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GuestInfo'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='GuestInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ips is not None:
            self.ips.export(outfile, level, namespaceprefix_, name_='ips', pretty_print=pretty_print)
        if self.fqdn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfqdn>%s</%sfqdn>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fqdn), input_name='fqdn')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ips':
            obj_ = IPs.factory(parent_object_=self)
            obj_.build(child_)
            self.ips = obj_
            obj_.original_tagname_ = 'ips'
        elif nodeName_ == 'fqdn':
            fqdn_ = child_.text
            fqdn_ = self.gds_validate_string(fqdn_, node, 'fqdn')
            self.fqdn = fqdn_
# end class GuestInfo


class SerialNumber(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, policy=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.policy = policy
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SerialNumber)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SerialNumber.subclass:
            return SerialNumber.subclass(*args_, **kwargs_)
        else:
            return SerialNumber(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_policy(self):
        return self.policy
    def set_policy(self, policy):
        self.policy = policy
    policyProp = property(get_policy, set_policy)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def hasContent_(self):
        if (
            self.policy is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='serial_number', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serial_number')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='serial_number')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='serial_number', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='serial_number'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='serial_number', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolicy>%s</%spolicy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.policy), input_name='policy')), namespaceprefix_ , eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'policy':
            policy_ = child_.text
            policy_ = self.gds_validate_string(policy_, node, 'policy')
            self.policy = policy_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
# end class SerialNumber


class MigrationOptions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, auto_converge=None, compressed=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.auto_converge = auto_converge
        self.compressed = compressed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MigrationOptions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MigrationOptions.subclass:
            return MigrationOptions.subclass(*args_, **kwargs_)
        else:
            return MigrationOptions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_auto_converge(self):
        return self.auto_converge
    def set_auto_converge(self, auto_converge):
        self.auto_converge = auto_converge
    auto_convergeProp = property(get_auto_converge, set_auto_converge)
    def get_compressed(self):
        return self.compressed
    def set_compressed(self, compressed):
        self.compressed = compressed
    compressedProp = property(get_compressed, set_compressed)
    def hasContent_(self):
        if (
            self.auto_converge is not None or
            self.compressed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='migration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('migration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='migration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='migration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='migration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='migration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.auto_converge is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto_converge>%s</%sauto_converge>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.auto_converge), input_name='auto_converge')), namespaceprefix_ , eol_))
        if self.compressed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scompressed>%s</%scompressed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.compressed), input_name='compressed')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'auto_converge':
            auto_converge_ = child_.text
            auto_converge_ = self.gds_validate_string(auto_converge_, node, 'auto_converge')
            self.auto_converge = auto_converge_
        elif nodeName_ == 'compressed':
            compressed_ = child_.text
            compressed_ = self.gds_validate_string(compressed_, node, 'compressed')
            self.compressed = compressed_
# end class MigrationOptions


class IO(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, threads=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.threads = threads
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IO.subclass:
            return IO.subclass(*args_, **kwargs_)
        else:
            return IO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_threads(self):
        return self.threads
    def set_threads(self, threads):
        self.threads = threads
    threadsProp = property(get_threads, set_threads)
    def hasContent_(self):
        if (
            self.threads is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='io', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('io')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='io')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='io', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='io'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='io', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.threads is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthreads>%s</%sthreads>%s' % (namespaceprefix_ , self.gds_format_integer(self.threads, input_name='threads'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'threads' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'threads')
            self.threads = ival_
# end class IO


class VmBase(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, status=None, memory=None, cpu=None, cpu_shares=None, bios=None, os=None, cluster=None, storage_domain=None, creation_time=None, origin=None, stateless=None, delete_protected=None, high_availability=None, display=None, sso=None, rng_device=None, console=None, timezone=None, domain=None, usb=None, soundcard_enabled=None, tunnel_migration=None, migration_downtime=None, virtio_scsi=None, serial_number=None, start_paused=None, cpu_profile=None, migration=None, io=None, custom_properties=None, custom_emulated_machine=None, custom_cpu_model=None, time_zone=None, small_icon=None, large_icon=None, memory_policy=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VmBase, self).__init__(actions, href, id, name, description, comment, creation_status, link, extensiontype_,  **kwargs_)
        self.type_ = type_
        self.status = status
        self.memory = memory
        self.cpu = cpu
        self.cpu_shares = cpu_shares
        self.bios = bios
        self.os = os
        self.cluster = cluster
        self.storage_domain = storage_domain
        if isinstance(creation_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creation_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creation_time
        self.creation_time = initvalue_
        self.origin = origin
        self.stateless = stateless
        self.delete_protected = delete_protected
        self.high_availability = high_availability
        self.display = display
        self.sso = sso
        self.rng_device = rng_device
        self.console = console
        self.timezone = timezone
        self.domain = domain
        self.usb = usb
        self.soundcard_enabled = soundcard_enabled
        self.tunnel_migration = tunnel_migration
        self.migration_downtime = migration_downtime
        self.virtio_scsi = virtio_scsi
        self.serial_number = serial_number
        self.start_paused = start_paused
        self.cpu_profile = cpu_profile
        self.migration = migration
        self.io = io
        self.custom_properties = custom_properties
        self.custom_emulated_machine = custom_emulated_machine
        self.custom_cpu_model = custom_cpu_model
        self.time_zone = time_zone
        self.small_icon = small_icon
        self.large_icon = large_icon
        self.memory_policy = memory_policy
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmBase.subclass:
            return VmBase.subclass(*args_, **kwargs_)
        else:
            return VmBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_memory(self):
        return self.memory
    def set_memory(self, memory):
        self.memory = memory
    memoryProp = property(get_memory, set_memory)
    def get_cpu(self):
        return self.cpu
    def set_cpu(self, cpu):
        self.cpu = cpu
    cpuProp = property(get_cpu, set_cpu)
    def get_cpu_shares(self):
        return self.cpu_shares
    def set_cpu_shares(self, cpu_shares):
        self.cpu_shares = cpu_shares
    cpu_sharesProp = property(get_cpu_shares, set_cpu_shares)
    def get_bios(self):
        return self.bios
    def set_bios(self, bios):
        self.bios = bios
    biosProp = property(get_bios, set_bios)
    def get_os(self):
        return self.os
    def set_os(self, os):
        self.os = os
    osProp = property(get_os, set_os)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_creation_time(self):
        return self.creation_time
    def set_creation_time(self, creation_time):
        self.creation_time = creation_time
    creation_timeProp = property(get_creation_time, set_creation_time)
    def get_origin(self):
        return self.origin
    def set_origin(self, origin):
        self.origin = origin
    originProp = property(get_origin, set_origin)
    def get_stateless(self):
        return self.stateless
    def set_stateless(self, stateless):
        self.stateless = stateless
    statelessProp = property(get_stateless, set_stateless)
    def get_delete_protected(self):
        return self.delete_protected
    def set_delete_protected(self, delete_protected):
        self.delete_protected = delete_protected
    delete_protectedProp = property(get_delete_protected, set_delete_protected)
    def get_high_availability(self):
        return self.high_availability
    def set_high_availability(self, high_availability):
        self.high_availability = high_availability
    high_availabilityProp = property(get_high_availability, set_high_availability)
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    displayProp = property(get_display, set_display)
    def get_sso(self):
        return self.sso
    def set_sso(self, sso):
        self.sso = sso
    ssoProp = property(get_sso, set_sso)
    def get_rng_device(self):
        return self.rng_device
    def set_rng_device(self, rng_device):
        self.rng_device = rng_device
    rng_deviceProp = property(get_rng_device, set_rng_device)
    def get_console(self):
        return self.console
    def set_console(self, console):
        self.console = console
    consoleProp = property(get_console, set_console)
    def get_timezone(self):
        return self.timezone
    def set_timezone(self, timezone):
        self.timezone = timezone
    timezoneProp = property(get_timezone, set_timezone)
    def get_domain(self):
        return self.domain
    def set_domain(self, domain):
        self.domain = domain
    domainProp = property(get_domain, set_domain)
    def get_usb(self):
        return self.usb
    def set_usb(self, usb):
        self.usb = usb
    usbProp = property(get_usb, set_usb)
    def get_soundcard_enabled(self):
        return self.soundcard_enabled
    def set_soundcard_enabled(self, soundcard_enabled):
        self.soundcard_enabled = soundcard_enabled
    soundcard_enabledProp = property(get_soundcard_enabled, set_soundcard_enabled)
    def get_tunnel_migration(self):
        return self.tunnel_migration
    def set_tunnel_migration(self, tunnel_migration):
        self.tunnel_migration = tunnel_migration
    tunnel_migrationProp = property(get_tunnel_migration, set_tunnel_migration)
    def get_migration_downtime(self):
        return self.migration_downtime
    def set_migration_downtime(self, migration_downtime):
        self.migration_downtime = migration_downtime
    migration_downtimeProp = property(get_migration_downtime, set_migration_downtime)
    def get_virtio_scsi(self):
        return self.virtio_scsi
    def set_virtio_scsi(self, virtio_scsi):
        self.virtio_scsi = virtio_scsi
    virtio_scsiProp = property(get_virtio_scsi, set_virtio_scsi)
    def get_serial_number(self):
        return self.serial_number
    def set_serial_number(self, serial_number):
        self.serial_number = serial_number
    serial_numberProp = property(get_serial_number, set_serial_number)
    def get_start_paused(self):
        return self.start_paused
    def set_start_paused(self, start_paused):
        self.start_paused = start_paused
    start_pausedProp = property(get_start_paused, set_start_paused)
    def get_cpu_profile(self):
        return self.cpu_profile
    def set_cpu_profile(self, cpu_profile):
        self.cpu_profile = cpu_profile
    cpu_profileProp = property(get_cpu_profile, set_cpu_profile)
    def get_migration(self):
        return self.migration
    def set_migration(self, migration):
        self.migration = migration
    migrationProp = property(get_migration, set_migration)
    def get_io(self):
        return self.io
    def set_io(self, io):
        self.io = io
    ioProp = property(get_io, set_io)
    def get_custom_properties(self):
        return self.custom_properties
    def set_custom_properties(self, custom_properties):
        self.custom_properties = custom_properties
    custom_propertiesProp = property(get_custom_properties, set_custom_properties)
    def get_custom_emulated_machine(self):
        return self.custom_emulated_machine
    def set_custom_emulated_machine(self, custom_emulated_machine):
        self.custom_emulated_machine = custom_emulated_machine
    custom_emulated_machineProp = property(get_custom_emulated_machine, set_custom_emulated_machine)
    def get_custom_cpu_model(self):
        return self.custom_cpu_model
    def set_custom_cpu_model(self, custom_cpu_model):
        self.custom_cpu_model = custom_cpu_model
    custom_cpu_modelProp = property(get_custom_cpu_model, set_custom_cpu_model)
    def get_time_zone(self):
        return self.time_zone
    def set_time_zone(self, time_zone):
        self.time_zone = time_zone
    time_zoneProp = property(get_time_zone, set_time_zone)
    def get_small_icon(self):
        return self.small_icon
    def set_small_icon(self, small_icon):
        self.small_icon = small_icon
    small_iconProp = property(get_small_icon, set_small_icon)
    def get_large_icon(self):
        return self.large_icon
    def set_large_icon(self, large_icon):
        self.large_icon = large_icon
    large_iconProp = property(get_large_icon, set_large_icon)
    def get_memory_policy(self):
        return self.memory_policy
    def set_memory_policy(self, memory_policy):
        self.memory_policy = memory_policy
    memory_policyProp = property(get_memory_policy, set_memory_policy)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.status is not None or
            self.memory is not None or
            self.cpu is not None or
            self.cpu_shares is not None or
            self.bios is not None or
            self.os is not None or
            self.cluster is not None or
            self.storage_domain is not None or
            self.creation_time is not None or
            self.origin is not None or
            self.stateless is not None or
            self.delete_protected is not None or
            self.high_availability is not None or
            self.display is not None or
            self.sso is not None or
            self.rng_device is not None or
            self.console is not None or
            self.timezone is not None or
            self.domain is not None or
            self.usb is not None or
            self.soundcard_enabled is not None or
            self.tunnel_migration is not None or
            self.migration_downtime is not None or
            self.virtio_scsi is not None or
            self.serial_number is not None or
            self.start_paused is not None or
            self.cpu_profile is not None or
            self.migration is not None or
            self.io is not None or
            self.custom_properties is not None or
            self.custom_emulated_machine is not None or
            self.custom_cpu_model is not None or
            self.time_zone is not None or
            self.small_icon is not None or
            self.large_icon is not None or
            self.memory_policy is not None or
            super(VmBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='VmBase', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VmBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VmBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='VmBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VmBase'):
        super(VmBase, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VmBase')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='VmBase', fromsubclass_=False, pretty_print=True):
        super(VmBase, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.memory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemory>%s</%smemory>%s' % (namespaceprefix_ , self.gds_format_integer(self.memory, input_name='memory'), namespaceprefix_ , eol_))
        if self.cpu is not None:
            self.cpu.export(outfile, level, namespaceprefix_, name_='cpu', pretty_print=pretty_print)
        if self.cpu_shares is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpu_shares>%s</%scpu_shares>%s' % (namespaceprefix_ , self.gds_format_integer(self.cpu_shares, input_name='cpu_shares'), namespaceprefix_ , eol_))
        if self.bios is not None:
            self.bios.export(outfile, level, namespaceprefix_, name_='bios', pretty_print=pretty_print)
        if self.os is not None:
            self.os.export(outfile, level, namespaceprefix_, name_='os', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.creation_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screation_time>%s</%screation_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.creation_time, input_name='creation_time'), namespaceprefix_ , eol_))
        if self.origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorigin>%s</%sorigin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.origin), input_name='origin')), namespaceprefix_ , eol_))
        if self.stateless is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstateless>%s</%sstateless>%s' % (namespaceprefix_ , self.gds_format_boolean(self.stateless, input_name='stateless'), namespaceprefix_ , eol_))
        if self.delete_protected is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdelete_protected>%s</%sdelete_protected>%s' % (namespaceprefix_ , self.gds_format_boolean(self.delete_protected, input_name='delete_protected'), namespaceprefix_ , eol_))
        if self.high_availability is not None:
            self.high_availability.export(outfile, level, namespaceprefix_, name_='high_availability', pretty_print=pretty_print)
        if self.display is not None:
            self.display.export(outfile, level, namespaceprefix_, name_='display', pretty_print=pretty_print)
        if self.sso is not None:
            self.sso.export(outfile, level, namespaceprefix_, name_='sso', pretty_print=pretty_print)
        if self.rng_device is not None:
            self.rng_device.export(outfile, level, namespaceprefix_, name_='rng_device', pretty_print=pretty_print)
        if self.console is not None:
            self.console.export(outfile, level, namespaceprefix_, name_='console', pretty_print=pretty_print)
        if self.timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stimezone>%s</%stimezone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.timezone), input_name='timezone')), namespaceprefix_ , eol_))
        if self.domain is not None:
            self.domain.export(outfile, level, namespaceprefix_, name_='domain', pretty_print=pretty_print)
        if self.usb is not None:
            self.usb.export(outfile, level, namespaceprefix_, name_='usb', pretty_print=pretty_print)
        if self.soundcard_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoundcard_enabled>%s</%ssoundcard_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.soundcard_enabled, input_name='soundcard_enabled'), namespaceprefix_ , eol_))
        if self.tunnel_migration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stunnel_migration>%s</%stunnel_migration>%s' % (namespaceprefix_ , self.gds_format_boolean(self.tunnel_migration, input_name='tunnel_migration'), namespaceprefix_ , eol_))
        if self.migration_downtime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smigration_downtime>%s</%smigration_downtime>%s' % (namespaceprefix_ , self.gds_format_integer(self.migration_downtime, input_name='migration_downtime'), namespaceprefix_ , eol_))
        if self.virtio_scsi is not None:
            self.virtio_scsi.export(outfile, level, namespaceprefix_, name_='virtio_scsi', pretty_print=pretty_print)
        if self.serial_number is not None:
            self.serial_number.export(outfile, level, namespaceprefix_, name_='serial_number', pretty_print=pretty_print)
        if self.start_paused is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart_paused>%s</%sstart_paused>%s' % (namespaceprefix_ , self.gds_format_boolean(self.start_paused, input_name='start_paused'), namespaceprefix_ , eol_))
        if self.cpu_profile is not None:
            self.cpu_profile.export(outfile, level, namespaceprefix_, name_='cpu_profile', pretty_print=pretty_print)
        if self.migration is not None:
            self.migration.export(outfile, level, namespaceprefix_, name_='migration', pretty_print=pretty_print)
        if self.io is not None:
            self.io.export(outfile, level, namespaceprefix_, name_='io', pretty_print=pretty_print)
        if self.custom_properties is not None:
            self.custom_properties.export(outfile, level, namespaceprefix_, name_='custom_properties', pretty_print=pretty_print)
        if self.custom_emulated_machine is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustom_emulated_machine>%s</%scustom_emulated_machine>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.custom_emulated_machine), input_name='custom_emulated_machine')), namespaceprefix_ , eol_))
        if self.custom_cpu_model is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustom_cpu_model>%s</%scustom_cpu_model>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.custom_cpu_model), input_name='custom_cpu_model')), namespaceprefix_ , eol_))
        if self.time_zone is not None:
            self.time_zone.export(outfile, level, namespaceprefix_, name_='time_zone', pretty_print=pretty_print)
        if self.small_icon is not None:
            self.small_icon.export(outfile, level, namespaceprefix_, name_='small_icon', pretty_print=pretty_print)
        if self.large_icon is not None:
            self.large_icon.export(outfile, level, namespaceprefix_, name_='large_icon', pretty_print=pretty_print)
        if self.memory_policy is not None:
            self.memory_policy.export(outfile, level, namespaceprefix_, name_='memory_policy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(VmBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'memory' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memory')
            self.memory = ival_
        elif nodeName_ == 'cpu':
            obj_ = CPU.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu = obj_
            obj_.original_tagname_ = 'cpu'
        elif nodeName_ == 'cpu_shares' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cpu_shares')
            self.cpu_shares = ival_
        elif nodeName_ == 'bios':
            obj_ = Bios.factory(parent_object_=self)
            obj_.build(child_)
            self.bios = obj_
            obj_.original_tagname_ = 'bios'
        elif nodeName_ == 'os':
            obj_ = OperatingSystem.factory(parent_object_=self)
            obj_.build(child_)
            self.os = obj_
            obj_.original_tagname_ = 'os'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'creation_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.creation_time = dval_
        elif nodeName_ == 'origin':
            origin_ = child_.text
            origin_ = self.gds_validate_string(origin_, node, 'origin')
            self.origin = origin_
        elif nodeName_ == 'stateless':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'stateless')
            self.stateless = ival_
        elif nodeName_ == 'delete_protected':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'delete_protected')
            self.delete_protected = ival_
        elif nodeName_ == 'high_availability':
            obj_ = HighAvailability.factory(parent_object_=self)
            obj_.build(child_)
            self.high_availability = obj_
            obj_.original_tagname_ = 'high_availability'
        elif nodeName_ == 'display':
            obj_ = Display.factory(parent_object_=self)
            obj_.build(child_)
            self.display = obj_
            obj_.original_tagname_ = 'display'
        elif nodeName_ == 'sso':
            obj_ = Sso.factory(parent_object_=self)
            obj_.build(child_)
            self.sso = obj_
            obj_.original_tagname_ = 'sso'
        elif nodeName_ == 'rng_device':
            obj_ = RngDevice.factory(parent_object_=self)
            obj_.build(child_)
            self.rng_device = obj_
            obj_.original_tagname_ = 'rng_device'
        elif nodeName_ == 'console':
            obj_ = Console.factory(parent_object_=self)
            obj_.build(child_)
            self.console = obj_
            obj_.original_tagname_ = 'console'
        elif nodeName_ == 'timezone':
            timezone_ = child_.text
            timezone_ = self.gds_validate_string(timezone_, node, 'timezone')
            self.timezone = timezone_
        elif nodeName_ == 'domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.domain = obj_
            obj_.original_tagname_ = 'domain'
        elif nodeName_ == 'usb':
            obj_ = Usb.factory(parent_object_=self)
            obj_.build(child_)
            self.usb = obj_
            obj_.original_tagname_ = 'usb'
        elif nodeName_ == 'soundcard_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'soundcard_enabled')
            self.soundcard_enabled = ival_
        elif nodeName_ == 'tunnel_migration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tunnel_migration')
            self.tunnel_migration = ival_
        elif nodeName_ == 'migration_downtime' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'migration_downtime')
            self.migration_downtime = ival_
        elif nodeName_ == 'virtio_scsi':
            obj_ = VirtIO_SCSI.factory(parent_object_=self)
            obj_.build(child_)
            self.virtio_scsi = obj_
            obj_.original_tagname_ = 'virtio_scsi'
        elif nodeName_ == 'serial_number':
            obj_ = SerialNumber.factory(parent_object_=self)
            obj_.build(child_)
            self.serial_number = obj_
            obj_.original_tagname_ = 'serial_number'
        elif nodeName_ == 'start_paused':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'start_paused')
            self.start_paused = ival_
        elif nodeName_ == 'cpu_profile':
            obj_ = CpuProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu_profile = obj_
            obj_.original_tagname_ = 'cpu_profile'
        elif nodeName_ == 'migration':
            obj_ = MigrationOptions.factory(parent_object_=self)
            obj_.build(child_)
            self.migration = obj_
            obj_.original_tagname_ = 'migration'
        elif nodeName_ == 'io':
            obj_ = IO.factory(parent_object_=self)
            obj_.build(child_)
            self.io = obj_
            obj_.original_tagname_ = 'io'
        elif nodeName_ == 'custom_properties':
            obj_ = CustomProperties.factory(parent_object_=self)
            obj_.build(child_)
            self.custom_properties = obj_
            obj_.original_tagname_ = 'custom_properties'
        elif nodeName_ == 'custom_emulated_machine':
            custom_emulated_machine_ = child_.text
            custom_emulated_machine_ = self.gds_validate_string(custom_emulated_machine_, node, 'custom_emulated_machine')
            self.custom_emulated_machine = custom_emulated_machine_
        elif nodeName_ == 'custom_cpu_model':
            custom_cpu_model_ = child_.text
            custom_cpu_model_ = self.gds_validate_string(custom_cpu_model_, node, 'custom_cpu_model')
            self.custom_cpu_model = custom_cpu_model_
        elif nodeName_ == 'time_zone':
            obj_ = TimeZone.factory(parent_object_=self)
            obj_.build(child_)
            self.time_zone = obj_
            obj_.original_tagname_ = 'time_zone'
        elif nodeName_ == 'small_icon':
            obj_ = Icon.factory(parent_object_=self)
            obj_.build(child_)
            self.small_icon = obj_
            obj_.original_tagname_ = 'small_icon'
        elif nodeName_ == 'large_icon':
            obj_ = Icon.factory(parent_object_=self)
            obj_.build(child_)
            self.large_icon = obj_
            obj_.original_tagname_ = 'large_icon'
        elif nodeName_ == 'memory_policy':
            obj_ = MemoryPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.memory_policy = obj_
            obj_.original_tagname_ = 'memory_policy'
        super(VmBase, self).buildChildren(child_, node, nodeName_, True)
# end class VmBase


class VM(VmBase):
    subclass = None
    superclass = VmBase
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, status=None, memory=None, cpu=None, cpu_shares=None, bios=None, os=None, cluster=None, storage_domain=None, creation_time=None, origin=None, stateless=None, delete_protected=None, high_availability=None, display=None, sso=None, rng_device=None, console=None, timezone=None, domain=None, usb=None, soundcard_enabled=None, tunnel_migration=None, migration_downtime=None, virtio_scsi=None, serial_number=None, start_paused=None, cpu_profile=None, migration=None, io=None, custom_properties=None, custom_emulated_machine=None, custom_cpu_model=None, time_zone=None, small_icon=None, large_icon=None, memory_policy=None, stop_reason=None, host=None, template=None, instance_type=None, start_time=None, stop_time=None, run_once=None, payloads=None, statistics=None, disks=None, initialization=None, nics=None, tags=None, snapshots=None, placement_policy=None, guest_info=None, quota=None, vmpool=None, cdroms=None, floppies=None, reported_devices=None, watchdogs=None, use_latest_template_version=None, next_run_configuration_exists=None, numa_tune_mode=None, permissions=None, external_host_provider=None, katello_errata=None, guest_time_zone=None, guest_operating_system=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VM, self).__init__(actions, href, id, name, description, comment, creation_status, link, type_, status, memory, cpu, cpu_shares, bios, os, cluster, storage_domain, creation_time, origin, stateless, delete_protected, high_availability, display, sso, rng_device, console, timezone, domain, usb, soundcard_enabled, tunnel_migration, migration_downtime, virtio_scsi, serial_number, start_paused, cpu_profile, migration, io, custom_properties, custom_emulated_machine, custom_cpu_model, time_zone, small_icon, large_icon, memory_policy, extensiontype_,  **kwargs_)
        self.stop_reason = stop_reason
        self.host = host
        self.template = template
        self.instance_type = instance_type
        if isinstance(start_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(start_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = start_time
        self.start_time = initvalue_
        if isinstance(stop_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(stop_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = stop_time
        self.stop_time = initvalue_
        self.run_once = run_once
        self.payloads = payloads
        self.statistics = statistics
        self.disks = disks
        self.initialization = initialization
        self.nics = nics
        self.tags = tags
        self.snapshots = snapshots
        self.placement_policy = placement_policy
        self.guest_info = guest_info
        self.quota = quota
        self.vmpool = vmpool
        self.cdroms = cdroms
        self.floppies = floppies
        self.reported_devices = reported_devices
        self.watchdogs = watchdogs
        self.use_latest_template_version = use_latest_template_version
        self.next_run_configuration_exists = next_run_configuration_exists
        self.numa_tune_mode = numa_tune_mode
        self.permissions = permissions
        self.external_host_provider = external_host_provider
        self.katello_errata = katello_errata
        self.guest_time_zone = guest_time_zone
        self.guest_operating_system = guest_operating_system
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VM)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VM.subclass:
            return VM.subclass(*args_, **kwargs_)
        else:
            return VM(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stop_reason(self):
        return self.stop_reason
    def set_stop_reason(self, stop_reason):
        self.stop_reason = stop_reason
    stop_reasonProp = property(get_stop_reason, set_stop_reason)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_instance_type(self):
        return self.instance_type
    def set_instance_type(self, instance_type):
        self.instance_type = instance_type
    instance_typeProp = property(get_instance_type, set_instance_type)
    def get_start_time(self):
        return self.start_time
    def set_start_time(self, start_time):
        self.start_time = start_time
    start_timeProp = property(get_start_time, set_start_time)
    def get_stop_time(self):
        return self.stop_time
    def set_stop_time(self, stop_time):
        self.stop_time = stop_time
    stop_timeProp = property(get_stop_time, set_stop_time)
    def get_run_once(self):
        return self.run_once
    def set_run_once(self, run_once):
        self.run_once = run_once
    run_onceProp = property(get_run_once, set_run_once)
    def get_payloads(self):
        return self.payloads
    def set_payloads(self, payloads):
        self.payloads = payloads
    payloadsProp = property(get_payloads, set_payloads)
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    statisticsProp = property(get_statistics, set_statistics)
    def get_disks(self):
        return self.disks
    def set_disks(self, disks):
        self.disks = disks
    disksProp = property(get_disks, set_disks)
    def get_initialization(self):
        return self.initialization
    def set_initialization(self, initialization):
        self.initialization = initialization
    initializationProp = property(get_initialization, set_initialization)
    def get_nics(self):
        return self.nics
    def set_nics(self, nics):
        self.nics = nics
    nicsProp = property(get_nics, set_nics)
    def get_tags(self):
        return self.tags
    def set_tags(self, tags):
        self.tags = tags
    tagsProp = property(get_tags, set_tags)
    def get_snapshots(self):
        return self.snapshots
    def set_snapshots(self, snapshots):
        self.snapshots = snapshots
    snapshotsProp = property(get_snapshots, set_snapshots)
    def get_placement_policy(self):
        return self.placement_policy
    def set_placement_policy(self, placement_policy):
        self.placement_policy = placement_policy
    placement_policyProp = property(get_placement_policy, set_placement_policy)
    def get_guest_info(self):
        return self.guest_info
    def set_guest_info(self, guest_info):
        self.guest_info = guest_info
    guest_infoProp = property(get_guest_info, set_guest_info)
    def get_quota(self):
        return self.quota
    def set_quota(self, quota):
        self.quota = quota
    quotaProp = property(get_quota, set_quota)
    def get_vmpool(self):
        return self.vmpool
    def set_vmpool(self, vmpool):
        self.vmpool = vmpool
    vmpoolProp = property(get_vmpool, set_vmpool)
    def get_cdroms(self):
        return self.cdroms
    def set_cdroms(self, cdroms):
        self.cdroms = cdroms
    cdromsProp = property(get_cdroms, set_cdroms)
    def get_floppies(self):
        return self.floppies
    def set_floppies(self, floppies):
        self.floppies = floppies
    floppiesProp = property(get_floppies, set_floppies)
    def get_reported_devices(self):
        return self.reported_devices
    def set_reported_devices(self, reported_devices):
        self.reported_devices = reported_devices
    reported_devicesProp = property(get_reported_devices, set_reported_devices)
    def get_watchdogs(self):
        return self.watchdogs
    def set_watchdogs(self, watchdogs):
        self.watchdogs = watchdogs
    watchdogsProp = property(get_watchdogs, set_watchdogs)
    def get_use_latest_template_version(self):
        return self.use_latest_template_version
    def set_use_latest_template_version(self, use_latest_template_version):
        self.use_latest_template_version = use_latest_template_version
    use_latest_template_versionProp = property(get_use_latest_template_version, set_use_latest_template_version)
    def get_next_run_configuration_exists(self):
        return self.next_run_configuration_exists
    def set_next_run_configuration_exists(self, next_run_configuration_exists):
        self.next_run_configuration_exists = next_run_configuration_exists
    next_run_configuration_existsProp = property(get_next_run_configuration_exists, set_next_run_configuration_exists)
    def get_numa_tune_mode(self):
        return self.numa_tune_mode
    def set_numa_tune_mode(self, numa_tune_mode):
        self.numa_tune_mode = numa_tune_mode
    numa_tune_modeProp = property(get_numa_tune_mode, set_numa_tune_mode)
    def get_permissions(self):
        return self.permissions
    def set_permissions(self, permissions):
        self.permissions = permissions
    permissionsProp = property(get_permissions, set_permissions)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def get_katello_errata(self):
        return self.katello_errata
    def set_katello_errata(self, katello_errata):
        self.katello_errata = katello_errata
    katello_errataProp = property(get_katello_errata, set_katello_errata)
    def get_guest_time_zone(self):
        return self.guest_time_zone
    def set_guest_time_zone(self, guest_time_zone):
        self.guest_time_zone = guest_time_zone
    guest_time_zoneProp = property(get_guest_time_zone, set_guest_time_zone)
    def get_guest_operating_system(self):
        return self.guest_operating_system
    def set_guest_operating_system(self, guest_operating_system):
        self.guest_operating_system = guest_operating_system
    guest_operating_systemProp = property(get_guest_operating_system, set_guest_operating_system)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.stop_reason is not None or
            self.host is not None or
            self.template is not None or
            self.instance_type is not None or
            self.start_time is not None or
            self.stop_time is not None or
            self.run_once is not None or
            self.payloads is not None or
            self.statistics is not None or
            self.disks is not None or
            self.initialization is not None or
            self.nics is not None or
            self.tags is not None or
            self.snapshots is not None or
            self.placement_policy is not None or
            self.guest_info is not None or
            self.quota is not None or
            self.vmpool is not None or
            self.cdroms is not None or
            self.floppies is not None or
            self.reported_devices is not None or
            self.watchdogs is not None or
            self.use_latest_template_version is not None or
            self.next_run_configuration_exists is not None or
            self.numa_tune_mode is not None or
            self.permissions is not None or
            self.external_host_provider is not None or
            self.katello_errata is not None or
            self.guest_time_zone is not None or
            self.guest_operating_system is not None or
            super(VM, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm'):
        super(VM, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm', fromsubclass_=False, pretty_print=True):
        super(VM, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.stop_reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstop_reason>%s</%sstop_reason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.stop_reason), input_name='stop_reason')), namespaceprefix_ , eol_))
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.instance_type is not None:
            self.instance_type.export(outfile, level, namespaceprefix_, name_='instance_type', pretty_print=pretty_print)
        if self.start_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart_time>%s</%sstart_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.start_time, input_name='start_time'), namespaceprefix_ , eol_))
        if self.stop_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstop_time>%s</%sstop_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.stop_time, input_name='stop_time'), namespaceprefix_ , eol_))
        if self.run_once is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srun_once>%s</%srun_once>%s' % (namespaceprefix_ , self.gds_format_boolean(self.run_once, input_name='run_once'), namespaceprefix_ , eol_))
        if self.payloads is not None:
            self.payloads.export(outfile, level, namespaceprefix_, name_='payloads', pretty_print=pretty_print)
        if self.statistics is not None:
            self.statistics.export(outfile, level, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
        if self.disks is not None:
            self.disks.export(outfile, level, namespaceprefix_, name_='disks', pretty_print=pretty_print)
        if self.initialization is not None:
            self.initialization.export(outfile, level, namespaceprefix_, name_='initialization', pretty_print=pretty_print)
        if self.nics is not None:
            self.nics.export(outfile, level, namespaceprefix_, name_='nics', pretty_print=pretty_print)
        if self.tags is not None:
            self.tags.export(outfile, level, namespaceprefix_, name_='tags', pretty_print=pretty_print)
        if self.snapshots is not None:
            self.snapshots.export(outfile, level, namespaceprefix_, name_='snapshots', pretty_print=pretty_print)
        if self.placement_policy is not None:
            self.placement_policy.export(outfile, level, namespaceprefix_, name_='placement_policy', pretty_print=pretty_print)
        if self.guest_info is not None:
            self.guest_info.export(outfile, level, namespaceprefix_, name_='guest_info', pretty_print=pretty_print)
        if self.quota is not None:
            self.quota.export(outfile, level, namespaceprefix_, name_='quota', pretty_print=pretty_print)
        if self.vmpool is not None:
            self.vmpool.export(outfile, level, namespaceprefix_, name_='vmpool', pretty_print=pretty_print)
        if self.cdroms is not None:
            self.cdroms.export(outfile, level, namespaceprefix_, name_='cdroms', pretty_print=pretty_print)
        if self.floppies is not None:
            self.floppies.export(outfile, level, namespaceprefix_, name_='floppies', pretty_print=pretty_print)
        if self.reported_devices is not None:
            self.reported_devices.export(outfile, level, namespaceprefix_, name_='reported_devices', pretty_print=pretty_print)
        if self.watchdogs is not None:
            self.watchdogs.export(outfile, level, namespaceprefix_, name_='watchdogs', pretty_print=pretty_print)
        if self.use_latest_template_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suse_latest_template_version>%s</%suse_latest_template_version>%s' % (namespaceprefix_ , self.gds_format_boolean(self.use_latest_template_version, input_name='use_latest_template_version'), namespaceprefix_ , eol_))
        if self.next_run_configuration_exists is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snext_run_configuration_exists>%s</%snext_run_configuration_exists>%s' % (namespaceprefix_ , self.gds_format_boolean(self.next_run_configuration_exists, input_name='next_run_configuration_exists'), namespaceprefix_ , eol_))
        if self.numa_tune_mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snuma_tune_mode>%s</%snuma_tune_mode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.numa_tune_mode), input_name='numa_tune_mode')), namespaceprefix_ , eol_))
        if self.permissions is not None:
            self.permissions.export(outfile, level, namespaceprefix_, name_='permissions', pretty_print=pretty_print)
        if self.external_host_provider is not None:
            self.external_host_provider.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
        if self.katello_errata is not None:
            self.katello_errata.export(outfile, level, namespaceprefix_, name_='katello_errata', pretty_print=pretty_print)
        if self.guest_time_zone is not None:
            self.guest_time_zone.export(outfile, level, namespaceprefix_, name_='guest_time_zone', pretty_print=pretty_print)
        if self.guest_operating_system is not None:
            self.guest_operating_system.export(outfile, level, namespaceprefix_, name_='guest_operating_system', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(VM, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stop_reason':
            stop_reason_ = child_.text
            stop_reason_ = self.gds_validate_string(stop_reason_, node, 'stop_reason')
            self.stop_reason = stop_reason_
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'instance_type':
            obj_ = InstanceType.factory(parent_object_=self)
            obj_.build(child_)
            self.instance_type = obj_
            obj_.original_tagname_ = 'instance_type'
        elif nodeName_ == 'start_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.start_time = dval_
        elif nodeName_ == 'stop_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.stop_time = dval_
        elif nodeName_ == 'run_once':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'run_once')
            self.run_once = ival_
        elif nodeName_ == 'payloads':
            obj_ = Payloads.factory(parent_object_=self)
            obj_.build(child_)
            self.payloads = obj_
            obj_.original_tagname_ = 'payloads'
        elif nodeName_ == 'statistics':
            obj_ = Statistics.factory(parent_object_=self)
            obj_.build(child_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'disks':
            obj_ = Disks.factory(parent_object_=self)
            obj_.build(child_)
            self.disks = obj_
            obj_.original_tagname_ = 'disks'
        elif nodeName_ == 'initialization':
            obj_ = Initialization.factory(parent_object_=self)
            obj_.build(child_)
            self.initialization = obj_
            obj_.original_tagname_ = 'initialization'
        elif nodeName_ == 'nics':
            obj_ = Nics.factory(parent_object_=self)
            obj_.build(child_)
            self.nics = obj_
            obj_.original_tagname_ = 'nics'
        elif nodeName_ == 'tags':
            obj_ = Tags.factory(parent_object_=self)
            obj_.build(child_)
            self.tags = obj_
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'snapshots':
            obj_ = Snapshots.factory(parent_object_=self)
            obj_.build(child_)
            self.snapshots = obj_
            obj_.original_tagname_ = 'snapshots'
        elif nodeName_ == 'placement_policy':
            obj_ = VmPlacementPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.placement_policy = obj_
            obj_.original_tagname_ = 'placement_policy'
        elif nodeName_ == 'guest_info':
            obj_ = GuestInfo.factory(parent_object_=self)
            obj_.build(child_)
            self.guest_info = obj_
            obj_.original_tagname_ = 'guest_info'
        elif nodeName_ == 'quota':
            obj_ = Quota.factory(parent_object_=self)
            obj_.build(child_)
            self.quota = obj_
            obj_.original_tagname_ = 'quota'
        elif nodeName_ == 'vmpool':
            obj_ = VmPool.factory(parent_object_=self)
            obj_.build(child_)
            self.vmpool = obj_
            obj_.original_tagname_ = 'vmpool'
        elif nodeName_ == 'cdroms':
            obj_ = CdRoms.factory(parent_object_=self)
            obj_.build(child_)
            self.cdroms = obj_
            obj_.original_tagname_ = 'cdroms'
        elif nodeName_ == 'floppies':
            obj_ = Floppies.factory(parent_object_=self)
            obj_.build(child_)
            self.floppies = obj_
            obj_.original_tagname_ = 'floppies'
        elif nodeName_ == 'reported_devices':
            obj_ = ReportedDevices.factory(parent_object_=self)
            obj_.build(child_)
            self.reported_devices = obj_
            obj_.original_tagname_ = 'reported_devices'
        elif nodeName_ == 'watchdogs':
            obj_ = WatchDogs.factory(parent_object_=self)
            obj_.build(child_)
            self.watchdogs = obj_
            obj_.original_tagname_ = 'watchdogs'
        elif nodeName_ == 'use_latest_template_version':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'use_latest_template_version')
            self.use_latest_template_version = ival_
        elif nodeName_ == 'next_run_configuration_exists':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'next_run_configuration_exists')
            self.next_run_configuration_exists = ival_
        elif nodeName_ == 'numa_tune_mode':
            numa_tune_mode_ = child_.text
            numa_tune_mode_ = self.gds_validate_string(numa_tune_mode_, node, 'numa_tune_mode')
            self.numa_tune_mode = numa_tune_mode_
        elif nodeName_ == 'permissions':
            obj_ = Permissions.factory(parent_object_=self)
            obj_.build(child_)
            self.permissions = obj_
            obj_.original_tagname_ = 'permissions'
        elif nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider = obj_
            obj_.original_tagname_ = 'external_host_provider'
        elif nodeName_ == 'katello_errata':
            obj_ = KatelloErrata.factory(parent_object_=self)
            obj_.build(child_)
            self.katello_errata = obj_
            obj_.original_tagname_ = 'katello_errata'
        elif nodeName_ == 'guest_time_zone':
            obj_ = TimeZone.factory(parent_object_=self)
            obj_.build(child_)
            self.guest_time_zone = obj_
            obj_.original_tagname_ = 'guest_time_zone'
        elif nodeName_ == 'guest_operating_system':
            obj_ = GuestOperatingSystem.factory(parent_object_=self)
            obj_.build(child_)
            self.guest_operating_system = obj_
            obj_.original_tagname_ = 'guest_operating_system'
        super(VM, self).buildChildren(child_, node, nodeName_, True)
# end class VM


class VMs(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, vm=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VMs, self).__init__(actions, size, total, active,  **kwargs_)
        if vm is None:
            self.vm = []
        else:
            self.vm = vm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VMs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VMs.subclass:
            return VMs.subclass(*args_, **kwargs_)
        else:
            return VMs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    def add_vm(self, value):
        self.vm.append(value)
    def insert_vm_at(self, index, value):
        self.vm.insert(index, value)
    def replace_vm_at(self, index, value):
        self.vm[index] = value
    vmProp = property(get_vm, set_vm)
    def hasContent_(self):
        if (
            self.vm or
            super(VMs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vms', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vms')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vms'):
        super(VMs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vms')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vms', fromsubclass_=False, pretty_print=True):
        super(VMs, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_ in self.vm:
            vm_.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VMs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm.append(obj_)
            obj_.original_tagname_ = 'vm'
        super(VMs, self).buildChildren(child_, node, nodeName_, True)
# end class VMs


class Icon(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, media_type=None, data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Icon, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.media_type = media_type
        self.data = data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Icon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Icon.subclass:
            return Icon.subclass(*args_, **kwargs_)
        else:
            return Icon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_media_type(self):
        return self.media_type
    def set_media_type(self, media_type):
        self.media_type = media_type
    media_typeProp = property(get_media_type, set_media_type)
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    dataProp = property(get_data, set_data)
    def hasContent_(self):
        if (
            self.media_type is not None or
            self.data is not None or
            super(Icon, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='icon', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('icon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='icon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='icon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='icon'):
        super(Icon, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='icon')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='icon', fromsubclass_=False, pretty_print=True):
        super(Icon, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.media_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smedia_type>%s</%smedia_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.media_type), input_name='media_type')), namespaceprefix_ , eol_))
        if self.data is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata>%s</%sdata>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.data), input_name='data')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Icon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'media_type':
            media_type_ = child_.text
            media_type_ = self.gds_validate_string(media_type_, node, 'media_type')
            self.media_type = media_type_
        elif nodeName_ == 'data':
            data_ = child_.text
            data_ = self.gds_validate_string(data_, node, 'data')
            self.data = data_
        super(Icon, self).buildChildren(child_, node, nodeName_, True)
# end class Icon


class Icons(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, icon=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Icons, self).__init__(actions, size, total, active,  **kwargs_)
        if icon is None:
            self.icon = []
        else:
            self.icon = icon
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Icons)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Icons.subclass:
            return Icons.subclass(*args_, **kwargs_)
        else:
            return Icons(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_icon(self):
        return self.icon
    def set_icon(self, icon):
        self.icon = icon
    def add_icon(self, value):
        self.icon.append(value)
    def insert_icon_at(self, index, value):
        self.icon.insert(index, value)
    def replace_icon_at(self, index, value):
        self.icon[index] = value
    iconProp = property(get_icon, set_icon)
    def hasContent_(self):
        if (
            self.icon or
            super(Icons, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='icons', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('icons')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='icons')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='icons', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='icons'):
        super(Icons, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='icons')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='icons', fromsubclass_=False, pretty_print=True):
        super(Icons, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for icon_ in self.icon:
            icon_.export(outfile, level, namespaceprefix_, name_='icon', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Icons, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'icon':
            obj_ = Icon.factory(parent_object_=self)
            obj_.build(child_)
            self.icon.append(obj_)
            obj_.original_tagname_ = 'icon'
        super(Icons, self).buildChildren(child_, node, nodeName_, True)
# end class Icons


class ReportedDevices(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, reported_device=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ReportedDevices, self).__init__(actions, size, total, active,  **kwargs_)
        if reported_device is None:
            self.reported_device = []
        else:
            self.reported_device = reported_device
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportedDevices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportedDevices.subclass:
            return ReportedDevices.subclass(*args_, **kwargs_)
        else:
            return ReportedDevices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reported_device(self):
        return self.reported_device
    def set_reported_device(self, reported_device):
        self.reported_device = reported_device
    def add_reported_device(self, value):
        self.reported_device.append(value)
    def insert_reported_device_at(self, index, value):
        self.reported_device.insert(index, value)
    def replace_reported_device_at(self, index, value):
        self.reported_device[index] = value
    reported_deviceProp = property(get_reported_device, set_reported_device)
    def hasContent_(self):
        if (
            self.reported_device or
            super(ReportedDevices, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='reported_devices', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reported_devices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reported_devices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='reported_devices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='reported_devices'):
        super(ReportedDevices, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reported_devices')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='reported_devices', fromsubclass_=False, pretty_print=True):
        super(ReportedDevices, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reported_device_ in self.reported_device:
            reported_device_.export(outfile, level, namespaceprefix_, name_='reported_device', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReportedDevices, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reported_device':
            obj_ = ReportedDevice.factory(parent_object_=self)
            obj_.build(child_)
            self.reported_device.append(obj_)
            obj_.original_tagname_ = 'reported_device'
        super(ReportedDevices, self).buildChildren(child_, node, nodeName_, True)
# end class ReportedDevices


class ReportedDevice(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, mac=None, ips=None, vm=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ReportedDevice, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.type_ = type_
        self.mac = mac
        self.ips = ips
        self.vm = vm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportedDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportedDevice.subclass:
            return ReportedDevice.subclass(*args_, **kwargs_)
        else:
            return ReportedDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_mac(self):
        return self.mac
    def set_mac(self, mac):
        self.mac = mac
    macProp = property(get_mac, set_mac)
    def get_ips(self):
        return self.ips
    def set_ips(self, ips):
        self.ips = ips
    ipsProp = property(get_ips, set_ips)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.mac is not None or
            self.ips is not None or
            self.vm is not None or
            super(ReportedDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='reported_device', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reported_device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reported_device')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='reported_device', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='reported_device'):
        super(ReportedDevice, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reported_device')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='reported_device', fromsubclass_=False, pretty_print=True):
        super(ReportedDevice, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.mac is not None:
            self.mac.export(outfile, level, namespaceprefix_, name_='mac', pretty_print=pretty_print)
        if self.ips is not None:
            self.ips.export(outfile, level, namespaceprefix_, name_='ips', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReportedDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'mac':
            obj_ = MAC.factory(parent_object_=self)
            obj_.build(child_)
            self.mac = obj_
            obj_.original_tagname_ = 'mac'
        elif nodeName_ == 'ips':
            obj_ = IPs.factory(parent_object_=self)
            obj_.build(child_)
            self.ips = obj_
            obj_.original_tagname_ = 'ips'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        super(ReportedDevice, self).buildChildren(child_, node, nodeName_, True)
# end class ReportedDevice


class PreviewVMs(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, preview_vm=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PreviewVMs, self).__init__(actions, size, total, active,  **kwargs_)
        if preview_vm is None:
            self.preview_vm = []
        else:
            self.preview_vm = preview_vm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PreviewVMs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PreviewVMs.subclass:
            return PreviewVMs.subclass(*args_, **kwargs_)
        else:
            return PreviewVMs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_preview_vm(self):
        return self.preview_vm
    def set_preview_vm(self, preview_vm):
        self.preview_vm = preview_vm
    def add_preview_vm(self, value):
        self.preview_vm.append(value)
    def insert_preview_vm_at(self, index, value):
        self.preview_vm.insert(index, value)
    def replace_preview_vm_at(self, index, value):
        self.preview_vm[index] = value
    preview_vmProp = property(get_preview_vm, set_preview_vm)
    def hasContent_(self):
        if (
            self.preview_vm or
            super(PreviewVMs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='preview_vms', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('preview_vms')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='preview_vms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='preview_vms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='preview_vms'):
        super(PreviewVMs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='preview_vms')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='preview_vms', fromsubclass_=False, pretty_print=True):
        super(PreviewVMs, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for preview_vm_ in self.preview_vm:
            preview_vm_.export(outfile, level, namespaceprefix_, name_='preview_vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PreviewVMs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'preview_vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.preview_vm.append(obj_)
            obj_.original_tagname_ = 'preview_vm'
        super(PreviewVMs, self).buildChildren(child_, node, nodeName_, True)
# end class PreviewVMs


class VmStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vm_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vm_state is None:
            self.vm_state = []
        else:
            self.vm_state = vm_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmStates.subclass:
            return VmStates.subclass(*args_, **kwargs_)
        else:
            return VmStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm_state(self):
        return self.vm_state
    def set_vm_state(self, vm_state):
        self.vm_state = vm_state
    def add_vm_state(self, value):
        self.vm_state.append(value)
    def insert_vm_state_at(self, index, value):
        self.vm_state.insert(index, value)
    def replace_vm_state_at(self, index, value):
        self.vm_state[index] = value
    vm_stateProp = property(get_vm_state, set_vm_state)
    def hasContent_(self):
        if (
            self.vm_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_state_ in self.vm_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svm_state>%s</%svm_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(vm_state_), input_name='vm_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm_state':
            vm_state_ = child_.text
            vm_state_ = self.gds_validate_string(vm_state_, node, 'vm_state')
            self.vm_state.append(vm_state_)
# end class VmStates


class VmPauseDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vm_pause_detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vm_pause_detail is None:
            self.vm_pause_detail = []
        else:
            self.vm_pause_detail = vm_pause_detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmPauseDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmPauseDetails.subclass:
            return VmPauseDetails.subclass(*args_, **kwargs_)
        else:
            return VmPauseDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm_pause_detail(self):
        return self.vm_pause_detail
    def set_vm_pause_detail(self, vm_pause_detail):
        self.vm_pause_detail = vm_pause_detail
    def add_vm_pause_detail(self, value):
        self.vm_pause_detail.append(value)
    def insert_vm_pause_detail_at(self, index, value):
        self.vm_pause_detail.insert(index, value)
    def replace_vm_pause_detail_at(self, index, value):
        self.vm_pause_detail[index] = value
    vm_pause_detailProp = property(get_vm_pause_detail, set_vm_pause_detail)
    def hasContent_(self):
        if (
            self.vm_pause_detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_pause_details', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_pause_details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_pause_details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_pause_details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_pause_details'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_pause_details', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_pause_detail_ in self.vm_pause_detail:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svm_pause_detail>%s</%svm_pause_detail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(vm_pause_detail_), input_name='vm_pause_detail')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm_pause_detail':
            vm_pause_detail_ = child_.text
            vm_pause_detail_ = self.gds_validate_string(vm_pause_detail_, node, 'vm_pause_detail')
            self.vm_pause_detail.append(vm_pause_detail_)
# end class VmPauseDetails


class PmProxyTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PmProxyTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PmProxyTypes.subclass:
            return PmProxyTypes.subclass(*args_, **kwargs_)
        else:
            return PmProxyTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def add_type(self, value):
        self.type_.append(value)
    def insert_type_at(self, index, value):
        self.type_.insert(index, value)
    def replace_type_at(self, index, value):
        self.type_[index] = value
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.type_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='pm_proxy_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pm_proxy_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pm_proxy_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='pm_proxy_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pm_proxy_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='pm_proxy_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for type_ in self.type_:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(type_), input_name='type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_.append(type_)
# end class PmProxyTypes


class Session(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, vm=None, protocol=None, ip=None, user=None, console_user=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Session, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.vm = vm
        self.protocol = protocol
        self.ip = ip
        self.user = user
        self.console_user = console_user
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Session)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Session.subclass:
            return Session.subclass(*args_, **kwargs_)
        else:
            return Session(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    protocolProp = property(get_protocol, set_protocol)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    ipProp = property(get_ip, set_ip)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_console_user(self):
        return self.console_user
    def set_console_user(self, console_user):
        self.console_user = console_user
    console_userProp = property(get_console_user, set_console_user)
    def hasContent_(self):
        if (
            self.vm is not None or
            self.protocol is not None or
            self.ip is not None or
            self.user is not None or
            self.console_user is not None or
            super(Session, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='session', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('session')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='session')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='session', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='session'):
        super(Session, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='session')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='session', fromsubclass_=False, pretty_print=True):
        super(Session, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.protocol), input_name='protocol')), namespaceprefix_ , eol_))
        if self.ip is not None:
            self.ip.export(outfile, level, namespaceprefix_, name_='ip', pretty_print=pretty_print)
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
        if self.console_user is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconsole_user>%s</%sconsole_user>%s' % (namespaceprefix_ , self.gds_format_boolean(self.console_user, input_name='console_user'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Session, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'ip':
            obj_ = IP.factory(parent_object_=self)
            obj_.build(child_)
            self.ip = obj_
            obj_.original_tagname_ = 'ip'
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'console_user':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'console_user')
            self.console_user = ival_
        super(Session, self).buildChildren(child_, node, nodeName_, True)
# end class Session


class Sessions(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, session=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Sessions, self).__init__(actions, size, total, active,  **kwargs_)
        if session is None:
            self.session = []
        else:
            self.session = session
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sessions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sessions.subclass:
            return Sessions.subclass(*args_, **kwargs_)
        else:
            return Sessions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_session(self):
        return self.session
    def set_session(self, session):
        self.session = session
    def add_session(self, value):
        self.session.append(value)
    def insert_session_at(self, index, value):
        self.session.insert(index, value)
    def replace_session_at(self, index, value):
        self.session[index] = value
    sessionProp = property(get_session, set_session)
    def hasContent_(self):
        if (
            self.session or
            super(Sessions, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='sessions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sessions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sessions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='sessions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sessions'):
        super(Sessions, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sessions')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='sessions', fromsubclass_=False, pretty_print=True):
        super(Sessions, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for session_ in self.session:
            session_.export(outfile, level, namespaceprefix_, name_='session', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Sessions, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'session':
            obj_ = Session.factory(parent_object_=self)
            obj_.build(child_)
            self.session.append(obj_)
            obj_.original_tagname_ = 'session'
        super(Sessions, self).buildChildren(child_, node, nodeName_, True)
# end class Sessions


class VmPool(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, size=None, cluster=None, template=None, vm=None, prestarted_vms=None, max_user_vms=None, display=None, rng_device=None, soundcard_enabled=None, type_=None, use_latest_template_version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VmPool, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.size = size
        self.cluster = cluster
        self.template = template
        self.vm = vm
        self.prestarted_vms = prestarted_vms
        self.max_user_vms = max_user_vms
        self.display = display
        self.rng_device = rng_device
        self.soundcard_enabled = soundcard_enabled
        self.type_ = type_
        self.use_latest_template_version = use_latest_template_version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmPool)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmPool.subclass:
            return VmPool.subclass(*args_, **kwargs_)
        else:
            return VmPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    sizeProp = property(get_size, set_size)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_prestarted_vms(self):
        return self.prestarted_vms
    def set_prestarted_vms(self, prestarted_vms):
        self.prestarted_vms = prestarted_vms
    prestarted_vmsProp = property(get_prestarted_vms, set_prestarted_vms)
    def get_max_user_vms(self):
        return self.max_user_vms
    def set_max_user_vms(self, max_user_vms):
        self.max_user_vms = max_user_vms
    max_user_vmsProp = property(get_max_user_vms, set_max_user_vms)
    def get_display(self):
        return self.display
    def set_display(self, display):
        self.display = display
    displayProp = property(get_display, set_display)
    def get_rng_device(self):
        return self.rng_device
    def set_rng_device(self, rng_device):
        self.rng_device = rng_device
    rng_deviceProp = property(get_rng_device, set_rng_device)
    def get_soundcard_enabled(self):
        return self.soundcard_enabled
    def set_soundcard_enabled(self, soundcard_enabled):
        self.soundcard_enabled = soundcard_enabled
    soundcard_enabledProp = property(get_soundcard_enabled, set_soundcard_enabled)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_use_latest_template_version(self):
        return self.use_latest_template_version
    def set_use_latest_template_version(self, use_latest_template_version):
        self.use_latest_template_version = use_latest_template_version
    use_latest_template_versionProp = property(get_use_latest_template_version, set_use_latest_template_version)
    def hasContent_(self):
        if (
            self.size is not None or
            self.cluster is not None or
            self.template is not None or
            self.vm is not None or
            self.prestarted_vms is not None or
            self.max_user_vms is not None or
            self.display is not None or
            self.rng_device is not None or
            self.soundcard_enabled is not None or
            self.type_ is not None or
            self.use_latest_template_version is not None or
            super(VmPool, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vmpool', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vmpool')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vmpool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vmpool', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vmpool'):
        super(VmPool, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vmpool')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vmpool', fromsubclass_=False, pretty_print=True):
        super(VmPool, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_format_integer(self.size, input_name='size'), namespaceprefix_ , eol_))
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.prestarted_vms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprestarted_vms>%s</%sprestarted_vms>%s' % (namespaceprefix_ , self.gds_format_integer(self.prestarted_vms, input_name='prestarted_vms'), namespaceprefix_ , eol_))
        if self.max_user_vms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_user_vms>%s</%smax_user_vms>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_user_vms, input_name='max_user_vms'), namespaceprefix_ , eol_))
        if self.display is not None:
            self.display.export(outfile, level, namespaceprefix_, name_='display', pretty_print=pretty_print)
        if self.rng_device is not None:
            self.rng_device.export(outfile, level, namespaceprefix_, name_='rng_device', pretty_print=pretty_print)
        if self.soundcard_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssoundcard_enabled>%s</%ssoundcard_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.soundcard_enabled, input_name='soundcard_enabled'), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.use_latest_template_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suse_latest_template_version>%s</%suse_latest_template_version>%s' % (namespaceprefix_ , self.gds_format_boolean(self.use_latest_template_version, input_name='use_latest_template_version'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmPool, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'prestarted_vms' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'prestarted_vms')
            self.prestarted_vms = ival_
        elif nodeName_ == 'max_user_vms' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_user_vms')
            self.max_user_vms = ival_
        elif nodeName_ == 'display':
            obj_ = Display.factory(parent_object_=self)
            obj_.build(child_)
            self.display = obj_
            obj_.original_tagname_ = 'display'
        elif nodeName_ == 'rng_device':
            obj_ = RngDevice.factory(parent_object_=self)
            obj_.build(child_)
            self.rng_device = obj_
            obj_.original_tagname_ = 'rng_device'
        elif nodeName_ == 'soundcard_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'soundcard_enabled')
            self.soundcard_enabled = ival_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'use_latest_template_version':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'use_latest_template_version')
            self.use_latest_template_version = ival_
        super(VmPool, self).buildChildren(child_, node, nodeName_, True)
# end class VmPool


class VmPools(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, vmpool=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VmPools, self).__init__(actions, size, total, active,  **kwargs_)
        if vmpool is None:
            self.vmpool = []
        else:
            self.vmpool = vmpool
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VmPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VmPools.subclass:
            return VmPools.subclass(*args_, **kwargs_)
        else:
            return VmPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vmpool(self):
        return self.vmpool
    def set_vmpool(self, vmpool):
        self.vmpool = vmpool
    def add_vmpool(self, value):
        self.vmpool.append(value)
    def insert_vmpool_at(self, index, value):
        self.vmpool.insert(index, value)
    def replace_vmpool_at(self, index, value):
        self.vmpool[index] = value
    vmpoolProp = property(get_vmpool, set_vmpool)
    def hasContent_(self):
        if (
            self.vmpool or
            super(VmPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vmpools', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vmpools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vmpools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vmpools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vmpools'):
        super(VmPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vmpools')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vmpools', fromsubclass_=False, pretty_print=True):
        super(VmPools, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vmpool_ in self.vmpool:
            vmpool_.export(outfile, level, namespaceprefix_, name_='vmpool', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vmpool':
            obj_ = VmPool.factory(parent_object_=self)
            obj_.build(child_)
            self.vmpool.append(obj_)
            obj_.original_tagname_ = 'vmpool'
        super(VmPools, self).buildChildren(child_, node, nodeName_, True)
# end class VmPools


class BaseDevice(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BaseDevice, self).__init__(actions, href, id, name, description, comment, creation_status, link, extensiontype_,  **kwargs_)
        self.template = template
        self.instance_type = instance_type
        self.vms = vms
        self.vm = vm
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseDevice.subclass:
            return BaseDevice.subclass(*args_, **kwargs_)
        else:
            return BaseDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_instance_type(self):
        return self.instance_type
    def set_instance_type(self, instance_type):
        self.instance_type = instance_type
    instance_typeProp = property(get_instance_type, set_instance_type)
    def get_vms(self):
        return self.vms
    def set_vms(self, vms):
        self.vms = vms
    vmsProp = property(get_vms, set_vms)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.template is not None or
            self.instance_type is not None or
            self.vms is not None or
            self.vm is not None or
            super(BaseDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BaseDevice', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseDevice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='BaseDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseDevice'):
        super(BaseDevice, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseDevice')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BaseDevice', fromsubclass_=False, pretty_print=True):
        super(BaseDevice, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.instance_type is not None:
            self.instance_type.export(outfile, level, namespaceprefix_, name_='instance_type', pretty_print=pretty_print)
        if self.vms is not None:
            self.vms.export(outfile, level, namespaceprefix_, name_='vms', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'instance_type':
            obj_ = InstanceType.factory(parent_object_=self)
            obj_.build(child_)
            self.instance_type = obj_
            obj_.original_tagname_ = 'instance_type'
        elif nodeName_ == 'vms':
            obj_ = VMs.factory(parent_object_=self)
            obj_.build(child_)
            self.vms = obj_
            obj_.original_tagname_ = 'vms'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        super(BaseDevice, self).buildChildren(child_, node, nodeName_, True)
# end class BaseDevice


class BaseDevices(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BaseDevices, self).__init__(actions, size, total, active, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BaseDevices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BaseDevices.subclass:
            return BaseDevices.subclass(*args_, **kwargs_)
        else:
            return BaseDevices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(BaseDevices, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='BaseDevices', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BaseDevices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseDevices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='BaseDevices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BaseDevices'):
        super(BaseDevices, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BaseDevices')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='BaseDevices', fromsubclass_=False, pretty_print=True):
        super(BaseDevices, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(BaseDevices, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BaseDevices, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BaseDevices


class Application(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, vm=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Application, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.vm = vm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Application)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Application.subclass:
            return Application.subclass(*args_, **kwargs_)
        else:
            return Application(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def hasContent_(self):
        if (
            self.vm is not None or
            super(Application, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='application', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('application')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='application')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='application', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='application'):
        super(Application, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='application')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='application', fromsubclass_=False, pretty_print=True):
        super(Application, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Application, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        super(Application, self).buildChildren(child_, node, nodeName_, True)
# end class Application


class Applications(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, application=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Applications, self).__init__(actions, size, total, active,  **kwargs_)
        if application is None:
            self.application = []
        else:
            self.application = application
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Applications)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Applications.subclass:
            return Applications.subclass(*args_, **kwargs_)
        else:
            return Applications(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_application(self):
        return self.application
    def set_application(self, application):
        self.application = application
    def add_application(self, value):
        self.application.append(value)
    def insert_application_at(self, index, value):
        self.application.insert(index, value)
    def replace_application_at(self, index, value):
        self.application[index] = value
    applicationProp = property(get_application, set_application)
    def hasContent_(self):
        if (
            self.application or
            super(Applications, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='applications', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('applications')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='applications')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='applications', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='applications'):
        super(Applications, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='applications')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='applications', fromsubclass_=False, pretty_print=True):
        super(Applications, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for application_ in self.application:
            application_.export(outfile, level, namespaceprefix_, name_='application', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Applications, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'application':
            obj_ = Application.factory(parent_object_=self)
            obj_.build(child_)
            self.application.append(obj_)
            obj_.original_tagname_ = 'application'
        super(Applications, self).buildChildren(child_, node, nodeName_, True)
# end class Applications


class CdRom(BaseDevice):
    subclass = None
    superclass = BaseDevice
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, file=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CdRom, self).__init__(actions, href, id, name, description, comment, creation_status, link, template, instance_type, vms, vm,  **kwargs_)
        self.file = file
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CdRom)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CdRom.subclass:
            return CdRom.subclass(*args_, **kwargs_)
        else:
            return CdRom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    fileProp = property(get_file, set_file)
    def hasContent_(self):
        if (
            self.file is not None or
            super(CdRom, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cdrom', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cdrom')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cdrom')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cdrom', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cdrom'):
        super(CdRom, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cdrom')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cdrom', fromsubclass_=False, pretty_print=True):
        super(CdRom, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.file is not None:
            self.file.export(outfile, level, namespaceprefix_, name_='file', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CdRom, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'file':
            obj_ = File.factory(parent_object_=self)
            obj_.build(child_)
            self.file = obj_
            obj_.original_tagname_ = 'file'
        super(CdRom, self).buildChildren(child_, node, nodeName_, True)
# end class CdRom


class CdRoms(BaseDevices):
    subclass = None
    superclass = BaseDevices
    def __init__(self, actions=None, size=None, total=None, active=None, cdrom=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CdRoms, self).__init__(actions, size, total, active,  **kwargs_)
        if cdrom is None:
            self.cdrom = []
        else:
            self.cdrom = cdrom
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CdRoms)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CdRoms.subclass:
            return CdRoms.subclass(*args_, **kwargs_)
        else:
            return CdRoms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cdrom(self):
        return self.cdrom
    def set_cdrom(self, cdrom):
        self.cdrom = cdrom
    def add_cdrom(self, value):
        self.cdrom.append(value)
    def insert_cdrom_at(self, index, value):
        self.cdrom.insert(index, value)
    def replace_cdrom_at(self, index, value):
        self.cdrom[index] = value
    cdromProp = property(get_cdrom, set_cdrom)
    def hasContent_(self):
        if (
            self.cdrom or
            super(CdRoms, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cdroms', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cdroms')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cdroms')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cdroms', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cdroms'):
        super(CdRoms, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cdroms')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cdroms', fromsubclass_=False, pretty_print=True):
        super(CdRoms, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cdrom_ in self.cdrom:
            cdrom_.export(outfile, level, namespaceprefix_, name_='cdrom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CdRoms, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cdrom':
            obj_ = CdRom.factory(parent_object_=self)
            obj_.build(child_)
            self.cdrom.append(obj_)
            obj_.original_tagname_ = 'cdrom'
        super(CdRoms, self).buildChildren(child_, node, nodeName_, True)
# end class CdRoms


class Floppy(BaseDevice):
    subclass = None
    superclass = BaseDevice
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, file=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Floppy, self).__init__(actions, href, id, name, description, comment, creation_status, link, template, instance_type, vms, vm,  **kwargs_)
        self.file = file
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Floppy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Floppy.subclass:
            return Floppy.subclass(*args_, **kwargs_)
        else:
            return Floppy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    fileProp = property(get_file, set_file)
    def hasContent_(self):
        if (
            self.file is not None or
            super(Floppy, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='floppy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('floppy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='floppy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='floppy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='floppy'):
        super(Floppy, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='floppy')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='floppy', fromsubclass_=False, pretty_print=True):
        super(Floppy, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.file is not None:
            self.file.export(outfile, level, namespaceprefix_, name_='file', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Floppy, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'file':
            obj_ = File.factory(parent_object_=self)
            obj_.build(child_)
            self.file = obj_
            obj_.original_tagname_ = 'file'
        super(Floppy, self).buildChildren(child_, node, nodeName_, True)
# end class Floppy


class Floppies(BaseDevices):
    subclass = None
    superclass = BaseDevices
    def __init__(self, actions=None, size=None, total=None, active=None, floppy=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Floppies, self).__init__(actions, size, total, active,  **kwargs_)
        if floppy is None:
            self.floppy = []
        else:
            self.floppy = floppy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Floppies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Floppies.subclass:
            return Floppies.subclass(*args_, **kwargs_)
        else:
            return Floppies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_floppy(self):
        return self.floppy
    def set_floppy(self, floppy):
        self.floppy = floppy
    def add_floppy(self, value):
        self.floppy.append(value)
    def insert_floppy_at(self, index, value):
        self.floppy.insert(index, value)
    def replace_floppy_at(self, index, value):
        self.floppy[index] = value
    floppyProp = property(get_floppy, set_floppy)
    def hasContent_(self):
        if (
            self.floppy or
            super(Floppies, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='floppies', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('floppies')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='floppies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='floppies', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='floppies'):
        super(Floppies, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='floppies')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='floppies', fromsubclass_=False, pretty_print=True):
        super(Floppies, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for floppy_ in self.floppy:
            floppy_.export(outfile, level, namespaceprefix_, name_='floppy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Floppies, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'floppy':
            obj_ = Floppy.factory(parent_object_=self)
            obj_.build(child_)
            self.floppy.append(obj_)
            obj_.original_tagname_ = 'floppy'
        super(Floppies, self).buildChildren(child_, node, nodeName_, True)
# end class Floppies


class Disk(BaseDevice):
    subclass = None
    superclass = BaseDevice
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, alias=None, image_id=None, storage_domain=None, storage_domains=None, size=None, type_=None, provisioned_size=None, actual_size=None, status=None, interface=None, format=None, sparse=None, bootable=None, shareable=None, wipe_after_delete=None, propagate_errors=None, statistics=None, active=None, read_only=None, quota=None, lun_storage=None, sgio=None, uses_scsi_reservation=None, snapshot=None, disk_profile=None, logical_name=None, storage_type=None, openstack_volume_type=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Disk, self).__init__(actions, href, id, name, description, comment, creation_status, link, template, instance_type, vms, vm, extensiontype_,  **kwargs_)
        self.alias = alias
        self.image_id = image_id
        self.storage_domain = storage_domain
        self.storage_domains = storage_domains
        self.size = size
        self.type_ = type_
        self.provisioned_size = provisioned_size
        self.actual_size = actual_size
        self.status = status
        self.interface = interface
        self.format = format
        self.sparse = sparse
        self.bootable = bootable
        self.shareable = shareable
        self.wipe_after_delete = wipe_after_delete
        self.propagate_errors = propagate_errors
        self.statistics = statistics
        self.active = active
        self.read_only = read_only
        self.quota = quota
        self.lun_storage = lun_storage
        self.sgio = sgio
        self.uses_scsi_reservation = uses_scsi_reservation
        self.snapshot = snapshot
        self.disk_profile = disk_profile
        self.logical_name = logical_name
        self.storage_type = storage_type
        self.openstack_volume_type = openstack_volume_type
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Disk)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Disk.subclass:
            return Disk.subclass(*args_, **kwargs_)
        else:
            return Disk(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alias(self):
        return self.alias
    def set_alias(self, alias):
        self.alias = alias
    aliasProp = property(get_alias, set_alias)
    def get_image_id(self):
        return self.image_id
    def set_image_id(self, image_id):
        self.image_id = image_id
    image_idProp = property(get_image_id, set_image_id)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_storage_domains(self):
        return self.storage_domains
    def set_storage_domains(self, storage_domains):
        self.storage_domains = storage_domains
    storage_domainsProp = property(get_storage_domains, set_storage_domains)
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    sizeProp = property(get_size, set_size)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_provisioned_size(self):
        return self.provisioned_size
    def set_provisioned_size(self, provisioned_size):
        self.provisioned_size = provisioned_size
    provisioned_sizeProp = property(get_provisioned_size, set_provisioned_size)
    def get_actual_size(self):
        return self.actual_size
    def set_actual_size(self, actual_size):
        self.actual_size = actual_size
    actual_sizeProp = property(get_actual_size, set_actual_size)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_interface(self):
        return self.interface
    def set_interface(self, interface):
        self.interface = interface
    interfaceProp = property(get_interface, set_interface)
    def get_format(self):
        return self.format
    def set_format(self, format):
        self.format = format
    formatProp = property(get_format, set_format)
    def get_sparse(self):
        return self.sparse
    def set_sparse(self, sparse):
        self.sparse = sparse
    sparseProp = property(get_sparse, set_sparse)
    def get_bootable(self):
        return self.bootable
    def set_bootable(self, bootable):
        self.bootable = bootable
    bootableProp = property(get_bootable, set_bootable)
    def get_shareable(self):
        return self.shareable
    def set_shareable(self, shareable):
        self.shareable = shareable
    shareableProp = property(get_shareable, set_shareable)
    def get_wipe_after_delete(self):
        return self.wipe_after_delete
    def set_wipe_after_delete(self, wipe_after_delete):
        self.wipe_after_delete = wipe_after_delete
    wipe_after_deleteProp = property(get_wipe_after_delete, set_wipe_after_delete)
    def get_propagate_errors(self):
        return self.propagate_errors
    def set_propagate_errors(self, propagate_errors):
        self.propagate_errors = propagate_errors
    propagate_errorsProp = property(get_propagate_errors, set_propagate_errors)
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    statisticsProp = property(get_statistics, set_statistics)
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    activeProp = property(get_active, set_active)
    def get_read_only(self):
        return self.read_only
    def set_read_only(self, read_only):
        self.read_only = read_only
    read_onlyProp = property(get_read_only, set_read_only)
    def get_quota(self):
        return self.quota
    def set_quota(self, quota):
        self.quota = quota
    quotaProp = property(get_quota, set_quota)
    def get_lun_storage(self):
        return self.lun_storage
    def set_lun_storage(self, lun_storage):
        self.lun_storage = lun_storage
    lun_storageProp = property(get_lun_storage, set_lun_storage)
    def get_sgio(self):
        return self.sgio
    def set_sgio(self, sgio):
        self.sgio = sgio
    sgioProp = property(get_sgio, set_sgio)
    def get_uses_scsi_reservation(self):
        return self.uses_scsi_reservation
    def set_uses_scsi_reservation(self, uses_scsi_reservation):
        self.uses_scsi_reservation = uses_scsi_reservation
    uses_scsi_reservationProp = property(get_uses_scsi_reservation, set_uses_scsi_reservation)
    def get_snapshot(self):
        return self.snapshot
    def set_snapshot(self, snapshot):
        self.snapshot = snapshot
    snapshotProp = property(get_snapshot, set_snapshot)
    def get_disk_profile(self):
        return self.disk_profile
    def set_disk_profile(self, disk_profile):
        self.disk_profile = disk_profile
    disk_profileProp = property(get_disk_profile, set_disk_profile)
    def get_logical_name(self):
        return self.logical_name
    def set_logical_name(self, logical_name):
        self.logical_name = logical_name
    logical_nameProp = property(get_logical_name, set_logical_name)
    def get_storage_type(self):
        return self.storage_type
    def set_storage_type(self, storage_type):
        self.storage_type = storage_type
    storage_typeProp = property(get_storage_type, set_storage_type)
    def get_openstack_volume_type(self):
        return self.openstack_volume_type
    def set_openstack_volume_type(self, openstack_volume_type):
        self.openstack_volume_type = openstack_volume_type
    openstack_volume_typeProp = property(get_openstack_volume_type, set_openstack_volume_type)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.alias is not None or
            self.image_id is not None or
            self.storage_domain is not None or
            self.storage_domains is not None or
            self.size is not None or
            self.type_ is not None or
            self.provisioned_size is not None or
            self.actual_size is not None or
            self.status is not None or
            self.interface is not None or
            self.format is not None or
            self.sparse is not None or
            self.bootable is not None or
            self.shareable is not None or
            self.wipe_after_delete is not None or
            self.propagate_errors is not None or
            self.statistics is not None or
            self.active is not None or
            self.read_only is not None or
            self.quota is not None or
            self.lun_storage is not None or
            self.sgio is not None or
            self.uses_scsi_reservation is not None or
            self.snapshot is not None or
            self.disk_profile is not None or
            self.logical_name is not None or
            self.storage_type is not None or
            self.openstack_volume_type is not None or
            super(Disk, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk'):
        super(Disk, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk', fromsubclass_=False, pretty_print=True):
        super(Disk, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.alias is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salias>%s</%salias>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.alias), input_name='alias')), namespaceprefix_ , eol_))
        if self.image_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simage_id>%s</%simage_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.image_id), input_name='image_id')), namespaceprefix_ , eol_))
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.storage_domains is not None:
            self.storage_domains.export(outfile, level, namespaceprefix_, name_='storage_domains', pretty_print=pretty_print)
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_format_integer(self.size, input_name='size'), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.provisioned_size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprovisioned_size>%s</%sprovisioned_size>%s' % (namespaceprefix_ , self.gds_format_integer(self.provisioned_size, input_name='provisioned_size'), namespaceprefix_ , eol_))
        if self.actual_size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactual_size>%s</%sactual_size>%s' % (namespaceprefix_ , self.gds_format_integer(self.actual_size, input_name='actual_size'), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterface>%s</%sinterface>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.interface), input_name='interface')), namespaceprefix_ , eol_))
        if self.format is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sformat>%s</%sformat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.format), input_name='format')), namespaceprefix_ , eol_))
        if self.sparse is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssparse>%s</%ssparse>%s' % (namespaceprefix_ , self.gds_format_boolean(self.sparse, input_name='sparse'), namespaceprefix_ , eol_))
        if self.bootable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbootable>%s</%sbootable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.bootable, input_name='bootable'), namespaceprefix_ , eol_))
        if self.shareable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshareable>%s</%sshareable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.shareable, input_name='shareable'), namespaceprefix_ , eol_))
        if self.wipe_after_delete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swipe_after_delete>%s</%swipe_after_delete>%s' % (namespaceprefix_ , self.gds_format_boolean(self.wipe_after_delete, input_name='wipe_after_delete'), namespaceprefix_ , eol_))
        if self.propagate_errors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spropagate_errors>%s</%spropagate_errors>%s' % (namespaceprefix_ , self.gds_format_boolean(self.propagate_errors, input_name='propagate_errors'), namespaceprefix_ , eol_))
        if self.statistics is not None:
            self.statistics.export(outfile, level, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
        if self.active is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactive>%s</%sactive>%s' % (namespaceprefix_ , self.gds_format_boolean(self.active, input_name='active'), namespaceprefix_ , eol_))
        if self.read_only is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sread_only>%s</%sread_only>%s' % (namespaceprefix_ , self.gds_format_boolean(self.read_only, input_name='read_only'), namespaceprefix_ , eol_))
        if self.quota is not None:
            self.quota.export(outfile, level, namespaceprefix_, name_='quota', pretty_print=pretty_print)
        if self.lun_storage is not None:
            self.lun_storage.export(outfile, level, namespaceprefix_, name_='lun_storage', pretty_print=pretty_print)
        if self.sgio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssgio>%s</%ssgio>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.sgio), input_name='sgio')), namespaceprefix_ , eol_))
        if self.uses_scsi_reservation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suses_scsi_reservation>%s</%suses_scsi_reservation>%s' % (namespaceprefix_ , self.gds_format_boolean(self.uses_scsi_reservation, input_name='uses_scsi_reservation'), namespaceprefix_ , eol_))
        if self.snapshot is not None:
            self.snapshot.export(outfile, level, namespaceprefix_, name_='snapshot', pretty_print=pretty_print)
        if self.disk_profile is not None:
            self.disk_profile.export(outfile, level, namespaceprefix_, name_='disk_profile', pretty_print=pretty_print)
        if self.logical_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogical_name>%s</%slogical_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.logical_name), input_name='logical_name')), namespaceprefix_ , eol_))
        if self.storage_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_type>%s</%sstorage_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.storage_type), input_name='storage_type')), namespaceprefix_ , eol_))
        if self.openstack_volume_type is not None:
            self.openstack_volume_type.export(outfile, level, namespaceprefix_, name_='openstack_volume_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Disk, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alias':
            alias_ = child_.text
            alias_ = self.gds_validate_string(alias_, node, 'alias')
            self.alias = alias_
        elif nodeName_ == 'image_id':
            image_id_ = child_.text
            image_id_ = self.gds_validate_string(image_id_, node, 'image_id')
            self.image_id = image_id_
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'storage_domains':
            obj_ = StorageDomains.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domains = obj_
            obj_.original_tagname_ = 'storage_domains'
        elif nodeName_ == 'size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'provisioned_size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'provisioned_size')
            self.provisioned_size = ival_
        elif nodeName_ == 'actual_size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'actual_size')
            self.actual_size = ival_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'interface':
            interface_ = child_.text
            interface_ = self.gds_validate_string(interface_, node, 'interface')
            self.interface = interface_
        elif nodeName_ == 'format':
            format_ = child_.text
            format_ = self.gds_validate_string(format_, node, 'format')
            self.format = format_
        elif nodeName_ == 'sparse':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sparse')
            self.sparse = ival_
        elif nodeName_ == 'bootable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bootable')
            self.bootable = ival_
        elif nodeName_ == 'shareable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'shareable')
            self.shareable = ival_
        elif nodeName_ == 'wipe_after_delete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'wipe_after_delete')
            self.wipe_after_delete = ival_
        elif nodeName_ == 'propagate_errors':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'propagate_errors')
            self.propagate_errors = ival_
        elif nodeName_ == 'statistics':
            obj_ = Statistics.factory(parent_object_=self)
            obj_.build(child_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'active':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'active')
            self.active = ival_
        elif nodeName_ == 'read_only':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'read_only')
            self.read_only = ival_
        elif nodeName_ == 'quota':
            obj_ = Quota.factory(parent_object_=self)
            obj_.build(child_)
            self.quota = obj_
            obj_.original_tagname_ = 'quota'
        elif nodeName_ == 'lun_storage':
            obj_ = Storage.factory(parent_object_=self)
            obj_.build(child_)
            self.lun_storage = obj_
            obj_.original_tagname_ = 'lun_storage'
        elif nodeName_ == 'sgio':
            sgio_ = child_.text
            sgio_ = self.gds_validate_string(sgio_, node, 'sgio')
            self.sgio = sgio_
        elif nodeName_ == 'uses_scsi_reservation':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'uses_scsi_reservation')
            self.uses_scsi_reservation = ival_
        elif nodeName_ == 'snapshot':
            obj_ = Snapshot.factory(parent_object_=self)
            obj_.build(child_)
            self.snapshot = obj_
            obj_.original_tagname_ = 'snapshot'
        elif nodeName_ == 'disk_profile':
            obj_ = DiskProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_profile = obj_
            obj_.original_tagname_ = 'disk_profile'
        elif nodeName_ == 'logical_name':
            logical_name_ = child_.text
            logical_name_ = self.gds_validate_string(logical_name_, node, 'logical_name')
            self.logical_name = logical_name_
        elif nodeName_ == 'storage_type':
            storage_type_ = child_.text
            storage_type_ = self.gds_validate_string(storage_type_, node, 'storage_type')
            self.storage_type = storage_type_
        elif nodeName_ == 'openstack_volume_type':
            obj_ = OpenStackVolumeType.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_volume_type = obj_
            obj_.original_tagname_ = 'openstack_volume_type'
        super(Disk, self).buildChildren(child_, node, nodeName_, True)
# end class Disk


class Disks(BaseDevices):
    subclass = None
    superclass = BaseDevices
    def __init__(self, actions=None, size=None, total=None, active=None, disk=None, clone=None, detach_only=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Disks, self).__init__(actions, size, total, active,  **kwargs_)
        if disk is None:
            self.disk = []
        else:
            self.disk = disk
        self.clone = clone
        self.detach_only = detach_only
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Disks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Disks.subclass:
            return Disks.subclass(*args_, **kwargs_)
        else:
            return Disks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk(self):
        return self.disk
    def set_disk(self, disk):
        self.disk = disk
    def add_disk(self, value):
        self.disk.append(value)
    def insert_disk_at(self, index, value):
        self.disk.insert(index, value)
    def replace_disk_at(self, index, value):
        self.disk[index] = value
    diskProp = property(get_disk, set_disk)
    def get_clone(self):
        return self.clone
    def set_clone(self, clone):
        self.clone = clone
    cloneProp = property(get_clone, set_clone)
    def get_detach_only(self):
        return self.detach_only
    def set_detach_only(self, detach_only):
        self.detach_only = detach_only
    detach_onlyProp = property(get_detach_only, set_detach_only)
    def hasContent_(self):
        if (
            self.disk or
            self.clone is not None or
            self.detach_only is not None or
            super(Disks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disks'):
        super(Disks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disks', fromsubclass_=False, pretty_print=True):
        super(Disks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_ in self.disk:
            disk_.export(outfile, level, namespaceprefix_, name_='disk', pretty_print=pretty_print)
        if self.clone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclone>%s</%sclone>%s' % (namespaceprefix_ , self.gds_format_boolean(self.clone, input_name='clone'), namespaceprefix_ , eol_))
        if self.detach_only is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetach_only>%s</%sdetach_only>%s' % (namespaceprefix_ , self.gds_format_boolean(self.detach_only, input_name='detach_only'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Disks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk':
            class_obj_ = self.get_class_obj_(child_, Disk)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.disk.append(obj_)
            obj_.original_tagname_ = 'disk'
        elif nodeName_ == 'clone':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'clone')
            self.clone = ival_
        elif nodeName_ == 'detach_only':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'detach_only')
            self.detach_only = ival_
        super(Disks, self).buildChildren(child_, node, nodeName_, True)
# end class Disks


class DiskSnapshot(Disk):
    subclass = None
    superclass = Disk
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, alias=None, image_id=None, storage_domain=None, storage_domains=None, size=None, type_=None, provisioned_size=None, actual_size=None, status=None, interface=None, format=None, sparse=None, bootable=None, shareable=None, wipe_after_delete=None, propagate_errors=None, statistics=None, active=None, read_only=None, quota=None, lun_storage=None, sgio=None, uses_scsi_reservation=None, snapshot=None, disk_profile=None, logical_name=None, storage_type=None, openstack_volume_type=None, disk=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DiskSnapshot, self).__init__(actions, href, id, name, description, comment, creation_status, link, template, instance_type, vms, vm, alias, image_id, storage_domain, storage_domains, size, type_, provisioned_size, actual_size, status, interface, format, sparse, bootable, shareable, wipe_after_delete, propagate_errors, statistics, active, read_only, quota, lun_storage, sgio, uses_scsi_reservation, snapshot, disk_profile, logical_name, storage_type, openstack_volume_type,  **kwargs_)
        self.disk = disk
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskSnapshot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskSnapshot.subclass:
            return DiskSnapshot.subclass(*args_, **kwargs_)
        else:
            return DiskSnapshot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk(self):
        return self.disk
    def set_disk(self, disk):
        self.disk = disk
    diskProp = property(get_disk, set_disk)
    def hasContent_(self):
        if (
            self.disk is not None or
            super(DiskSnapshot, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_snapshot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_snapshot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_snapshot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_snapshot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_snapshot'):
        super(DiskSnapshot, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_snapshot')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_snapshot', fromsubclass_=False, pretty_print=True):
        super(DiskSnapshot, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.disk is not None:
            self.disk.export(outfile, level, namespaceprefix_, name_='disk', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskSnapshot, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk':
            class_obj_ = self.get_class_obj_(child_, Disk)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.disk = obj_
            obj_.original_tagname_ = 'disk'
        super(DiskSnapshot, self).buildChildren(child_, node, nodeName_, True)
# end class DiskSnapshot


class DiskSnapshots(BaseDevices):
    subclass = None
    superclass = BaseDevices
    def __init__(self, actions=None, size=None, total=None, active=None, disk_snapshot=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DiskSnapshots, self).__init__(actions, size, total, active,  **kwargs_)
        if disk_snapshot is None:
            self.disk_snapshot = []
        else:
            self.disk_snapshot = disk_snapshot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskSnapshots)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskSnapshots.subclass:
            return DiskSnapshots.subclass(*args_, **kwargs_)
        else:
            return DiskSnapshots(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk_snapshot(self):
        return self.disk_snapshot
    def set_disk_snapshot(self, disk_snapshot):
        self.disk_snapshot = disk_snapshot
    def add_disk_snapshot(self, value):
        self.disk_snapshot.append(value)
    def insert_disk_snapshot_at(self, index, value):
        self.disk_snapshot.insert(index, value)
    def replace_disk_snapshot_at(self, index, value):
        self.disk_snapshot[index] = value
    disk_snapshotProp = property(get_disk_snapshot, set_disk_snapshot)
    def hasContent_(self):
        if (
            self.disk_snapshot or
            super(DiskSnapshots, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_snapshots', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_snapshots')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_snapshots')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_snapshots', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_snapshots'):
        super(DiskSnapshots, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_snapshots')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_snapshots', fromsubclass_=False, pretty_print=True):
        super(DiskSnapshots, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_snapshot_ in self.disk_snapshot:
            disk_snapshot_.export(outfile, level, namespaceprefix_, name_='disk_snapshot', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskSnapshots, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk_snapshot':
            obj_ = DiskSnapshot.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_snapshot.append(obj_)
            obj_.original_tagname_ = 'disk_snapshot'
        super(DiskSnapshots, self).buildChildren(child_, node, nodeName_, True)
# end class DiskSnapshots


class DiskStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, disk_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if disk_state is None:
            self.disk_state = []
        else:
            self.disk_state = disk_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskStates.subclass:
            return DiskStates.subclass(*args_, **kwargs_)
        else:
            return DiskStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk_state(self):
        return self.disk_state
    def set_disk_state(self, disk_state):
        self.disk_state = disk_state
    def add_disk_state(self, value):
        self.disk_state.append(value)
    def insert_disk_state_at(self, index, value):
        self.disk_state.insert(index, value)
    def replace_disk_state_at(self, index, value):
        self.disk_state[index] = value
    disk_stateProp = property(get_disk_state, set_disk_state)
    def hasContent_(self):
        if (
            self.disk_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_state_ in self.disk_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisk_state>%s</%sdisk_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(disk_state_), input_name='disk_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk_state':
            disk_state_ = child_.text
            disk_state_ = self.gds_validate_string(disk_state_, node, 'disk_state')
            self.disk_state.append(disk_state_)
# end class DiskStates


class PortMirroring(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, networks=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.networks = networks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortMirroring)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortMirroring.subclass:
            return PortMirroring.subclass(*args_, **kwargs_)
        else:
            return PortMirroring(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_networks(self):
        return self.networks
    def set_networks(self, networks):
        self.networks = networks
    networksProp = property(get_networks, set_networks)
    def hasContent_(self):
        if (
            self.networks is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='port_mirroring', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('port_mirroring')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='port_mirroring')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='port_mirroring', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='port_mirroring'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='port_mirroring', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.networks is not None:
            self.networks.export(outfile, level, namespaceprefix_, name_='networks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'networks':
            obj_ = Networks.factory(parent_object_=self)
            obj_.build(child_)
            self.networks = obj_
            obj_.original_tagname_ = 'networks'
# end class PortMirroring


class NIC(BaseDevice):
    subclass = None
    superclass = BaseDevice
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, network=None, linked=None, interface=None, mac=None, statistics=None, active=None, plugged=None, port_mirroring=None, reported_devices=None, vnic_profile=None, boot_protocol=None, on_boot=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(NIC, self).__init__(actions, href, id, name, description, comment, creation_status, link, template, instance_type, vms, vm,  **kwargs_)
        self.network = network
        self.linked = linked
        self.interface = interface
        self.mac = mac
        self.statistics = statistics
        self.active = active
        self.plugged = plugged
        self.port_mirroring = port_mirroring
        self.reported_devices = reported_devices
        self.vnic_profile = vnic_profile
        self.boot_protocol = boot_protocol
        self.on_boot = on_boot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NIC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NIC.subclass:
            return NIC.subclass(*args_, **kwargs_)
        else:
            return NIC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    networkProp = property(get_network, set_network)
    def get_linked(self):
        return self.linked
    def set_linked(self, linked):
        self.linked = linked
    linkedProp = property(get_linked, set_linked)
    def get_interface(self):
        return self.interface
    def set_interface(self, interface):
        self.interface = interface
    interfaceProp = property(get_interface, set_interface)
    def get_mac(self):
        return self.mac
    def set_mac(self, mac):
        self.mac = mac
    macProp = property(get_mac, set_mac)
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    statisticsProp = property(get_statistics, set_statistics)
    def get_active(self):
        return self.active
    def set_active(self, active):
        self.active = active
    activeProp = property(get_active, set_active)
    def get_plugged(self):
        return self.plugged
    def set_plugged(self, plugged):
        self.plugged = plugged
    pluggedProp = property(get_plugged, set_plugged)
    def get_port_mirroring(self):
        return self.port_mirroring
    def set_port_mirroring(self, port_mirroring):
        self.port_mirroring = port_mirroring
    port_mirroringProp = property(get_port_mirroring, set_port_mirroring)
    def get_reported_devices(self):
        return self.reported_devices
    def set_reported_devices(self, reported_devices):
        self.reported_devices = reported_devices
    reported_devicesProp = property(get_reported_devices, set_reported_devices)
    def get_vnic_profile(self):
        return self.vnic_profile
    def set_vnic_profile(self, vnic_profile):
        self.vnic_profile = vnic_profile
    vnic_profileProp = property(get_vnic_profile, set_vnic_profile)
    def get_boot_protocol(self):
        return self.boot_protocol
    def set_boot_protocol(self, boot_protocol):
        self.boot_protocol = boot_protocol
    boot_protocolProp = property(get_boot_protocol, set_boot_protocol)
    def get_on_boot(self):
        return self.on_boot
    def set_on_boot(self, on_boot):
        self.on_boot = on_boot
    on_bootProp = property(get_on_boot, set_on_boot)
    def hasContent_(self):
        if (
            self.network is not None or
            self.linked is not None or
            self.interface is not None or
            self.mac is not None or
            self.statistics is not None or
            self.active is not None or
            self.plugged is not None or
            self.port_mirroring is not None or
            self.reported_devices is not None or
            self.vnic_profile is not None or
            self.boot_protocol is not None or
            self.on_boot is not None or
            super(NIC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nic'):
        super(NIC, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nic')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nic', fromsubclass_=False, pretty_print=True):
        super(NIC, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network is not None:
            self.network.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
        if self.linked is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinked>%s</%slinked>%s' % (namespaceprefix_ , self.gds_format_boolean(self.linked, input_name='linked'), namespaceprefix_ , eol_))
        if self.interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterface>%s</%sinterface>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.interface), input_name='interface')), namespaceprefix_ , eol_))
        if self.mac is not None:
            self.mac.export(outfile, level, namespaceprefix_, name_='mac', pretty_print=pretty_print)
        if self.statistics is not None:
            self.statistics.export(outfile, level, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
        if self.active is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactive>%s</%sactive>%s' % (namespaceprefix_ , self.gds_format_boolean(self.active, input_name='active'), namespaceprefix_ , eol_))
        if self.plugged is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splugged>%s</%splugged>%s' % (namespaceprefix_ , self.gds_format_boolean(self.plugged, input_name='plugged'), namespaceprefix_ , eol_))
        if self.port_mirroring is not None:
            self.port_mirroring.export(outfile, level, namespaceprefix_, name_='port_mirroring', pretty_print=pretty_print)
        if self.reported_devices is not None:
            self.reported_devices.export(outfile, level, namespaceprefix_, name_='reported_devices', pretty_print=pretty_print)
        if self.vnic_profile is not None:
            self.vnic_profile.export(outfile, level, namespaceprefix_, name_='vnic_profile', pretty_print=pretty_print)
        if self.boot_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboot_protocol>%s</%sboot_protocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.boot_protocol), input_name='boot_protocol')), namespaceprefix_ , eol_))
        if self.on_boot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%son_boot>%s</%son_boot>%s' % (namespaceprefix_ , self.gds_format_boolean(self.on_boot, input_name='on_boot'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NIC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network = obj_
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'linked':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'linked')
            self.linked = ival_
        elif nodeName_ == 'interface':
            interface_ = child_.text
            interface_ = self.gds_validate_string(interface_, node, 'interface')
            self.interface = interface_
        elif nodeName_ == 'mac':
            obj_ = MAC.factory(parent_object_=self)
            obj_.build(child_)
            self.mac = obj_
            obj_.original_tagname_ = 'mac'
        elif nodeName_ == 'statistics':
            obj_ = Statistics.factory(parent_object_=self)
            obj_.build(child_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'active':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'active')
            self.active = ival_
        elif nodeName_ == 'plugged':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'plugged')
            self.plugged = ival_
        elif nodeName_ == 'port_mirroring':
            obj_ = PortMirroring.factory(parent_object_=self)
            obj_.build(child_)
            self.port_mirroring = obj_
            obj_.original_tagname_ = 'port_mirroring'
        elif nodeName_ == 'reported_devices':
            obj_ = ReportedDevices.factory(parent_object_=self)
            obj_.build(child_)
            self.reported_devices = obj_
            obj_.original_tagname_ = 'reported_devices'
        elif nodeName_ == 'vnic_profile':
            obj_ = VnicProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.vnic_profile = obj_
            obj_.original_tagname_ = 'vnic_profile'
        elif nodeName_ == 'boot_protocol':
            boot_protocol_ = child_.text
            boot_protocol_ = self.gds_validate_string(boot_protocol_, node, 'boot_protocol')
            self.boot_protocol = boot_protocol_
        elif nodeName_ == 'on_boot':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'on_boot')
            self.on_boot = ival_
        super(NIC, self).buildChildren(child_, node, nodeName_, True)
# end class NIC


class Nics(BaseDevices):
    subclass = None
    superclass = BaseDevices
    def __init__(self, actions=None, size=None, total=None, active=None, nic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Nics, self).__init__(actions, size, total, active,  **kwargs_)
        if nic is None:
            self.nic = []
        else:
            self.nic = nic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Nics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Nics.subclass:
            return Nics.subclass(*args_, **kwargs_)
        else:
            return Nics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nic(self):
        return self.nic
    def set_nic(self, nic):
        self.nic = nic
    def add_nic(self, value):
        self.nic.append(value)
    def insert_nic_at(self, index, value):
        self.nic.insert(index, value)
    def replace_nic_at(self, index, value):
        self.nic[index] = value
    nicProp = property(get_nic, set_nic)
    def hasContent_(self):
        if (
            self.nic or
            super(Nics, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nics', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nics')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nics'):
        super(Nics, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nics')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nics', fromsubclass_=False, pretty_print=True):
        super(Nics, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nic_ in self.nic:
            nic_.export(outfile, level, namespaceprefix_, name_='nic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Nics, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nic':
            obj_ = NIC.factory(parent_object_=self)
            obj_.build(child_)
            self.nic.append(obj_)
            obj_.original_tagname_ = 'nic'
        super(Nics, self).buildChildren(child_, node, nodeName_, True)
# end class Nics


class Snapshot(VM):
    subclass = None
    superclass = VM
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, status=None, memory=None, cpu=None, cpu_shares=None, bios=None, os=None, cluster=None, storage_domain=None, creation_time=None, origin=None, stateless=None, delete_protected=None, high_availability=None, display=None, sso=None, rng_device=None, console=None, timezone=None, domain=None, usb=None, soundcard_enabled=None, tunnel_migration=None, migration_downtime=None, virtio_scsi=None, serial_number=None, start_paused=None, cpu_profile=None, migration=None, io=None, custom_properties=None, custom_emulated_machine=None, custom_cpu_model=None, time_zone=None, small_icon=None, large_icon=None, memory_policy=None, stop_reason=None, host=None, template=None, instance_type=None, start_time=None, stop_time=None, run_once=None, payloads=None, statistics=None, disks=None, initialization=None, nics=None, tags=None, snapshots=None, placement_policy=None, guest_info=None, quota=None, vmpool=None, cdroms=None, floppies=None, reported_devices=None, watchdogs=None, use_latest_template_version=None, next_run_configuration_exists=None, numa_tune_mode=None, permissions=None, external_host_provider=None, katello_errata=None, guest_time_zone=None, guest_operating_system=None, vm=None, date=None, snapshot_status=None, persist_memorystate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Snapshot, self).__init__(actions, href, id, name, description, comment, creation_status, link, type_, status, memory, cpu, cpu_shares, bios, os, cluster, storage_domain, creation_time, origin, stateless, delete_protected, high_availability, display, sso, rng_device, console, timezone, domain, usb, soundcard_enabled, tunnel_migration, migration_downtime, virtio_scsi, serial_number, start_paused, cpu_profile, migration, io, custom_properties, custom_emulated_machine, custom_cpu_model, time_zone, small_icon, large_icon, memory_policy, stop_reason, host, template, instance_type, start_time, stop_time, run_once, payloads, statistics, disks, initialization, nics, tags, snapshots, placement_policy, guest_info, quota, vmpool, cdroms, floppies, reported_devices, watchdogs, use_latest_template_version, next_run_configuration_exists, numa_tune_mode, permissions, external_host_provider, katello_errata, guest_time_zone, guest_operating_system,  **kwargs_)
        self.vm = vm
        if isinstance(date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = date
        self.date = initvalue_
        self.snapshot_status = snapshot_status
        self.persist_memorystate = persist_memorystate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Snapshot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Snapshot.subclass:
            return Snapshot.subclass(*args_, **kwargs_)
        else:
            return Snapshot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    dateProp = property(get_date, set_date)
    def get_snapshot_status(self):
        return self.snapshot_status
    def set_snapshot_status(self, snapshot_status):
        self.snapshot_status = snapshot_status
    snapshot_statusProp = property(get_snapshot_status, set_snapshot_status)
    def get_persist_memorystate(self):
        return self.persist_memorystate
    def set_persist_memorystate(self, persist_memorystate):
        self.persist_memorystate = persist_memorystate
    persist_memorystateProp = property(get_persist_memorystate, set_persist_memorystate)
    def hasContent_(self):
        if (
            self.vm is not None or
            self.date is not None or
            self.snapshot_status is not None or
            self.persist_memorystate is not None or
            super(Snapshot, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='snapshot', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('snapshot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='snapshot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='snapshot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='snapshot'):
        super(Snapshot, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='snapshot')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='snapshot', fromsubclass_=False, pretty_print=True):
        super(Snapshot, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.date, input_name='date'), namespaceprefix_ , eol_))
        if self.snapshot_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssnapshot_status>%s</%ssnapshot_status>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.snapshot_status), input_name='snapshot_status')), namespaceprefix_ , eol_))
        if self.persist_memorystate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spersist_memorystate>%s</%spersist_memorystate>%s' % (namespaceprefix_ , self.gds_format_boolean(self.persist_memorystate, input_name='persist_memorystate'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Snapshot, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.date = dval_
        elif nodeName_ == 'snapshot_status':
            snapshot_status_ = child_.text
            snapshot_status_ = self.gds_validate_string(snapshot_status_, node, 'snapshot_status')
            self.snapshot_status = snapshot_status_
        elif nodeName_ == 'persist_memorystate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'persist_memorystate')
            self.persist_memorystate = ival_
        super(Snapshot, self).buildChildren(child_, node, nodeName_, True)
# end class Snapshot


class Snapshots(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, snapshot=None, collapse_snapshots=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Snapshots, self).__init__(actions, size, total, active,  **kwargs_)
        if snapshot is None:
            self.snapshot = []
        else:
            self.snapshot = snapshot
        self.collapse_snapshots = collapse_snapshots
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Snapshots)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Snapshots.subclass:
            return Snapshots.subclass(*args_, **kwargs_)
        else:
            return Snapshots(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_snapshot(self):
        return self.snapshot
    def set_snapshot(self, snapshot):
        self.snapshot = snapshot
    def add_snapshot(self, value):
        self.snapshot.append(value)
    def insert_snapshot_at(self, index, value):
        self.snapshot.insert(index, value)
    def replace_snapshot_at(self, index, value):
        self.snapshot[index] = value
    snapshotProp = property(get_snapshot, set_snapshot)
    def get_collapse_snapshots(self):
        return self.collapse_snapshots
    def set_collapse_snapshots(self, collapse_snapshots):
        self.collapse_snapshots = collapse_snapshots
    collapse_snapshotsProp = property(get_collapse_snapshots, set_collapse_snapshots)
    def hasContent_(self):
        if (
            self.snapshot or
            self.collapse_snapshots is not None or
            super(Snapshots, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='snapshots', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('snapshots')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='snapshots')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='snapshots', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='snapshots'):
        super(Snapshots, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='snapshots')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='snapshots', fromsubclass_=False, pretty_print=True):
        super(Snapshots, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for snapshot_ in self.snapshot:
            snapshot_.export(outfile, level, namespaceprefix_, name_='snapshot', pretty_print=pretty_print)
        if self.collapse_snapshots is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scollapse_snapshots>%s</%scollapse_snapshots>%s' % (namespaceprefix_ , self.gds_format_boolean(self.collapse_snapshots, input_name='collapse_snapshots'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Snapshots, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'snapshot':
            obj_ = Snapshot.factory(parent_object_=self)
            obj_.build(child_)
            self.snapshot.append(obj_)
            obj_.original_tagname_ = 'snapshot'
        elif nodeName_ == 'collapse_snapshots':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'collapse_snapshots')
            self.collapse_snapshots = ival_
        super(Snapshots, self).buildChildren(child_, node, nodeName_, True)
# end class Snapshots


class HostNIC(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host=None, network=None, mac=None, ip=None, base_interface=None, vlan=None, bonding=None, boot_protocol=None, statistics=None, check_connectivity=None, speed=None, status=None, mtu=None, bridged=None, custom_configuration=None, override_configuration=None, labels=None, properties=None, virtual_functions_configuration=None, qos=None, physical_function=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HostNIC, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.host = host
        self.network = network
        self.mac = mac
        self.ip = ip
        self.base_interface = base_interface
        self.vlan = vlan
        self.bonding = bonding
        self.boot_protocol = boot_protocol
        self.statistics = statistics
        self.check_connectivity = check_connectivity
        self.speed = speed
        self.status = status
        self.mtu = mtu
        self.bridged = bridged
        self.custom_configuration = custom_configuration
        self.override_configuration = override_configuration
        self.labels = labels
        self.properties = properties
        self.virtual_functions_configuration = virtual_functions_configuration
        self.qos = qos
        self.physical_function = physical_function
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostNIC)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostNIC.subclass:
            return HostNIC.subclass(*args_, **kwargs_)
        else:
            return HostNIC(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    networkProp = property(get_network, set_network)
    def get_mac(self):
        return self.mac
    def set_mac(self, mac):
        self.mac = mac
    macProp = property(get_mac, set_mac)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    ipProp = property(get_ip, set_ip)
    def get_base_interface(self):
        return self.base_interface
    def set_base_interface(self, base_interface):
        self.base_interface = base_interface
    base_interfaceProp = property(get_base_interface, set_base_interface)
    def get_vlan(self):
        return self.vlan
    def set_vlan(self, vlan):
        self.vlan = vlan
    vlanProp = property(get_vlan, set_vlan)
    def get_bonding(self):
        return self.bonding
    def set_bonding(self, bonding):
        self.bonding = bonding
    bondingProp = property(get_bonding, set_bonding)
    def get_boot_protocol(self):
        return self.boot_protocol
    def set_boot_protocol(self, boot_protocol):
        self.boot_protocol = boot_protocol
    boot_protocolProp = property(get_boot_protocol, set_boot_protocol)
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    statisticsProp = property(get_statistics, set_statistics)
    def get_check_connectivity(self):
        return self.check_connectivity
    def set_check_connectivity(self, check_connectivity):
        self.check_connectivity = check_connectivity
    check_connectivityProp = property(get_check_connectivity, set_check_connectivity)
    def get_speed(self):
        return self.speed
    def set_speed(self, speed):
        self.speed = speed
    speedProp = property(get_speed, set_speed)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_mtu(self):
        return self.mtu
    def set_mtu(self, mtu):
        self.mtu = mtu
    mtuProp = property(get_mtu, set_mtu)
    def get_bridged(self):
        return self.bridged
    def set_bridged(self, bridged):
        self.bridged = bridged
    bridgedProp = property(get_bridged, set_bridged)
    def get_custom_configuration(self):
        return self.custom_configuration
    def set_custom_configuration(self, custom_configuration):
        self.custom_configuration = custom_configuration
    custom_configurationProp = property(get_custom_configuration, set_custom_configuration)
    def get_override_configuration(self):
        return self.override_configuration
    def set_override_configuration(self, override_configuration):
        self.override_configuration = override_configuration
    override_configurationProp = property(get_override_configuration, set_override_configuration)
    def get_labels(self):
        return self.labels
    def set_labels(self, labels):
        self.labels = labels
    labelsProp = property(get_labels, set_labels)
    def get_properties(self):
        return self.properties
    def set_properties(self, properties):
        self.properties = properties
    propertiesProp = property(get_properties, set_properties)
    def get_virtual_functions_configuration(self):
        return self.virtual_functions_configuration
    def set_virtual_functions_configuration(self, virtual_functions_configuration):
        self.virtual_functions_configuration = virtual_functions_configuration
    virtual_functions_configurationProp = property(get_virtual_functions_configuration, set_virtual_functions_configuration)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    qosProp = property(get_qos, set_qos)
    def get_physical_function(self):
        return self.physical_function
    def set_physical_function(self, physical_function):
        self.physical_function = physical_function
    physical_functionProp = property(get_physical_function, set_physical_function)
    def hasContent_(self):
        if (
            self.host is not None or
            self.network is not None or
            self.mac is not None or
            self.ip is not None or
            self.base_interface is not None or
            self.vlan is not None or
            self.bonding is not None or
            self.boot_protocol is not None or
            self.statistics is not None or
            self.check_connectivity is not None or
            self.speed is not None or
            self.status is not None or
            self.mtu is not None or
            self.bridged is not None or
            self.custom_configuration is not None or
            self.override_configuration is not None or
            self.labels is not None or
            self.properties is not None or
            self.virtual_functions_configuration is not None or
            self.qos is not None or
            self.physical_function is not None or
            super(HostNIC, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_nic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_nic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_nic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_nic'):
        super(HostNIC, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_nic')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_nic', fromsubclass_=False, pretty_print=True):
        super(HostNIC, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.network is not None:
            self.network.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
        if self.mac is not None:
            self.mac.export(outfile, level, namespaceprefix_, name_='mac', pretty_print=pretty_print)
        if self.ip is not None:
            self.ip.export(outfile, level, namespaceprefix_, name_='ip', pretty_print=pretty_print)
        if self.base_interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbase_interface>%s</%sbase_interface>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.base_interface), input_name='base_interface')), namespaceprefix_ , eol_))
        if self.vlan is not None:
            self.vlan.export(outfile, level, namespaceprefix_, name_='vlan', pretty_print=pretty_print)
        if self.bonding is not None:
            self.bonding.export(outfile, level, namespaceprefix_, name_='bonding', pretty_print=pretty_print)
        if self.boot_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboot_protocol>%s</%sboot_protocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.boot_protocol), input_name='boot_protocol')), namespaceprefix_ , eol_))
        if self.statistics is not None:
            self.statistics.export(outfile, level, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
        if self.check_connectivity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scheck_connectivity>%s</%scheck_connectivity>%s' % (namespaceprefix_ , self.gds_format_boolean(self.check_connectivity, input_name='check_connectivity'), namespaceprefix_ , eol_))
        if self.speed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sspeed>%s</%sspeed>%s' % (namespaceprefix_ , self.gds_format_integer(self.speed, input_name='speed'), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.mtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smtu>%s</%smtu>%s' % (namespaceprefix_ , self.gds_format_integer(self.mtu, input_name='mtu'), namespaceprefix_ , eol_))
        if self.bridged is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbridged>%s</%sbridged>%s' % (namespaceprefix_ , self.gds_format_boolean(self.bridged, input_name='bridged'), namespaceprefix_ , eol_))
        if self.custom_configuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustom_configuration>%s</%scustom_configuration>%s' % (namespaceprefix_ , self.gds_format_boolean(self.custom_configuration, input_name='custom_configuration'), namespaceprefix_ , eol_))
        if self.override_configuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverride_configuration>%s</%soverride_configuration>%s' % (namespaceprefix_ , self.gds_format_boolean(self.override_configuration, input_name='override_configuration'), namespaceprefix_ , eol_))
        if self.labels is not None:
            self.labels.export(outfile, level, namespaceprefix_, name_='labels', pretty_print=pretty_print)
        if self.properties is not None:
            self.properties.export(outfile, level, namespaceprefix_, name_='properties', pretty_print=pretty_print)
        if self.virtual_functions_configuration is not None:
            self.virtual_functions_configuration.export(outfile, level, namespaceprefix_, name_='virtual_functions_configuration', pretty_print=pretty_print)
        if self.qos is not None:
            self.qos.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
        if self.physical_function is not None:
            self.physical_function.export(outfile, level, namespaceprefix_, name_='physical_function', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HostNIC, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network = obj_
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'mac':
            obj_ = MAC.factory(parent_object_=self)
            obj_.build(child_)
            self.mac = obj_
            obj_.original_tagname_ = 'mac'
        elif nodeName_ == 'ip':
            obj_ = IP.factory(parent_object_=self)
            obj_.build(child_)
            self.ip = obj_
            obj_.original_tagname_ = 'ip'
        elif nodeName_ == 'base_interface':
            base_interface_ = child_.text
            base_interface_ = self.gds_validate_string(base_interface_, node, 'base_interface')
            self.base_interface = base_interface_
        elif nodeName_ == 'vlan':
            obj_ = VLAN.factory(parent_object_=self)
            obj_.build(child_)
            self.vlan = obj_
            obj_.original_tagname_ = 'vlan'
        elif nodeName_ == 'bonding':
            obj_ = Bonding.factory(parent_object_=self)
            obj_.build(child_)
            self.bonding = obj_
            obj_.original_tagname_ = 'bonding'
        elif nodeName_ == 'boot_protocol':
            boot_protocol_ = child_.text
            boot_protocol_ = self.gds_validate_string(boot_protocol_, node, 'boot_protocol')
            self.boot_protocol = boot_protocol_
        elif nodeName_ == 'statistics':
            obj_ = Statistics.factory(parent_object_=self)
            obj_.build(child_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'check_connectivity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'check_connectivity')
            self.check_connectivity = ival_
        elif nodeName_ == 'speed' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'speed')
            self.speed = ival_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'mtu' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mtu')
            self.mtu = ival_
        elif nodeName_ == 'bridged':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'bridged')
            self.bridged = ival_
        elif nodeName_ == 'custom_configuration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'custom_configuration')
            self.custom_configuration = ival_
        elif nodeName_ == 'override_configuration':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'override_configuration')
            self.override_configuration = ival_
        elif nodeName_ == 'labels':
            obj_ = Labels.factory(parent_object_=self)
            obj_.build(child_)
            self.labels = obj_
            obj_.original_tagname_ = 'labels'
        elif nodeName_ == 'properties':
            obj_ = Properties.factory(parent_object_=self)
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        elif nodeName_ == 'virtual_functions_configuration':
            obj_ = HostNicVirtualFunctionsConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.virtual_functions_configuration = obj_
            obj_.original_tagname_ = 'virtual_functions_configuration'
        elif nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos = obj_
            obj_.original_tagname_ = 'qos'
        elif nodeName_ == 'physical_function':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.physical_function = obj_
            obj_.original_tagname_ = 'physical_function'
        super(HostNIC, self).buildChildren(child_, node, nodeName_, True)
# end class HostNIC


class HostNicVirtualFunctionsConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max_number_of_virtual_functions=None, number_of_virtual_functions=None, all_networks_allowed=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.max_number_of_virtual_functions = max_number_of_virtual_functions
        self.number_of_virtual_functions = number_of_virtual_functions
        self.all_networks_allowed = all_networks_allowed
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostNicVirtualFunctionsConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostNicVirtualFunctionsConfiguration.subclass:
            return HostNicVirtualFunctionsConfiguration.subclass(*args_, **kwargs_)
        else:
            return HostNicVirtualFunctionsConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max_number_of_virtual_functions(self):
        return self.max_number_of_virtual_functions
    def set_max_number_of_virtual_functions(self, max_number_of_virtual_functions):
        self.max_number_of_virtual_functions = max_number_of_virtual_functions
    max_number_of_virtual_functionsProp = property(get_max_number_of_virtual_functions, set_max_number_of_virtual_functions)
    def get_number_of_virtual_functions(self):
        return self.number_of_virtual_functions
    def set_number_of_virtual_functions(self, number_of_virtual_functions):
        self.number_of_virtual_functions = number_of_virtual_functions
    number_of_virtual_functionsProp = property(get_number_of_virtual_functions, set_number_of_virtual_functions)
    def get_all_networks_allowed(self):
        return self.all_networks_allowed
    def set_all_networks_allowed(self, all_networks_allowed):
        self.all_networks_allowed = all_networks_allowed
    all_networks_allowedProp = property(get_all_networks_allowed, set_all_networks_allowed)
    def hasContent_(self):
        if (
            self.max_number_of_virtual_functions is not None or
            self.number_of_virtual_functions is not None or
            self.all_networks_allowed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_nic_virtual_functions_configuration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_nic_virtual_functions_configuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_nic_virtual_functions_configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_nic_virtual_functions_configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_nic_virtual_functions_configuration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_nic_virtual_functions_configuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.max_number_of_virtual_functions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_number_of_virtual_functions>%s</%smax_number_of_virtual_functions>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_number_of_virtual_functions, input_name='max_number_of_virtual_functions'), namespaceprefix_ , eol_))
        if self.number_of_virtual_functions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber_of_virtual_functions>%s</%snumber_of_virtual_functions>%s' % (namespaceprefix_ , self.gds_format_integer(self.number_of_virtual_functions, input_name='number_of_virtual_functions'), namespaceprefix_ , eol_))
        if self.all_networks_allowed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sall_networks_allowed>%s</%sall_networks_allowed>%s' % (namespaceprefix_ , self.gds_format_boolean(self.all_networks_allowed, input_name='all_networks_allowed'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'max_number_of_virtual_functions' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_number_of_virtual_functions')
            self.max_number_of_virtual_functions = ival_
        elif nodeName_ == 'number_of_virtual_functions' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'number_of_virtual_functions')
            self.number_of_virtual_functions = ival_
        elif nodeName_ == 'all_networks_allowed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'all_networks_allowed')
            self.all_networks_allowed = ival_
# end class HostNicVirtualFunctionsConfiguration


class UnmanagedNetworks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, unmanaged_network=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(UnmanagedNetworks, self).__init__(actions, size, total, active,  **kwargs_)
        if unmanaged_network is None:
            self.unmanaged_network = []
        else:
            self.unmanaged_network = unmanaged_network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnmanagedNetworks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnmanagedNetworks.subclass:
            return UnmanagedNetworks.subclass(*args_, **kwargs_)
        else:
            return UnmanagedNetworks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unmanaged_network(self):
        return self.unmanaged_network
    def set_unmanaged_network(self, unmanaged_network):
        self.unmanaged_network = unmanaged_network
    def add_unmanaged_network(self, value):
        self.unmanaged_network.append(value)
    def insert_unmanaged_network_at(self, index, value):
        self.unmanaged_network.insert(index, value)
    def replace_unmanaged_network_at(self, index, value):
        self.unmanaged_network[index] = value
    unmanaged_networkProp = property(get_unmanaged_network, set_unmanaged_network)
    def hasContent_(self):
        if (
            self.unmanaged_network or
            super(UnmanagedNetworks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='unmanaged_networks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unmanaged_networks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unmanaged_networks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='unmanaged_networks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='unmanaged_networks'):
        super(UnmanagedNetworks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unmanaged_networks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='unmanaged_networks', fromsubclass_=False, pretty_print=True):
        super(UnmanagedNetworks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for unmanaged_network_ in self.unmanaged_network:
            unmanaged_network_.export(outfile, level, namespaceprefix_, name_='unmanaged_network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UnmanagedNetworks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'unmanaged_network':
            obj_ = UnmanagedNetwork.factory(parent_object_=self)
            obj_.build(child_)
            self.unmanaged_network.append(obj_)
            obj_.original_tagname_ = 'unmanaged_network'
        super(UnmanagedNetworks, self).buildChildren(child_, node, nodeName_, True)
# end class UnmanagedNetworks


class UnmanagedNetwork(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host_nic=None, host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(UnmanagedNetwork, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.host_nic = host_nic
        self.host = host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnmanagedNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnmanagedNetwork.subclass:
            return UnmanagedNetwork.subclass(*args_, **kwargs_)
        else:
            return UnmanagedNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_nic(self):
        return self.host_nic
    def set_host_nic(self, host_nic):
        self.host_nic = host_nic
    host_nicProp = property(get_host_nic, set_host_nic)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def hasContent_(self):
        if (
            self.host_nic is not None or
            self.host is not None or
            super(UnmanagedNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='unmanaged_network', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unmanaged_network')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unmanaged_network')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='unmanaged_network', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='unmanaged_network'):
        super(UnmanagedNetwork, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unmanaged_network')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='unmanaged_network', fromsubclass_=False, pretty_print=True):
        super(UnmanagedNetwork, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host_nic is not None:
            self.host_nic.export(outfile, level, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UnmanagedNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_nic':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic = obj_
            obj_.original_tagname_ = 'host_nic'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        super(UnmanagedNetwork, self).buildChildren(child_, node, nodeName_, True)
# end class UnmanagedNetwork


class HostNics(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, host_nic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HostNics, self).__init__(actions, size, total, active,  **kwargs_)
        if host_nic is None:
            self.host_nic = []
        else:
            self.host_nic = host_nic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostNics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostNics.subclass:
            return HostNics.subclass(*args_, **kwargs_)
        else:
            return HostNics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_nic(self):
        return self.host_nic
    def set_host_nic(self, host_nic):
        self.host_nic = host_nic
    def add_host_nic(self, value):
        self.host_nic.append(value)
    def insert_host_nic_at(self, index, value):
        self.host_nic.insert(index, value)
    def replace_host_nic_at(self, index, value):
        self.host_nic[index] = value
    host_nicProp = property(get_host_nic, set_host_nic)
    def hasContent_(self):
        if (
            self.host_nic or
            super(HostNics, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_nics', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_nics')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_nics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_nics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_nics'):
        super(HostNics, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_nics')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_nics', fromsubclass_=False, pretty_print=True):
        super(HostNics, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_nic_ in self.host_nic:
            host_nic_.export(outfile, level, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HostNics, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_nic':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic.append(obj_)
            obj_.original_tagname_ = 'host_nic'
        super(HostNics, self).buildChildren(child_, node, nodeName_, True)
# end class HostNics


class Product(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Product, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Product)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Product.subclass:
            return Product.subclass(*args_, **kwargs_)
        else:
            return Product(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Product, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='product', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('product')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='product')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='product', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='product'):
        super(Product, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='product')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='product', fromsubclass_=False, pretty_print=True):
        super(Product, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Product, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Product, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Product


class Vendor(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Vendor, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Vendor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Vendor.subclass:
            return Vendor.subclass(*args_, **kwargs_)
        else:
            return Vendor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Vendor, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vendor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vendor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vendor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vendor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vendor'):
        super(Vendor, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vendor')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vendor', fromsubclass_=False, pretty_print=True):
        super(Vendor, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Vendor, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Vendor, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Vendor


class HostDevice(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host=None, parent_device=None, capability=None, product=None, vendor=None, iommu_group=None, physical_function=None, virtual_functions=None, placeholder=None, vm=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HostDevice, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.host = host
        self.parent_device = parent_device
        self.capability = capability
        self.product = product
        self.vendor = vendor
        self.iommu_group = iommu_group
        self.physical_function = physical_function
        self.virtual_functions = virtual_functions
        self.placeholder = placeholder
        self.vm = vm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostDevice.subclass:
            return HostDevice.subclass(*args_, **kwargs_)
        else:
            return HostDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_parent_device(self):
        return self.parent_device
    def set_parent_device(self, parent_device):
        self.parent_device = parent_device
    parent_deviceProp = property(get_parent_device, set_parent_device)
    def get_capability(self):
        return self.capability
    def set_capability(self, capability):
        self.capability = capability
    capabilityProp = property(get_capability, set_capability)
    def get_product(self):
        return self.product
    def set_product(self, product):
        self.product = product
    productProp = property(get_product, set_product)
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    vendorProp = property(get_vendor, set_vendor)
    def get_iommu_group(self):
        return self.iommu_group
    def set_iommu_group(self, iommu_group):
        self.iommu_group = iommu_group
    iommu_groupProp = property(get_iommu_group, set_iommu_group)
    def get_physical_function(self):
        return self.physical_function
    def set_physical_function(self, physical_function):
        self.physical_function = physical_function
    physical_functionProp = property(get_physical_function, set_physical_function)
    def get_virtual_functions(self):
        return self.virtual_functions
    def set_virtual_functions(self, virtual_functions):
        self.virtual_functions = virtual_functions
    virtual_functionsProp = property(get_virtual_functions, set_virtual_functions)
    def get_placeholder(self):
        return self.placeholder
    def set_placeholder(self, placeholder):
        self.placeholder = placeholder
    placeholderProp = property(get_placeholder, set_placeholder)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def hasContent_(self):
        if (
            self.host is not None or
            self.parent_device is not None or
            self.capability is not None or
            self.product is not None or
            self.vendor is not None or
            self.iommu_group is not None or
            self.physical_function is not None or
            self.virtual_functions is not None or
            self.placeholder is not None or
            self.vm is not None or
            super(HostDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_device', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_device')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_device')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_device', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_device'):
        super(HostDevice, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_device')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_device', fromsubclass_=False, pretty_print=True):
        super(HostDevice, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.parent_device is not None:
            self.parent_device.export(outfile, level, namespaceprefix_, name_='parent_device', pretty_print=pretty_print)
        if self.capability is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapability>%s</%scapability>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.capability), input_name='capability')), namespaceprefix_ , eol_))
        if self.product is not None:
            self.product.export(outfile, level, namespaceprefix_, name_='product', pretty_print=pretty_print)
        if self.vendor is not None:
            self.vendor.export(outfile, level, namespaceprefix_, name_='vendor', pretty_print=pretty_print)
        if self.iommu_group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siommu_group>%s</%siommu_group>%s' % (namespaceprefix_ , self.gds_format_integer(self.iommu_group, input_name='iommu_group'), namespaceprefix_ , eol_))
        if self.physical_function is not None:
            self.physical_function.export(outfile, level, namespaceprefix_, name_='physical_function', pretty_print=pretty_print)
        if self.virtual_functions is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svirtual_functions>%s</%svirtual_functions>%s' % (namespaceprefix_ , self.gds_format_integer(self.virtual_functions, input_name='virtual_functions'), namespaceprefix_ , eol_))
        if self.placeholder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaceholder>%s</%splaceholder>%s' % (namespaceprefix_ , self.gds_format_boolean(self.placeholder, input_name='placeholder'), namespaceprefix_ , eol_))
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HostDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'parent_device':
            obj_ = HostDevice.factory(parent_object_=self)
            obj_.build(child_)
            self.parent_device = obj_
            obj_.original_tagname_ = 'parent_device'
        elif nodeName_ == 'capability':
            capability_ = child_.text
            capability_ = self.gds_validate_string(capability_, node, 'capability')
            self.capability = capability_
        elif nodeName_ == 'product':
            obj_ = Product.factory(parent_object_=self)
            obj_.build(child_)
            self.product = obj_
            obj_.original_tagname_ = 'product'
        elif nodeName_ == 'vendor':
            obj_ = Vendor.factory(parent_object_=self)
            obj_.build(child_)
            self.vendor = obj_
            obj_.original_tagname_ = 'vendor'
        elif nodeName_ == 'iommu_group' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'iommu_group')
            self.iommu_group = ival_
        elif nodeName_ == 'physical_function':
            obj_ = HostDevice.factory(parent_object_=self)
            obj_.build(child_)
            self.physical_function = obj_
            obj_.original_tagname_ = 'physical_function'
        elif nodeName_ == 'virtual_functions' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'virtual_functions')
            self.virtual_functions = ival_
        elif nodeName_ == 'placeholder':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'placeholder')
            self.placeholder = ival_
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        super(HostDevice, self).buildChildren(child_, node, nodeName_, True)
# end class HostDevice


class HostDevices(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, host_device=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HostDevices, self).__init__(actions, size, total, active,  **kwargs_)
        if host_device is None:
            self.host_device = []
        else:
            self.host_device = host_device
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostDevices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostDevices.subclass:
            return HostDevices.subclass(*args_, **kwargs_)
        else:
            return HostDevices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_device(self):
        return self.host_device
    def set_host_device(self, host_device):
        self.host_device = host_device
    def add_host_device(self, value):
        self.host_device.append(value)
    def insert_host_device_at(self, index, value):
        self.host_device.insert(index, value)
    def replace_host_device_at(self, index, value):
        self.host_device[index] = value
    host_deviceProp = property(get_host_device, set_host_device)
    def hasContent_(self):
        if (
            self.host_device or
            super(HostDevices, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_devices', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_devices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_devices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_devices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_devices'):
        super(HostDevices, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_devices')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_devices', fromsubclass_=False, pretty_print=True):
        super(HostDevices, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_device_ in self.host_device:
            host_device_.export(outfile, level, namespaceprefix_, name_='host_device', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HostDevices, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_device':
            obj_ = HostDevice.factory(parent_object_=self)
            obj_.build(child_)
            self.host_device.append(obj_)
            obj_.original_tagname_ = 'host_device'
        super(HostDevices, self).buildChildren(child_, node, nodeName_, True)
# end class HostDevices


class GuestNicConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, ip=None, boot_protocol=None, on_boot=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.ip = ip
        self.boot_protocol = boot_protocol
        self.on_boot = on_boot
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GuestNicConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GuestNicConfiguration.subclass:
            return GuestNicConfiguration.subclass(*args_, **kwargs_)
        else:
            return GuestNicConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    ipProp = property(get_ip, set_ip)
    def get_boot_protocol(self):
        return self.boot_protocol
    def set_boot_protocol(self, boot_protocol):
        self.boot_protocol = boot_protocol
    boot_protocolProp = property(get_boot_protocol, set_boot_protocol)
    def get_on_boot(self):
        return self.on_boot
    def set_on_boot(self, on_boot):
        self.on_boot = on_boot
    on_bootProp = property(get_on_boot, set_on_boot)
    def hasContent_(self):
        if (
            self.name is not None or
            self.ip is not None or
            self.boot_protocol is not None or
            self.on_boot is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nic_configuration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nic_configuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nic_configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nic_configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nic_configuration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nic_configuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.ip is not None:
            self.ip.export(outfile, level, namespaceprefix_, name_='ip', pretty_print=pretty_print)
        if self.boot_protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sboot_protocol>%s</%sboot_protocol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.boot_protocol), input_name='boot_protocol')), namespaceprefix_ , eol_))
        if self.on_boot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%son_boot>%s</%son_boot>%s' % (namespaceprefix_ , self.gds_format_boolean(self.on_boot, input_name='on_boot'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'ip':
            obj_ = IP.factory(parent_object_=self)
            obj_.build(child_)
            self.ip = obj_
            obj_.original_tagname_ = 'ip'
        elif nodeName_ == 'boot_protocol':
            boot_protocol_ = child_.text
            boot_protocol_ = self.gds_validate_string(boot_protocol_, node, 'boot_protocol')
            self.boot_protocol = boot_protocol_
        elif nodeName_ == 'on_boot':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'on_boot')
            self.on_boot = ival_
# end class GuestNicConfiguration


class GuestNicsConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nic_configuration=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if nic_configuration is None:
            self.nic_configuration = []
        else:
            self.nic_configuration = nic_configuration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GuestNicsConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GuestNicsConfiguration.subclass:
            return GuestNicsConfiguration.subclass(*args_, **kwargs_)
        else:
            return GuestNicsConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nic_configuration(self):
        return self.nic_configuration
    def set_nic_configuration(self, nic_configuration):
        self.nic_configuration = nic_configuration
    def add_nic_configuration(self, value):
        self.nic_configuration.append(value)
    def insert_nic_configuration_at(self, index, value):
        self.nic_configuration.insert(index, value)
    def replace_nic_configuration_at(self, index, value):
        self.nic_configuration[index] = value
    nic_configurationProp = property(get_nic_configuration, set_nic_configuration)
    def hasContent_(self):
        if (
            self.nic_configuration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nic_configurations', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nic_configurations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nic_configurations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nic_configurations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nic_configurations'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nic_configurations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nic_configuration_ in self.nic_configuration:
            nic_configuration_.export(outfile, level, namespaceprefix_, name_='nic_configuration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nic_configuration':
            obj_ = GuestNicConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.nic_configuration.append(obj_)
            obj_.original_tagname_ = 'nic_configuration'
# end class GuestNicsConfiguration


class HostNICStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host_nic_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if host_nic_state is None:
            self.host_nic_state = []
        else:
            self.host_nic_state = host_nic_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostNICStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostNICStates.subclass:
            return HostNICStates.subclass(*args_, **kwargs_)
        else:
            return HostNICStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_nic_state(self):
        return self.host_nic_state
    def set_host_nic_state(self, host_nic_state):
        self.host_nic_state = host_nic_state
    def add_host_nic_state(self, value):
        self.host_nic_state.append(value)
    def insert_host_nic_state_at(self, index, value):
        self.host_nic_state.insert(index, value)
    def replace_host_nic_state_at(self, index, value):
        self.host_nic_state[index] = value
    host_nic_stateProp = property(get_host_nic_state, set_host_nic_state)
    def hasContent_(self):
        if (
            self.host_nic_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_nic_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_nic_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_nic_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_nic_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_nic_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_nic_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_nic_state_ in self.host_nic_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost_nic_state>%s</%shost_nic_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(host_nic_state_), input_name='host_nic_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_nic_state':
            host_nic_state_ = child_.text
            host_nic_state_ = self.gds_validate_string(host_nic_state_, node, 'host_nic_state')
            self.host_nic_state.append(host_nic_state_)
# end class HostNICStates


class Slaves(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host_nic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if host_nic is None:
            self.host_nic = []
        else:
            self.host_nic = host_nic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Slaves)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Slaves.subclass:
            return Slaves.subclass(*args_, **kwargs_)
        else:
            return Slaves(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_nic(self):
        return self.host_nic
    def set_host_nic(self, host_nic):
        self.host_nic = host_nic
    def add_host_nic(self, value):
        self.host_nic.append(value)
    def insert_host_nic_at(self, index, value):
        self.host_nic.insert(index, value)
    def replace_host_nic_at(self, index, value):
        self.host_nic[index] = value
    host_nicProp = property(get_host_nic, set_host_nic)
    def hasContent_(self):
        if (
            self.host_nic
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='slaves', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slaves')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slaves')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='slaves', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='slaves'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='slaves', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_nic_ in self.host_nic:
            host_nic_.export(outfile, level, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_nic':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic.append(obj_)
            obj_.original_tagname_ = 'host_nic'
# end class Slaves


class Bonding(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, options=None, slaves=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.options = options
        self.slaves = slaves
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bonding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bonding.subclass:
            return Bonding.subclass(*args_, **kwargs_)
        else:
            return Bonding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_options(self):
        return self.options
    def set_options(self, options):
        self.options = options
    optionsProp = property(get_options, set_options)
    def get_slaves(self):
        return self.slaves
    def set_slaves(self, slaves):
        self.slaves = slaves
    slavesProp = property(get_slaves, set_slaves)
    def hasContent_(self):
        if (
            self.options is not None or
            self.slaves is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='bonding', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bonding')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bonding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='bonding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bonding'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='bonding', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.options is not None:
            self.options.export(outfile, level, namespaceprefix_, name_='options', pretty_print=pretty_print)
        if self.slaves is not None:
            self.slaves.export(outfile, level, namespaceprefix_, name_='slaves', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'options':
            obj_ = Options.factory(parent_object_=self)
            obj_.build(child_)
            self.options = obj_
            obj_.original_tagname_ = 'options'
        elif nodeName_ == 'slaves':
            obj_ = Slaves.factory(parent_object_=self)
            obj_.build(child_)
            self.slaves = obj_
            obj_.original_tagname_ = 'slaves'
# end class Bonding


class NetworkAttachment(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, network=None, host_nic=None, ip_address_assignments=None, properties=None, reported_configurations=None, host=None, qos=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(NetworkAttachment, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.network = network
        self.host_nic = host_nic
        self.ip_address_assignments = ip_address_assignments
        self.properties = properties
        self.reported_configurations = reported_configurations
        self.host = host
        self.qos = qos
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetworkAttachment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetworkAttachment.subclass:
            return NetworkAttachment.subclass(*args_, **kwargs_)
        else:
            return NetworkAttachment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    networkProp = property(get_network, set_network)
    def get_host_nic(self):
        return self.host_nic
    def set_host_nic(self, host_nic):
        self.host_nic = host_nic
    host_nicProp = property(get_host_nic, set_host_nic)
    def get_ip_address_assignments(self):
        return self.ip_address_assignments
    def set_ip_address_assignments(self, ip_address_assignments):
        self.ip_address_assignments = ip_address_assignments
    ip_address_assignmentsProp = property(get_ip_address_assignments, set_ip_address_assignments)
    def get_properties(self):
        return self.properties
    def set_properties(self, properties):
        self.properties = properties
    propertiesProp = property(get_properties, set_properties)
    def get_reported_configurations(self):
        return self.reported_configurations
    def set_reported_configurations(self, reported_configurations):
        self.reported_configurations = reported_configurations
    reported_configurationsProp = property(get_reported_configurations, set_reported_configurations)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    qosProp = property(get_qos, set_qos)
    def hasContent_(self):
        if (
            self.network is not None or
            self.host_nic is not None or
            self.ip_address_assignments is not None or
            self.properties is not None or
            self.reported_configurations is not None or
            self.host is not None or
            self.qos is not None or
            super(NetworkAttachment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='network_attachment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('network_attachment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_attachment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='network_attachment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='network_attachment'):
        super(NetworkAttachment, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_attachment')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='network_attachment', fromsubclass_=False, pretty_print=True):
        super(NetworkAttachment, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network is not None:
            self.network.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
        if self.host_nic is not None:
            self.host_nic.export(outfile, level, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
        if self.ip_address_assignments is not None:
            self.ip_address_assignments.export(outfile, level, namespaceprefix_, name_='ip_address_assignments', pretty_print=pretty_print)
        if self.properties is not None:
            self.properties.export(outfile, level, namespaceprefix_, name_='properties', pretty_print=pretty_print)
        if self.reported_configurations is not None:
            self.reported_configurations.export(outfile, level, namespaceprefix_, name_='reported_configurations', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.qos is not None:
            self.qos.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkAttachment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network = obj_
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'host_nic':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic = obj_
            obj_.original_tagname_ = 'host_nic'
        elif nodeName_ == 'ip_address_assignments':
            obj_ = IpAddressAssignments.factory(parent_object_=self)
            obj_.build(child_)
            self.ip_address_assignments = obj_
            obj_.original_tagname_ = 'ip_address_assignments'
        elif nodeName_ == 'properties':
            obj_ = Properties.factory(parent_object_=self)
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        elif nodeName_ == 'reported_configurations':
            obj_ = ReportedConfigurations.factory(parent_object_=self)
            obj_.build(child_)
            self.reported_configurations = obj_
            obj_.original_tagname_ = 'reported_configurations'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos = obj_
            obj_.original_tagname_ = 'qos'
        super(NetworkAttachment, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkAttachment


class NetworkAttachments(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, network_attachment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(NetworkAttachments, self).__init__(actions, size, total, active,  **kwargs_)
        if network_attachment is None:
            self.network_attachment = []
        else:
            self.network_attachment = network_attachment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NetworkAttachments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NetworkAttachments.subclass:
            return NetworkAttachments.subclass(*args_, **kwargs_)
        else:
            return NetworkAttachments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_attachment(self):
        return self.network_attachment
    def set_network_attachment(self, network_attachment):
        self.network_attachment = network_attachment
    def add_network_attachment(self, value):
        self.network_attachment.append(value)
    def insert_network_attachment_at(self, index, value):
        self.network_attachment.insert(index, value)
    def replace_network_attachment_at(self, index, value):
        self.network_attachment[index] = value
    network_attachmentProp = property(get_network_attachment, set_network_attachment)
    def hasContent_(self):
        if (
            self.network_attachment or
            super(NetworkAttachments, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='network_attachments', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('network_attachments')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_attachments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='network_attachments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='network_attachments'):
        super(NetworkAttachments, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='network_attachments')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='network_attachments', fromsubclass_=False, pretty_print=True):
        super(NetworkAttachments, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for network_attachment_ in self.network_attachment:
            network_attachment_.export(outfile, level, namespaceprefix_, name_='network_attachment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkAttachments, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network_attachment':
            obj_ = NetworkAttachment.factory(parent_object_=self)
            obj_.build(child_)
            self.network_attachment.append(obj_)
            obj_.original_tagname_ = 'network_attachment'
        super(NetworkAttachments, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkAttachments


class ReportedConfigurations(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, in_sync=None, reported_configuration=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.in_sync = in_sync
        if reported_configuration is None:
            self.reported_configuration = []
        else:
            self.reported_configuration = reported_configuration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportedConfigurations)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportedConfigurations.subclass:
            return ReportedConfigurations.subclass(*args_, **kwargs_)
        else:
            return ReportedConfigurations(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_in_sync(self):
        return self.in_sync
    def set_in_sync(self, in_sync):
        self.in_sync = in_sync
    in_syncProp = property(get_in_sync, set_in_sync)
    def get_reported_configuration(self):
        return self.reported_configuration
    def set_reported_configuration(self, reported_configuration):
        self.reported_configuration = reported_configuration
    def add_reported_configuration(self, value):
        self.reported_configuration.append(value)
    def insert_reported_configuration_at(self, index, value):
        self.reported_configuration.insert(index, value)
    def replace_reported_configuration_at(self, index, value):
        self.reported_configuration[index] = value
    reported_configurationProp = property(get_reported_configuration, set_reported_configuration)
    def hasContent_(self):
        if (
            self.in_sync is not None or
            self.reported_configuration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ReportedConfigurations', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReportedConfigurations')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReportedConfigurations')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ReportedConfigurations', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReportedConfigurations'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ReportedConfigurations', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.in_sync is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sin_sync>%s</%sin_sync>%s' % (namespaceprefix_ , self.gds_format_boolean(self.in_sync, input_name='in_sync'), namespaceprefix_ , eol_))
        for reported_configuration_ in self.reported_configuration:
            reported_configuration_.export(outfile, level, namespaceprefix_, name_='reported_configuration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'in_sync':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'in_sync')
            self.in_sync = ival_
        elif nodeName_ == 'reported_configuration':
            obj_ = ReportedConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.reported_configuration.append(obj_)
            obj_.original_tagname_ = 'reported_configuration'
# end class ReportedConfigurations


class ReportedConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, expected_value=None, actual_value=None, in_sync=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.expected_value = expected_value
        self.actual_value = actual_value
        self.in_sync = in_sync
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReportedConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReportedConfiguration.subclass:
            return ReportedConfiguration.subclass(*args_, **kwargs_)
        else:
            return ReportedConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_expected_value(self):
        return self.expected_value
    def set_expected_value(self, expected_value):
        self.expected_value = expected_value
    expected_valueProp = property(get_expected_value, set_expected_value)
    def get_actual_value(self):
        return self.actual_value
    def set_actual_value(self, actual_value):
        self.actual_value = actual_value
    actual_valueProp = property(get_actual_value, set_actual_value)
    def get_in_sync(self):
        return self.in_sync
    def set_in_sync(self, in_sync):
        self.in_sync = in_sync
    in_syncProp = property(get_in_sync, set_in_sync)
    def hasContent_(self):
        if (
            self.name is not None or
            self.expected_value is not None or
            self.actual_value is not None or
            self.in_sync is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ReportedConfiguration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReportedConfiguration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReportedConfiguration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ReportedConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReportedConfiguration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ReportedConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.expected_value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexpected_value>%s</%sexpected_value>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.expected_value), input_name='expected_value')), namespaceprefix_ , eol_))
        if self.actual_value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactual_value>%s</%sactual_value>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.actual_value), input_name='actual_value')), namespaceprefix_ , eol_))
        if self.in_sync is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sin_sync>%s</%sin_sync>%s' % (namespaceprefix_ , self.gds_format_boolean(self.in_sync, input_name='in_sync'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'expected_value':
            expected_value_ = child_.text
            expected_value_ = self.gds_validate_string(expected_value_, node, 'expected_value')
            self.expected_value = expected_value_
        elif nodeName_ == 'actual_value':
            actual_value_ = child_.text
            actual_value_ = self.gds_validate_string(actual_value_, node, 'actual_value')
            self.actual_value = actual_value_
        elif nodeName_ == 'in_sync':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'in_sync')
            self.in_sync = ival_
# end class ReportedConfiguration


class IpAddressAssignments(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ip_address_assignment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if ip_address_assignment is None:
            self.ip_address_assignment = []
        else:
            self.ip_address_assignment = ip_address_assignment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IpAddressAssignments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IpAddressAssignments.subclass:
            return IpAddressAssignments.subclass(*args_, **kwargs_)
        else:
            return IpAddressAssignments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip_address_assignment(self):
        return self.ip_address_assignment
    def set_ip_address_assignment(self, ip_address_assignment):
        self.ip_address_assignment = ip_address_assignment
    def add_ip_address_assignment(self, value):
        self.ip_address_assignment.append(value)
    def insert_ip_address_assignment_at(self, index, value):
        self.ip_address_assignment.insert(index, value)
    def replace_ip_address_assignment_at(self, index, value):
        self.ip_address_assignment[index] = value
    ip_address_assignmentProp = property(get_ip_address_assignment, set_ip_address_assignment)
    def hasContent_(self):
        if (
            self.ip_address_assignment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='IpAddressAssignments', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IpAddressAssignments')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IpAddressAssignments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='IpAddressAssignments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IpAddressAssignments'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='IpAddressAssignments', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ip_address_assignment_ in self.ip_address_assignment:
            ip_address_assignment_.export(outfile, level, namespaceprefix_, name_='ip_address_assignment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip_address_assignment':
            obj_ = IpAddressAssignment.factory(parent_object_=self)
            obj_.build(child_)
            self.ip_address_assignment.append(obj_)
            obj_.original_tagname_ = 'ip_address_assignment'
# end class IpAddressAssignments


class IpAddressAssignment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ip=None, assignment_method=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ip = ip
        self.assignment_method = assignment_method
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IpAddressAssignment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IpAddressAssignment.subclass:
            return IpAddressAssignment.subclass(*args_, **kwargs_)
        else:
            return IpAddressAssignment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    ipProp = property(get_ip, set_ip)
    def get_assignment_method(self):
        return self.assignment_method
    def set_assignment_method(self, assignment_method):
        self.assignment_method = assignment_method
    assignment_methodProp = property(get_assignment_method, set_assignment_method)
    def hasContent_(self):
        if (
            self.ip is not None or
            self.assignment_method is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='IpAddressAssignment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IpAddressAssignment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IpAddressAssignment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='IpAddressAssignment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IpAddressAssignment'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='IpAddressAssignment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ip is not None:
            self.ip.export(outfile, level, namespaceprefix_, name_='ip', pretty_print=pretty_print)
        if self.assignment_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sassignment_method>%s</%sassignment_method>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.assignment_method), input_name='assignment_method')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip':
            obj_ = IP.factory(parent_object_=self)
            obj_.build(child_)
            self.ip = obj_
            obj_.original_tagname_ = 'ip'
        elif nodeName_ == 'assignment_method':
            assignment_method_ = child_.text
            assignment_method_ = self.gds_validate_string(assignment_method_, node, 'assignment_method')
            self.assignment_method = assignment_method_
# end class IpAddressAssignment


class HostStorage(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, storage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HostStorage, self).__init__(actions, size, total, active,  **kwargs_)
        if storage is None:
            self.storage = []
        else:
            self.storage = storage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HostStorage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HostStorage.subclass:
            return HostStorage.subclass(*args_, **kwargs_)
        else:
            return HostStorage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage(self):
        return self.storage
    def set_storage(self, storage):
        self.storage = storage
    def add_storage(self, value):
        self.storage.append(value)
    def insert_storage_at(self, index, value):
        self.storage.insert(index, value)
    def replace_storage_at(self, index, value):
        self.storage[index] = value
    storageProp = property(get_storage, set_storage)
    def hasContent_(self):
        if (
            self.storage or
            super(HostStorage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_storage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_storage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_storage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_storage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_storage'):
        super(HostStorage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_storage')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_storage', fromsubclass_=False, pretty_print=True):
        super(HostStorage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_ in self.storage:
            storage_.export(outfile, level, namespaceprefix_, name_='storage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HostStorage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage':
            obj_ = Storage.factory(parent_object_=self)
            obj_.build(child_)
            self.storage.append(obj_)
            obj_.original_tagname_ = 'storage'
        super(HostStorage, self).buildChildren(child_, node, nodeName_, True)
# end class HostStorage


class Bookmark(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Bookmark, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bookmark)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bookmark.subclass:
            return Bookmark.subclass(*args_, **kwargs_)
        else:
            return Bookmark(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def hasContent_(self):
        if (
            self.value is not None or
            super(Bookmark, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='bookmark', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bookmark')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bookmark')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='bookmark', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bookmark'):
        super(Bookmark, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bookmark')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='bookmark', fromsubclass_=False, pretty_print=True):
        super(Bookmark, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Bookmark, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        super(Bookmark, self).buildChildren(child_, node, nodeName_, True)
# end class Bookmark


class Bookmarks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, bookmark=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Bookmarks, self).__init__(actions, size, total, active,  **kwargs_)
        if bookmark is None:
            self.bookmark = []
        else:
            self.bookmark = bookmark
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Bookmarks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Bookmarks.subclass:
            return Bookmarks.subclass(*args_, **kwargs_)
        else:
            return Bookmarks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bookmark(self):
        return self.bookmark
    def set_bookmark(self, bookmark):
        self.bookmark = bookmark
    def add_bookmark(self, value):
        self.bookmark.append(value)
    def insert_bookmark_at(self, index, value):
        self.bookmark.insert(index, value)
    def replace_bookmark_at(self, index, value):
        self.bookmark[index] = value
    bookmarkProp = property(get_bookmark, set_bookmark)
    def hasContent_(self):
        if (
            self.bookmark or
            super(Bookmarks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='bookmarks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bookmarks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bookmarks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='bookmarks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bookmarks'):
        super(Bookmarks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bookmarks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='bookmarks', fromsubclass_=False, pretty_print=True):
        super(Bookmarks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for bookmark_ in self.bookmark:
            bookmark_.export(outfile, level, namespaceprefix_, name_='bookmark', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Bookmarks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bookmark':
            obj_ = Bookmark.factory(parent_object_=self)
            obj_.build(child_)
            self.bookmark.append(obj_)
            obj_.original_tagname_ = 'bookmark'
        super(Bookmarks, self).buildChildren(child_, node, nodeName_, True)
# end class Bookmarks


class TagParent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.tag = tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagParent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagParent.subclass:
            return TagParent.subclass(*args_, **kwargs_)
        else:
            return TagParent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    tagProp = property(get_tag, set_tag)
    def hasContent_(self):
        if (
            self.tag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='TagParent', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagParent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagParent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='TagParent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagParent'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='TagParent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tag is not None:
            self.tag.export(outfile, level, namespaceprefix_, name_='tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.tag = obj_
            obj_.original_tagname_ = 'tag'
# end class TagParent


class Tag(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host=None, vm=None, template=None, user=None, group=None, parent=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Tag, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.host = host
        self.vm = vm
        self.template = template
        self.user = user
        self.group = group
        self.parent = parent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tag.subclass:
            return Tag.subclass(*args_, **kwargs_)
        else:
            return Tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    groupProp = property(get_group, set_group)
    def get_parent(self):
        return self.parent
    def set_parent(self, parent):
        self.parent = parent
    parentProp = property(get_parent, set_parent)
    def hasContent_(self):
        if (
            self.host is not None or
            self.vm is not None or
            self.template is not None or
            self.user is not None or
            self.group is not None or
            self.parent is not None or
            super(Tag, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='tag', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tag')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tag'):
        super(Tag, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tag')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='tag', fromsubclass_=False, pretty_print=True):
        super(Tag, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.user is not None:
            self.user.export(outfile, level, namespaceprefix_, name_='user', pretty_print=pretty_print)
        if self.group is not None:
            self.group.export(outfile, level, namespaceprefix_, name_='group', pretty_print=pretty_print)
        if self.parent is not None:
            self.parent.export(outfile, level, namespaceprefix_, name_='parent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Tag, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'user':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.user = obj_
            obj_.original_tagname_ = 'user'
        elif nodeName_ == 'group':
            obj_ = Group.factory(parent_object_=self)
            obj_.build(child_)
            self.group = obj_
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'parent':
            obj_ = TagParent.factory(parent_object_=self)
            obj_.build(child_)
            self.parent = obj_
            obj_.original_tagname_ = 'parent'
        super(Tag, self).buildChildren(child_, node, nodeName_, True)
# end class Tag


class Tags(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Tags, self).__init__(actions, size, total, active,  **kwargs_)
        if tag is None:
            self.tag = []
        else:
            self.tag = tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tags)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tags.subclass:
            return Tags.subclass(*args_, **kwargs_)
        else:
            return Tags(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def add_tag(self, value):
        self.tag.append(value)
    def insert_tag_at(self, index, value):
        self.tag.insert(index, value)
    def replace_tag_at(self, index, value):
        self.tag[index] = value
    tagProp = property(get_tag, set_tag)
    def hasContent_(self):
        if (
            self.tag or
            super(Tags, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='tags', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tags')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tags')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='tags', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='tags'):
        super(Tags, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='tags')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='tags', fromsubclass_=False, pretty_print=True):
        super(Tags, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tag_ in self.tag:
            tag_.export(outfile, level, namespaceprefix_, name_='tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Tags, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.tag.append(obj_)
            obj_.original_tagname_ = 'tag'
        super(Tags, self).buildChildren(child_, node, nodeName_, True)
# end class Tags


class Usb(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.enabled = enabled
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Usb)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Usb.subclass:
            return Usb.subclass(*args_, **kwargs_)
        else:
            return Usb(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    enabledProp = property(get_enabled, set_enabled)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.enabled is not None or
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='usb', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('usb')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='usb')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='usb', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='usb'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='usb', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class Usb


class Quota(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, data_center=None, vms=None, disks=None, users=None, cluster_soft_limit_pct=None, cluster_hard_limit_pct=None, storage_soft_limit_pct=None, storage_hard_limit_pct=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Quota, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.data_center = data_center
        self.vms = vms
        self.disks = disks
        self.users = users
        self.cluster_soft_limit_pct = cluster_soft_limit_pct
        self.cluster_hard_limit_pct = cluster_hard_limit_pct
        self.storage_soft_limit_pct = storage_soft_limit_pct
        self.storage_hard_limit_pct = storage_hard_limit_pct
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quota)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quota.subclass:
            return Quota.subclass(*args_, **kwargs_)
        else:
            return Quota(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_vms(self):
        return self.vms
    def set_vms(self, vms):
        self.vms = vms
    vmsProp = property(get_vms, set_vms)
    def get_disks(self):
        return self.disks
    def set_disks(self, disks):
        self.disks = disks
    disksProp = property(get_disks, set_disks)
    def get_users(self):
        return self.users
    def set_users(self, users):
        self.users = users
    usersProp = property(get_users, set_users)
    def get_cluster_soft_limit_pct(self):
        return self.cluster_soft_limit_pct
    def set_cluster_soft_limit_pct(self, cluster_soft_limit_pct):
        self.cluster_soft_limit_pct = cluster_soft_limit_pct
    cluster_soft_limit_pctProp = property(get_cluster_soft_limit_pct, set_cluster_soft_limit_pct)
    def get_cluster_hard_limit_pct(self):
        return self.cluster_hard_limit_pct
    def set_cluster_hard_limit_pct(self, cluster_hard_limit_pct):
        self.cluster_hard_limit_pct = cluster_hard_limit_pct
    cluster_hard_limit_pctProp = property(get_cluster_hard_limit_pct, set_cluster_hard_limit_pct)
    def get_storage_soft_limit_pct(self):
        return self.storage_soft_limit_pct
    def set_storage_soft_limit_pct(self, storage_soft_limit_pct):
        self.storage_soft_limit_pct = storage_soft_limit_pct
    storage_soft_limit_pctProp = property(get_storage_soft_limit_pct, set_storage_soft_limit_pct)
    def get_storage_hard_limit_pct(self):
        return self.storage_hard_limit_pct
    def set_storage_hard_limit_pct(self, storage_hard_limit_pct):
        self.storage_hard_limit_pct = storage_hard_limit_pct
    storage_hard_limit_pctProp = property(get_storage_hard_limit_pct, set_storage_hard_limit_pct)
    def hasContent_(self):
        if (
            self.data_center is not None or
            self.vms is not None or
            self.disks is not None or
            self.users is not None or
            self.cluster_soft_limit_pct is not None or
            self.cluster_hard_limit_pct is not None or
            self.storage_soft_limit_pct is not None or
            self.storage_hard_limit_pct is not None or
            super(Quota, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='quota', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quota')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quota')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='quota', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quota'):
        super(Quota, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quota')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='quota', fromsubclass_=False, pretty_print=True):
        super(Quota, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.vms is not None:
            self.vms.export(outfile, level, namespaceprefix_, name_='vms', pretty_print=pretty_print)
        if self.disks is not None:
            self.disks.export(outfile, level, namespaceprefix_, name_='disks', pretty_print=pretty_print)
        if self.users is not None:
            self.users.export(outfile, level, namespaceprefix_, name_='users', pretty_print=pretty_print)
        if self.cluster_soft_limit_pct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scluster_soft_limit_pct>%s</%scluster_soft_limit_pct>%s' % (namespaceprefix_ , self.gds_format_integer(self.cluster_soft_limit_pct, input_name='cluster_soft_limit_pct'), namespaceprefix_ , eol_))
        if self.cluster_hard_limit_pct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scluster_hard_limit_pct>%s</%scluster_hard_limit_pct>%s' % (namespaceprefix_ , self.gds_format_integer(self.cluster_hard_limit_pct, input_name='cluster_hard_limit_pct'), namespaceprefix_ , eol_))
        if self.storage_soft_limit_pct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_soft_limit_pct>%s</%sstorage_soft_limit_pct>%s' % (namespaceprefix_ , self.gds_format_integer(self.storage_soft_limit_pct, input_name='storage_soft_limit_pct'), namespaceprefix_ , eol_))
        if self.storage_hard_limit_pct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstorage_hard_limit_pct>%s</%sstorage_hard_limit_pct>%s' % (namespaceprefix_ , self.gds_format_integer(self.storage_hard_limit_pct, input_name='storage_hard_limit_pct'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Quota, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'vms':
            obj_ = VMs.factory(parent_object_=self)
            obj_.build(child_)
            self.vms = obj_
            obj_.original_tagname_ = 'vms'
        elif nodeName_ == 'disks':
            obj_ = Disks.factory(parent_object_=self)
            obj_.build(child_)
            self.disks = obj_
            obj_.original_tagname_ = 'disks'
        elif nodeName_ == 'users':
            obj_ = Users.factory(parent_object_=self)
            obj_.build(child_)
            self.users = obj_
            obj_.original_tagname_ = 'users'
        elif nodeName_ == 'cluster_soft_limit_pct' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cluster_soft_limit_pct')
            self.cluster_soft_limit_pct = ival_
        elif nodeName_ == 'cluster_hard_limit_pct' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cluster_hard_limit_pct')
            self.cluster_hard_limit_pct = ival_
        elif nodeName_ == 'storage_soft_limit_pct' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'storage_soft_limit_pct')
            self.storage_soft_limit_pct = ival_
        elif nodeName_ == 'storage_hard_limit_pct' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'storage_hard_limit_pct')
            self.storage_hard_limit_pct = ival_
        super(Quota, self).buildChildren(child_, node, nodeName_, True)
# end class Quota


class Quotas(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, quota=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Quotas, self).__init__(actions, size, total, active,  **kwargs_)
        if quota is None:
            self.quota = []
        else:
            self.quota = quota
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Quotas)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Quotas.subclass:
            return Quotas.subclass(*args_, **kwargs_)
        else:
            return Quotas(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quota(self):
        return self.quota
    def set_quota(self, quota):
        self.quota = quota
    def add_quota(self, value):
        self.quota.append(value)
    def insert_quota_at(self, index, value):
        self.quota.insert(index, value)
    def replace_quota_at(self, index, value):
        self.quota[index] = value
    quotaProp = property(get_quota, set_quota)
    def hasContent_(self):
        if (
            self.quota or
            super(Quotas, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='quotas', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('quotas')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quotas')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='quotas', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='quotas'):
        super(Quotas, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='quotas')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='quotas', fromsubclass_=False, pretty_print=True):
        super(Quotas, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for quota_ in self.quota:
            quota_.export(outfile, level, namespaceprefix_, name_='quota', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Quotas, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quota':
            obj_ = Quota.factory(parent_object_=self)
            obj_.build(child_)
            self.quota.append(obj_)
            obj_.original_tagname_ = 'quota'
        super(Quotas, self).buildChildren(child_, node, nodeName_, True)
# end class Quotas


class QuotaStorageLimit(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, quota=None, storage_domain=None, limit=None, usage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QuotaStorageLimit, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.quota = quota
        self.storage_domain = storage_domain
        self.limit = limit
        self.usage = usage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotaStorageLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotaStorageLimit.subclass:
            return QuotaStorageLimit.subclass(*args_, **kwargs_)
        else:
            return QuotaStorageLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quota(self):
        return self.quota
    def set_quota(self, quota):
        self.quota = quota
    quotaProp = property(get_quota, set_quota)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_limit(self):
        return self.limit
    def set_limit(self, limit):
        self.limit = limit
    limitProp = property(get_limit, set_limit)
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    usageProp = property(get_usage, set_usage)
    def hasContent_(self):
        if (
            self.quota is not None or
            self.storage_domain is not None or
            self.limit is not None or
            self.usage is not None or
            super(QuotaStorageLimit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_quota_limit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_quota_limit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_quota_limit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_quota_limit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_quota_limit'):
        super(QuotaStorageLimit, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_quota_limit')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_quota_limit', fromsubclass_=False, pretty_print=True):
        super(QuotaStorageLimit, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quota is not None:
            self.quota.export(outfile, level, namespaceprefix_, name_='quota', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimit>%s</%slimit>%s' % (namespaceprefix_ , self.gds_format_integer(self.limit, input_name='limit'), namespaceprefix_ , eol_))
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_format_double(self.usage, input_name='usage'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QuotaStorageLimit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quota':
            obj_ = Quota.factory(parent_object_=self)
            obj_.build(child_)
            self.quota = obj_
            obj_.original_tagname_ = 'quota'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'limit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'limit')
            self.limit = ival_
        elif nodeName_ == 'usage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'usage')
            self.usage = fval_
        super(QuotaStorageLimit, self).buildChildren(child_, node, nodeName_, True)
# end class QuotaStorageLimit


class QuotaStorageLimits(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, storage_quota_limit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QuotaStorageLimits, self).__init__(actions, size, total, active,  **kwargs_)
        if storage_quota_limit is None:
            self.storage_quota_limit = []
        else:
            self.storage_quota_limit = storage_quota_limit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotaStorageLimits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotaStorageLimits.subclass:
            return QuotaStorageLimits.subclass(*args_, **kwargs_)
        else:
            return QuotaStorageLimits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storage_quota_limit(self):
        return self.storage_quota_limit
    def set_storage_quota_limit(self, storage_quota_limit):
        self.storage_quota_limit = storage_quota_limit
    def add_storage_quota_limit(self, value):
        self.storage_quota_limit.append(value)
    def insert_storage_quota_limit_at(self, index, value):
        self.storage_quota_limit.insert(index, value)
    def replace_storage_quota_limit_at(self, index, value):
        self.storage_quota_limit[index] = value
    storage_quota_limitProp = property(get_storage_quota_limit, set_storage_quota_limit)
    def hasContent_(self):
        if (
            self.storage_quota_limit or
            super(QuotaStorageLimits, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='storage_quota_limits', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('storage_quota_limits')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_quota_limits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='storage_quota_limits', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='storage_quota_limits'):
        super(QuotaStorageLimits, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='storage_quota_limits')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='storage_quota_limits', fromsubclass_=False, pretty_print=True):
        super(QuotaStorageLimits, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for storage_quota_limit_ in self.storage_quota_limit:
            storage_quota_limit_.export(outfile, level, namespaceprefix_, name_='storage_quota_limit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QuotaStorageLimits, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'storage_quota_limit':
            obj_ = QuotaStorageLimit.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_quota_limit.append(obj_)
            obj_.original_tagname_ = 'storage_quota_limit'
        super(QuotaStorageLimits, self).buildChildren(child_, node, nodeName_, True)
# end class QuotaStorageLimits


class QuotaClusterLimit(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, quota=None, cluster=None, vcpu_limit=None, vcpu_usage=None, memory_limit=None, memory_usage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QuotaClusterLimit, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.quota = quota
        self.cluster = cluster
        self.vcpu_limit = vcpu_limit
        self.vcpu_usage = vcpu_usage
        self.memory_limit = memory_limit
        self.memory_usage = memory_usage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotaClusterLimit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotaClusterLimit.subclass:
            return QuotaClusterLimit.subclass(*args_, **kwargs_)
        else:
            return QuotaClusterLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quota(self):
        return self.quota
    def set_quota(self, quota):
        self.quota = quota
    quotaProp = property(get_quota, set_quota)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_vcpu_limit(self):
        return self.vcpu_limit
    def set_vcpu_limit(self, vcpu_limit):
        self.vcpu_limit = vcpu_limit
    vcpu_limitProp = property(get_vcpu_limit, set_vcpu_limit)
    def get_vcpu_usage(self):
        return self.vcpu_usage
    def set_vcpu_usage(self, vcpu_usage):
        self.vcpu_usage = vcpu_usage
    vcpu_usageProp = property(get_vcpu_usage, set_vcpu_usage)
    def get_memory_limit(self):
        return self.memory_limit
    def set_memory_limit(self, memory_limit):
        self.memory_limit = memory_limit
    memory_limitProp = property(get_memory_limit, set_memory_limit)
    def get_memory_usage(self):
        return self.memory_usage
    def set_memory_usage(self, memory_usage):
        self.memory_usage = memory_usage
    memory_usageProp = property(get_memory_usage, set_memory_usage)
    def hasContent_(self):
        if (
            self.quota is not None or
            self.cluster is not None or
            self.vcpu_limit is not None or
            self.vcpu_usage is not None or
            self.memory_limit is not None or
            self.memory_usage is not None or
            super(QuotaClusterLimit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cluster_quota_limit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cluster_quota_limit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cluster_quota_limit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cluster_quota_limit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cluster_quota_limit'):
        super(QuotaClusterLimit, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cluster_quota_limit')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cluster_quota_limit', fromsubclass_=False, pretty_print=True):
        super(QuotaClusterLimit, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quota is not None:
            self.quota.export(outfile, level, namespaceprefix_, name_='quota', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.vcpu_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svcpu_limit>%s</%svcpu_limit>%s' % (namespaceprefix_ , self.gds_format_integer(self.vcpu_limit, input_name='vcpu_limit'), namespaceprefix_ , eol_))
        if self.vcpu_usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svcpu_usage>%s</%svcpu_usage>%s' % (namespaceprefix_ , self.gds_format_integer(self.vcpu_usage, input_name='vcpu_usage'), namespaceprefix_ , eol_))
        if self.memory_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemory_limit>%s</%smemory_limit>%s' % (namespaceprefix_ , self.gds_format_double(self.memory_limit, input_name='memory_limit'), namespaceprefix_ , eol_))
        if self.memory_usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemory_usage>%s</%smemory_usage>%s' % (namespaceprefix_ , self.gds_format_double(self.memory_usage, input_name='memory_usage'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QuotaClusterLimit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quota':
            obj_ = Quota.factory(parent_object_=self)
            obj_.build(child_)
            self.quota = obj_
            obj_.original_tagname_ = 'quota'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'vcpu_limit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vcpu_limit')
            self.vcpu_limit = ival_
        elif nodeName_ == 'vcpu_usage' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'vcpu_usage')
            self.vcpu_usage = ival_
        elif nodeName_ == 'memory_limit' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'memory_limit')
            self.memory_limit = fval_
        elif nodeName_ == 'memory_usage' and child_.text:
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'memory_usage')
            self.memory_usage = fval_
        super(QuotaClusterLimit, self).buildChildren(child_, node, nodeName_, True)
# end class QuotaClusterLimit


class QuotaClusterLimits(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, cluster_quota_limit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QuotaClusterLimits, self).__init__(actions, size, total, active,  **kwargs_)
        if cluster_quota_limit is None:
            self.cluster_quota_limit = []
        else:
            self.cluster_quota_limit = cluster_quota_limit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuotaClusterLimits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuotaClusterLimits.subclass:
            return QuotaClusterLimits.subclass(*args_, **kwargs_)
        else:
            return QuotaClusterLimits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cluster_quota_limit(self):
        return self.cluster_quota_limit
    def set_cluster_quota_limit(self, cluster_quota_limit):
        self.cluster_quota_limit = cluster_quota_limit
    def add_cluster_quota_limit(self, value):
        self.cluster_quota_limit.append(value)
    def insert_cluster_quota_limit_at(self, index, value):
        self.cluster_quota_limit.insert(index, value)
    def replace_cluster_quota_limit_at(self, index, value):
        self.cluster_quota_limit[index] = value
    cluster_quota_limitProp = property(get_cluster_quota_limit, set_cluster_quota_limit)
    def hasContent_(self):
        if (
            self.cluster_quota_limit or
            super(QuotaClusterLimits, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cluster_quota_limits', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cluster_quota_limits')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cluster_quota_limits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cluster_quota_limits', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cluster_quota_limits'):
        super(QuotaClusterLimits, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cluster_quota_limits')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cluster_quota_limits', fromsubclass_=False, pretty_print=True):
        super(QuotaClusterLimits, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cluster_quota_limit_ in self.cluster_quota_limit:
            cluster_quota_limit_.export(outfile, level, namespaceprefix_, name_='cluster_quota_limit', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QuotaClusterLimits, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cluster_quota_limit':
            obj_ = QuotaClusterLimit.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster_quota_limit.append(obj_)
            obj_.original_tagname_ = 'cluster_quota_limit'
        super(QuotaClusterLimits, self).buildChildren(child_, node, nodeName_, True)
# end class QuotaClusterLimits


class Url(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parameters_set=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if parameters_set is None:
            self.parameters_set = []
        else:
            self.parameters_set = parameters_set
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Url.subclass:
            return Url.subclass(*args_, **kwargs_)
        else:
            return Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameters_set(self):
        return self.parameters_set
    def set_parameters_set(self, parameters_set):
        self.parameters_set = parameters_set
    def add_parameters_set(self, value):
        self.parameters_set.append(value)
    def insert_parameters_set_at(self, index, value):
        self.parameters_set.insert(index, value)
    def replace_parameters_set_at(self, index, value):
        self.parameters_set[index] = value
    parameters_setProp = property(get_parameters_set, set_parameters_set)
    def hasContent_(self):
        if (
            self.parameters_set
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='url', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='url')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='url', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='url'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='url', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameters_set_ in self.parameters_set:
            parameters_set_.export(outfile, level, namespaceprefix_, name_='parameters_set', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameters_set':
            obj_ = ParametersSet.factory(parent_object_=self)
            obj_.build(child_)
            self.parameters_set.append(obj_)
            obj_.original_tagname_ = 'parameters_set'
# end class Url


class Body(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, required=None, type_=None, parameters_set=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.required = _cast(bool, required)
        self.type_ = type_
        if parameters_set is None:
            self.parameters_set = []
        else:
            self.parameters_set = parameters_set
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Body)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Body.subclass:
            return Body.subclass(*args_, **kwargs_)
        else:
            return Body(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_parameters_set(self):
        return self.parameters_set
    def set_parameters_set(self, parameters_set):
        self.parameters_set = parameters_set
    def add_parameters_set(self, value):
        self.parameters_set.append(value)
    def insert_parameters_set_at(self, index, value):
        self.parameters_set.insert(index, value)
    def replace_parameters_set_at(self, index, value):
        self.parameters_set[index] = value
    parameters_setProp = property(get_parameters_set, set_parameters_set)
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    requiredProp = property(get_required, set_required)
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.parameters_set
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='body', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('body')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='body')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='body', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='body'):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='body', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        for parameters_set_ in self.parameters_set:
            parameters_set_.export(outfile, level, namespaceprefix_, name_='parameters_set', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'parameters_set':
            obj_ = ParametersSet.factory(parent_object_=self)
            obj_.build(child_)
            self.parameters_set.append(obj_)
            obj_.original_tagname_ = 'parameters_set'
# end class Body


class Request(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, http_method=None, headers=None, url=None, body=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.http_method = http_method
        self.validate_HttpMethod(self.http_method)
        self.headers = headers
        self.url = url
        self.body = body
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Request)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Request.subclass:
            return Request.subclass(*args_, **kwargs_)
        else:
            return Request(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_http_method(self):
        return self.http_method
    def set_http_method(self, http_method):
        self.http_method = http_method
    http_methodProp = property(get_http_method, set_http_method)
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    headersProp = property(get_headers, set_headers)
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    urlProp = property(get_url, set_url)
    def get_body(self):
        return self.body
    def set_body(self, body):
        self.body = body
    bodyProp = property(get_body, set_body)
    def validate_HttpMethod(self, value):
        # Validate type HttpMethod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on HttpMethod' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.http_method is not None or
            self.headers is not None or
            self.url is not None or
            self.body is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='request', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('request')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='request')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='request', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='request'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='request', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.http_method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shttp_method>%s</%shttp_method>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.http_method), input_name='http_method')), namespaceprefix_ , eol_))
        if self.headers is not None:
            self.headers.export(outfile, level, namespaceprefix_, name_='headers', pretty_print=pretty_print)
        if self.url is not None:
            self.url.export(outfile, level, namespaceprefix_, name_='url', pretty_print=pretty_print)
        if self.body is not None:
            self.body.export(outfile, level, namespaceprefix_, name_='body', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'http_method':
            http_method_ = child_.text
            http_method_ = self.gds_validate_string(http_method_, node, 'http_method')
            self.http_method = http_method_
            # validate type HttpMethod
            self.validate_HttpMethod(self.http_method)
        elif nodeName_ == 'headers':
            obj_ = Headers.factory(parent_object_=self)
            obj_.build(child_)
            self.headers = obj_
            obj_.original_tagname_ = 'headers'
        elif nodeName_ == 'url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'body':
            obj_ = Body.factory(parent_object_=self)
            obj_.build(child_)
            self.body = obj_
            obj_.original_tagname_ = 'body'
# end class Request


class Response(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Response.subclass:
            return Response.subclass(*args_, **kwargs_)
        else:
            return Response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='response', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='response'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='response', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class Response


class Parameter(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, required=None, type_=None, context=None, value=None, parameters_set=None, deprecated=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Parameter, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.required = _cast(bool, required)
        self.type_ = _cast(None, type_)
        self.context = _cast(None, context)
        self.value = value
        self.parameters_set = parameters_set
        self.deprecated = deprecated
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameter.subclass:
            return Parameter.subclass(*args_, **kwargs_)
        else:
            return Parameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_parameters_set(self):
        return self.parameters_set
    def set_parameters_set(self, parameters_set):
        self.parameters_set = parameters_set
    parameters_setProp = property(get_parameters_set, set_parameters_set)
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    deprecatedProp = property(get_deprecated, set_deprecated)
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    requiredProp = property(get_required, set_required)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_context(self):
        return self.context
    def set_context(self, context):
        self.context = context
    contextProp = property(get_context, set_context)
    def hasContent_(self):
        if (
            self.value is not None or
            self.parameters_set is not None or
            self.deprecated is not None or
            super(Parameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='parameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='parameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parameter'):
        super(Parameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameter')
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.context is not None and 'context' not in already_processed:
            already_processed.add('context')
            outfile.write(' context=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.context), input_name='context')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='parameter', fromsubclass_=False, pretty_print=True):
        super(Parameter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
        if self.parameters_set is not None:
            self.parameters_set.export(outfile, level, namespaceprefix_, name_='parameters_set', pretty_print=pretty_print)
        if self.deprecated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeprecated>%s</%sdeprecated>%s' % (namespaceprefix_ , self.gds_format_boolean(self.deprecated, input_name='deprecated'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('context', node)
        if value is not None and 'context' not in already_processed:
            already_processed.add('context')
            self.context = value
        super(Parameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'parameters_set':
            obj_ = ParametersSet.factory(parent_object_=self)
            obj_.build(child_)
            self.parameters_set = obj_
            obj_.original_tagname_ = 'parameters_set'
        elif nodeName_ == 'deprecated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'deprecated')
            self.deprecated = ival_
        super(Parameter, self).buildChildren(child_, node, nodeName_, True)
# end class Parameter


class Header(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, required=None, value=None, deprecated=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Header, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.required = _cast(bool, required)
        self.value = value
        self.deprecated = deprecated
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Header)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Header.subclass:
            return Header.subclass(*args_, **kwargs_)
        else:
            return Header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    deprecatedProp = property(get_deprecated, set_deprecated)
    def get_required(self):
        return self.required
    def set_required(self, required):
        self.required = required
    requiredProp = property(get_required, set_required)
    def hasContent_(self):
        if (
            self.value is not None or
            self.deprecated is not None or
            super(Header, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='header', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('header')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='header', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='header'):
        super(Header, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='header')
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='header', fromsubclass_=False, pretty_print=True):
        super(Header, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
        if self.deprecated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeprecated>%s</%sdeprecated>%s' % (namespaceprefix_ , self.gds_format_boolean(self.deprecated, input_name='deprecated'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(Header, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'deprecated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'deprecated')
            self.deprecated = ival_
        super(Header, self).buildChildren(child_, node, nodeName_, True)
# end class Header


class Headers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, header=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if header is None:
            self.header = []
        else:
            self.header = header
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Headers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Headers.subclass:
            return Headers.subclass(*args_, **kwargs_)
        else:
            return Headers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_header(self):
        return self.header
    def set_header(self, header):
        self.header = header
    def add_header(self, value):
        self.header.append(value)
    def insert_header_at(self, index, value):
        self.header.insert(index, value)
    def replace_header_at(self, index, value):
        self.header[index] = value
    headerProp = property(get_header, set_header)
    def hasContent_(self):
        if (
            self.header
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='headers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('headers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='headers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='headers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='headers'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='headers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for header_ in self.header:
            header_.export(outfile, level, namespaceprefix_, name_='header', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'header':
            obj_ = Header.factory(parent_object_=self)
            obj_.build(child_)
            self.header.append(obj_)
            obj_.original_tagname_ = 'header'
# end class Headers


class ParametersSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deprecated=None, description=None, parameter=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.deprecated = deprecated
        self.description = description
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParametersSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParametersSet.subclass:
            return ParametersSet.subclass(*args_, **kwargs_)
        else:
            return ParametersSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deprecated(self):
        return self.deprecated
    def set_deprecated(self, deprecated):
        self.deprecated = deprecated
    deprecatedProp = property(get_deprecated, set_deprecated)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    descriptionProp = property(get_description, set_description)
    def get_parameter(self):
        return self.parameter
    def set_parameter(self, parameter):
        self.parameter = parameter
    def add_parameter(self, value):
        self.parameter.append(value)
    def insert_parameter_at(self, index, value):
        self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value):
        self.parameter[index] = value
    parameterProp = property(get_parameter, set_parameter)
    def hasContent_(self):
        if (
            self.deprecated is not None or
            self.description is not None or
            self.parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='parameters_set', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameters_set')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameters_set')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='parameters_set', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='parameters_set'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='parameters_set', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deprecated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeprecated>%s</%sdeprecated>%s' % (namespaceprefix_ , self.gds_format_boolean(self.deprecated, input_name='deprecated'), namespaceprefix_ , eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespaceprefix_, name_='parameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deprecated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'deprecated')
            self.deprecated = ival_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameter':
            obj_ = Parameter.factory(parent_object_=self)
            obj_.build(child_)
            self.parameter.append(obj_)
            obj_.original_tagname_ = 'parameter'
# end class ParametersSet


class Schema(Link):
    subclass = None
    superclass = Link
    def __init__(self, href=None, rel=None, name=None, description=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Schema, self).__init__(href, rel,  **kwargs_)
        self.name = name
        self.description = description
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Schema)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Schema.subclass:
            return Schema.subclass(*args_, **kwargs_)
        else:
            return Schema(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    descriptionProp = property(get_description, set_description)
    def hasContent_(self):
        if (
            self.name is not None or
            self.description is not None or
            super(Schema, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='schema', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('schema')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='schema')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='schema', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='schema'):
        super(Schema, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='schema')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='schema', fromsubclass_=False, pretty_print=True):
        super(Schema, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Schema, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        super(Schema, self).buildChildren(child_, node, nodeName_, True)
# end class Schema


class RSDL(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, href=None, rel=None, description=None, version=None, schema=None, general=None, links=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.href = _cast(None, href)
        self.rel = _cast(None, rel)
        self.description = description
        self.version = version
        self.schema = schema
        self.general = general
        self.links = links
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RSDL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RSDL.subclass:
            return RSDL.subclass(*args_, **kwargs_)
        else:
            return RSDL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    descriptionProp = property(get_description, set_description)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_schema(self):
        return self.schema
    def set_schema(self, schema):
        self.schema = schema
    schemaProp = property(get_schema, set_schema)
    def get_general(self):
        return self.general
    def set_general(self, general):
        self.general = general
    generalProp = property(get_general, set_general)
    def get_links(self):
        return self.links
    def set_links(self, links):
        self.links = links
    linksProp = property(get_links, set_links)
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    hrefProp = property(get_href, set_href)
    def get_rel(self):
        return self.rel
    def set_rel(self, rel):
        self.rel = rel
    relProp = property(get_rel, set_rel)
    def hasContent_(self):
        if (
            self.description is not None or
            self.version is not None or
            self.schema is not None or
            self.general is not None or
            self.links is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='rsdl', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rsdl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rsdl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='rsdl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rsdl'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.rel), input_name='rel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='rsdl', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.schema is not None:
            self.schema.export(outfile, level, namespaceprefix_, name_='schema', pretty_print=pretty_print)
        if self.general is not None:
            self.general.export(outfile, level, namespaceprefix_, name_='general', pretty_print=pretty_print)
        if self.links is not None:
            self.links.export(outfile, level, namespaceprefix_, name_='links', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'schema':
            obj_ = Schema.factory(parent_object_=self)
            obj_.build(child_)
            self.schema = obj_
            obj_.original_tagname_ = 'schema'
        elif nodeName_ == 'general':
            obj_ = GeneralMetadata.factory(parent_object_=self)
            obj_.build(child_)
            self.general = obj_
            obj_.original_tagname_ = 'general'
        elif nodeName_ == 'links':
            obj_ = DetailedLinks.factory(parent_object_=self)
            obj_.build(child_)
            self.links = obj_
            obj_.original_tagname_ = 'links'
# end class RSDL


class GlusterVolume(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, cluster=None, volume_type=None, transport_types=None, replica_count=None, stripe_count=None, disperse_count=None, redundancy_count=None, bricks=None, options=None, status=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterVolume, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.cluster = cluster
        self.volume_type = volume_type
        self.transport_types = transport_types
        self.replica_count = replica_count
        self.stripe_count = stripe_count
        self.disperse_count = disperse_count
        self.redundancy_count = redundancy_count
        self.bricks = bricks
        self.options = options
        self.status = status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterVolume)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterVolume.subclass:
            return GlusterVolume.subclass(*args_, **kwargs_)
        else:
            return GlusterVolume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_volume_type(self):
        return self.volume_type
    def set_volume_type(self, volume_type):
        self.volume_type = volume_type
    volume_typeProp = property(get_volume_type, set_volume_type)
    def get_transport_types(self):
        return self.transport_types
    def set_transport_types(self, transport_types):
        self.transport_types = transport_types
    transport_typesProp = property(get_transport_types, set_transport_types)
    def get_replica_count(self):
        return self.replica_count
    def set_replica_count(self, replica_count):
        self.replica_count = replica_count
    replica_countProp = property(get_replica_count, set_replica_count)
    def get_stripe_count(self):
        return self.stripe_count
    def set_stripe_count(self, stripe_count):
        self.stripe_count = stripe_count
    stripe_countProp = property(get_stripe_count, set_stripe_count)
    def get_disperse_count(self):
        return self.disperse_count
    def set_disperse_count(self, disperse_count):
        self.disperse_count = disperse_count
    disperse_countProp = property(get_disperse_count, set_disperse_count)
    def get_redundancy_count(self):
        return self.redundancy_count
    def set_redundancy_count(self, redundancy_count):
        self.redundancy_count = redundancy_count
    redundancy_countProp = property(get_redundancy_count, set_redundancy_count)
    def get_bricks(self):
        return self.bricks
    def set_bricks(self, bricks):
        self.bricks = bricks
    bricksProp = property(get_bricks, set_bricks)
    def get_options(self):
        return self.options
    def set_options(self, options):
        self.options = options
    optionsProp = property(get_options, set_options)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def hasContent_(self):
        if (
            self.cluster is not None or
            self.volume_type is not None or
            self.transport_types is not None or
            self.replica_count is not None or
            self.stripe_count is not None or
            self.disperse_count is not None or
            self.redundancy_count is not None or
            self.bricks is not None or
            self.options is not None or
            self.status is not None or
            super(GlusterVolume, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_volume', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_volume')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_volume')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_volume', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_volume'):
        super(GlusterVolume, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_volume')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_volume', fromsubclass_=False, pretty_print=True):
        super(GlusterVolume, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.volume_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolume_type>%s</%svolume_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.volume_type), input_name='volume_type')), namespaceprefix_ , eol_))
        if self.transport_types is not None:
            self.transport_types.export(outfile, level, namespaceprefix_, name_='transport_types', pretty_print=pretty_print)
        if self.replica_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreplica_count>%s</%sreplica_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.replica_count, input_name='replica_count'), namespaceprefix_ , eol_))
        if self.stripe_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstripe_count>%s</%sstripe_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.stripe_count, input_name='stripe_count'), namespaceprefix_ , eol_))
        if self.disperse_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisperse_count>%s</%sdisperse_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.disperse_count, input_name='disperse_count'), namespaceprefix_ , eol_))
        if self.redundancy_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sredundancy_count>%s</%sredundancy_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.redundancy_count, input_name='redundancy_count'), namespaceprefix_ , eol_))
        if self.bricks is not None:
            self.bricks.export(outfile, level, namespaceprefix_, name_='bricks', pretty_print=pretty_print)
        if self.options is not None:
            self.options.export(outfile, level, namespaceprefix_, name_='options', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterVolume, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'volume_type':
            volume_type_ = child_.text
            volume_type_ = self.gds_validate_string(volume_type_, node, 'volume_type')
            self.volume_type = volume_type_
        elif nodeName_ == 'transport_types':
            obj_ = TransportTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.transport_types = obj_
            obj_.original_tagname_ = 'transport_types'
        elif nodeName_ == 'replica_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'replica_count')
            self.replica_count = ival_
        elif nodeName_ == 'stripe_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'stripe_count')
            self.stripe_count = ival_
        elif nodeName_ == 'disperse_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'disperse_count')
            self.disperse_count = ival_
        elif nodeName_ == 'redundancy_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'redundancy_count')
            self.redundancy_count = ival_
        elif nodeName_ == 'bricks':
            obj_ = GlusterBricks.factory(parent_object_=self)
            obj_.build(child_)
            self.bricks = obj_
            obj_.original_tagname_ = 'bricks'
        elif nodeName_ == 'options':
            obj_ = Options.factory(parent_object_=self)
            obj_.build(child_)
            self.options = obj_
            obj_.original_tagname_ = 'options'
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        super(GlusterVolume, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterVolume


class GlusterVolumeTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gluster_volume_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if gluster_volume_type is None:
            self.gluster_volume_type = []
        else:
            self.gluster_volume_type = gluster_volume_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterVolumeTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterVolumeTypes.subclass:
            return GlusterVolumeTypes.subclass(*args_, **kwargs_)
        else:
            return GlusterVolumeTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gluster_volume_type(self):
        return self.gluster_volume_type
    def set_gluster_volume_type(self, gluster_volume_type):
        self.gluster_volume_type = gluster_volume_type
    def add_gluster_volume_type(self, value):
        self.gluster_volume_type.append(value)
    def insert_gluster_volume_type_at(self, index, value):
        self.gluster_volume_type.insert(index, value)
    def replace_gluster_volume_type_at(self, index, value):
        self.gluster_volume_type[index] = value
    gluster_volume_typeProp = property(get_gluster_volume_type, set_gluster_volume_type)
    def hasContent_(self):
        if (
            self.gluster_volume_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_volume_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_volume_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_volume_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_volume_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_volume_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_volume_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gluster_volume_type_ in self.gluster_volume_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgluster_volume_type>%s</%sgluster_volume_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(gluster_volume_type_), input_name='gluster_volume_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gluster_volume_type':
            gluster_volume_type_ = child_.text
            gluster_volume_type_ = self.gds_validate_string(gluster_volume_type_, node, 'gluster_volume_type')
            self.gluster_volume_type.append(gluster_volume_type_)
# end class GlusterVolumeTypes


class TransportTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, transport_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if transport_type is None:
            self.transport_type = []
        else:
            self.transport_type = transport_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransportTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransportTypes.subclass:
            return TransportTypes.subclass(*args_, **kwargs_)
        else:
            return TransportTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transport_type(self):
        return self.transport_type
    def set_transport_type(self, transport_type):
        self.transport_type = transport_type
    def add_transport_type(self, value):
        self.transport_type.append(value)
    def insert_transport_type_at(self, index, value):
        self.transport_type.insert(index, value)
    def replace_transport_type_at(self, index, value):
        self.transport_type[index] = value
    transport_typeProp = property(get_transport_type, set_transport_type)
    def hasContent_(self):
        if (
            self.transport_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='transport_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transport_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transport_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='transport_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transport_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='transport_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for transport_type_ in self.transport_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stransport_type>%s</%stransport_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(transport_type_), input_name='transport_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transport_type':
            transport_type_ = child_.text
            transport_type_ = self.gds_validate_string(transport_type_, node, 'transport_type')
            self.transport_type.append(transport_type_)
# end class TransportTypes


class GlusterStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterStates.subclass:
            return GlusterStates.subclass(*args_, **kwargs_)
        else:
            return GlusterStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def add_state(self, value):
        self.state.append(value)
    def insert_state_at(self, index, value):
        self.state.insert(index, value)
    def replace_state_at(self, index, value):
        self.state[index] = value
    stateProp = property(get_state, set_state)
    def hasContent_(self):
        if (
            self.state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='brick_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brick_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='brick_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='brick_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='brick_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for state_ in self.state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstate>%s</%sstate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(state_), input_name='state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'state':
            state_ = child_.text
            state_ = self.gds_validate_string(state_, node, 'state')
            self.state.append(state_)
# end class GlusterStates


class GlusterVolumes(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, gluster_volume=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterVolumes, self).__init__(actions, size, total, active,  **kwargs_)
        if gluster_volume is None:
            self.gluster_volume = []
        else:
            self.gluster_volume = gluster_volume
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterVolumes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterVolumes.subclass:
            return GlusterVolumes.subclass(*args_, **kwargs_)
        else:
            return GlusterVolumes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gluster_volume(self):
        return self.gluster_volume
    def set_gluster_volume(self, gluster_volume):
        self.gluster_volume = gluster_volume
    def add_gluster_volume(self, value):
        self.gluster_volume.append(value)
    def insert_gluster_volume_at(self, index, value):
        self.gluster_volume.insert(index, value)
    def replace_gluster_volume_at(self, index, value):
        self.gluster_volume[index] = value
    gluster_volumeProp = property(get_gluster_volume, set_gluster_volume)
    def hasContent_(self):
        if (
            self.gluster_volume or
            super(GlusterVolumes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_volumes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_volumes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_volumes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_volumes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_volumes'):
        super(GlusterVolumes, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_volumes')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_volumes', fromsubclass_=False, pretty_print=True):
        super(GlusterVolumes, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gluster_volume_ in self.gluster_volume:
            gluster_volume_.export(outfile, level, namespaceprefix_, name_='gluster_volume', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterVolumes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gluster_volume':
            obj_ = GlusterVolume.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_volume.append(obj_)
            obj_.original_tagname_ = 'gluster_volume'
        super(GlusterVolumes, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterVolumes


class GlusterClient(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, host_name=None, client_port=None, bytes_read=None, bytes_written=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.host_name = host_name
        self.client_port = client_port
        self.bytes_read = bytes_read
        self.bytes_written = bytes_written
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterClient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterClient.subclass:
            return GlusterClient.subclass(*args_, **kwargs_)
        else:
            return GlusterClient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_name(self):
        return self.host_name
    def set_host_name(self, host_name):
        self.host_name = host_name
    host_nameProp = property(get_host_name, set_host_name)
    def get_client_port(self):
        return self.client_port
    def set_client_port(self, client_port):
        self.client_port = client_port
    client_portProp = property(get_client_port, set_client_port)
    def get_bytes_read(self):
        return self.bytes_read
    def set_bytes_read(self, bytes_read):
        self.bytes_read = bytes_read
    bytes_readProp = property(get_bytes_read, set_bytes_read)
    def get_bytes_written(self):
        return self.bytes_written
    def set_bytes_written(self, bytes_written):
        self.bytes_written = bytes_written
    bytes_writtenProp = property(get_bytes_written, set_bytes_written)
    def hasContent_(self):
        if (
            self.host_name is not None or
            self.client_port is not None or
            self.bytes_read is not None or
            self.bytes_written is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_client', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_client')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_client')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_client', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_client'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_client', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost_name>%s</%shost_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.host_name), input_name='host_name')), namespaceprefix_ , eol_))
        if self.client_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclient_port>%s</%sclient_port>%s' % (namespaceprefix_ , self.gds_format_integer(self.client_port, input_name='client_port'), namespaceprefix_ , eol_))
        if self.bytes_read is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbytes_read>%s</%sbytes_read>%s' % (namespaceprefix_ , self.gds_format_integer(self.bytes_read, input_name='bytes_read'), namespaceprefix_ , eol_))
        if self.bytes_written is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbytes_written>%s</%sbytes_written>%s' % (namespaceprefix_ , self.gds_format_integer(self.bytes_written, input_name='bytes_written'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_name':
            host_name_ = child_.text
            host_name_ = self.gds_validate_string(host_name_, node, 'host_name')
            self.host_name = host_name_
        elif nodeName_ == 'client_port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'client_port')
            self.client_port = ival_
        elif nodeName_ == 'bytes_read' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bytes_read')
            self.bytes_read = ival_
        elif nodeName_ == 'bytes_written' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'bytes_written')
            self.bytes_written = ival_
# end class GlusterClient


class GlusterClients(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, gluster_client=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterClients, self).__init__(actions, size, total, active,  **kwargs_)
        if gluster_client is None:
            self.gluster_client = []
        else:
            self.gluster_client = gluster_client
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterClients)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterClients.subclass:
            return GlusterClients.subclass(*args_, **kwargs_)
        else:
            return GlusterClients(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gluster_client(self):
        return self.gluster_client
    def set_gluster_client(self, gluster_client):
        self.gluster_client = gluster_client
    def add_gluster_client(self, value):
        self.gluster_client.append(value)
    def insert_gluster_client_at(self, index, value):
        self.gluster_client.insert(index, value)
    def replace_gluster_client_at(self, index, value):
        self.gluster_client[index] = value
    gluster_clientProp = property(get_gluster_client, set_gluster_client)
    def hasContent_(self):
        if (
            self.gluster_client or
            super(GlusterClients, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_clients', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_clients')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_clients')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_clients', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_clients'):
        super(GlusterClients, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_clients')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_clients', fromsubclass_=False, pretty_print=True):
        super(GlusterClients, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gluster_client_ in self.gluster_client:
            gluster_client_.export(outfile, level, namespaceprefix_, name_='gluster_client', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterClients, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gluster_client':
            obj_ = GlusterClient.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_client.append(obj_)
            obj_.original_tagname_ = 'gluster_client'
        super(GlusterClients, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterClients


class GlusterMemoryPool(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, hot_count=None, cold_count=None, padded_size=None, alloc_count=None, max_alloc=None, pool_misses=None, max_stdalloc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.hot_count = hot_count
        self.cold_count = cold_count
        self.padded_size = padded_size
        self.alloc_count = alloc_count
        self.max_alloc = max_alloc
        self.pool_misses = pool_misses
        self.max_stdalloc = max_stdalloc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterMemoryPool)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterMemoryPool.subclass:
            return GlusterMemoryPool.subclass(*args_, **kwargs_)
        else:
            return GlusterMemoryPool(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_hot_count(self):
        return self.hot_count
    def set_hot_count(self, hot_count):
        self.hot_count = hot_count
    hot_countProp = property(get_hot_count, set_hot_count)
    def get_cold_count(self):
        return self.cold_count
    def set_cold_count(self, cold_count):
        self.cold_count = cold_count
    cold_countProp = property(get_cold_count, set_cold_count)
    def get_padded_size(self):
        return self.padded_size
    def set_padded_size(self, padded_size):
        self.padded_size = padded_size
    padded_sizeProp = property(get_padded_size, set_padded_size)
    def get_alloc_count(self):
        return self.alloc_count
    def set_alloc_count(self, alloc_count):
        self.alloc_count = alloc_count
    alloc_countProp = property(get_alloc_count, set_alloc_count)
    def get_max_alloc(self):
        return self.max_alloc
    def set_max_alloc(self, max_alloc):
        self.max_alloc = max_alloc
    max_allocProp = property(get_max_alloc, set_max_alloc)
    def get_pool_misses(self):
        return self.pool_misses
    def set_pool_misses(self, pool_misses):
        self.pool_misses = pool_misses
    pool_missesProp = property(get_pool_misses, set_pool_misses)
    def get_max_stdalloc(self):
        return self.max_stdalloc
    def set_max_stdalloc(self, max_stdalloc):
        self.max_stdalloc = max_stdalloc
    max_stdallocProp = property(get_max_stdalloc, set_max_stdalloc)
    def hasContent_(self):
        if (
            self.name is not None or
            self.hot_count is not None or
            self.cold_count is not None or
            self.padded_size is not None or
            self.alloc_count is not None or
            self.max_alloc is not None or
            self.pool_misses is not None or
            self.max_stdalloc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='memory_pool', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memory_pool')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memory_pool')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='memory_pool', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='memory_pool'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='memory_pool', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.hot_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shot_count>%s</%shot_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.hot_count, input_name='hot_count'), namespaceprefix_ , eol_))
        if self.cold_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scold_count>%s</%scold_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.cold_count, input_name='cold_count'), namespaceprefix_ , eol_))
        if self.padded_size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spadded_size>%s</%spadded_size>%s' % (namespaceprefix_ , self.gds_format_integer(self.padded_size, input_name='padded_size'), namespaceprefix_ , eol_))
        if self.alloc_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salloc_count>%s</%salloc_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.alloc_count, input_name='alloc_count'), namespaceprefix_ , eol_))
        if self.max_alloc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_alloc>%s</%smax_alloc>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_alloc, input_name='max_alloc'), namespaceprefix_ , eol_))
        if self.pool_misses is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spool_misses>%s</%spool_misses>%s' % (namespaceprefix_ , self.gds_format_integer(self.pool_misses, input_name='pool_misses'), namespaceprefix_ , eol_))
        if self.max_stdalloc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_stdalloc>%s</%smax_stdalloc>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_stdalloc, input_name='max_stdalloc'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'hot_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'hot_count')
            self.hot_count = ival_
        elif nodeName_ == 'cold_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cold_count')
            self.cold_count = ival_
        elif nodeName_ == 'padded_size' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'padded_size')
            self.padded_size = ival_
        elif nodeName_ == 'alloc_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'alloc_count')
            self.alloc_count = ival_
        elif nodeName_ == 'max_alloc' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_alloc')
            self.max_alloc = ival_
        elif nodeName_ == 'pool_misses' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pool_misses')
            self.pool_misses = ival_
        elif nodeName_ == 'max_stdalloc' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_stdalloc')
            self.max_stdalloc = ival_
# end class GlusterMemoryPool


class GlusterMemoryPools(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, memory_pool=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterMemoryPools, self).__init__(actions, size, total, active,  **kwargs_)
        if memory_pool is None:
            self.memory_pool = []
        else:
            self.memory_pool = memory_pool
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterMemoryPools)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterMemoryPools.subclass:
            return GlusterMemoryPools.subclass(*args_, **kwargs_)
        else:
            return GlusterMemoryPools(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memory_pool(self):
        return self.memory_pool
    def set_memory_pool(self, memory_pool):
        self.memory_pool = memory_pool
    def add_memory_pool(self, value):
        self.memory_pool.append(value)
    def insert_memory_pool_at(self, index, value):
        self.memory_pool.insert(index, value)
    def replace_memory_pool_at(self, index, value):
        self.memory_pool[index] = value
    memory_poolProp = property(get_memory_pool, set_memory_pool)
    def hasContent_(self):
        if (
            self.memory_pool or
            super(GlusterMemoryPools, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='memory_pools', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memory_pools')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memory_pools')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='memory_pools', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='memory_pools'):
        super(GlusterMemoryPools, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memory_pools')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='memory_pools', fromsubclass_=False, pretty_print=True):
        super(GlusterMemoryPools, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for memory_pool_ in self.memory_pool:
            memory_pool_.export(outfile, level, namespaceprefix_, name_='memory_pool', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterMemoryPools, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memory_pool':
            obj_ = GlusterMemoryPool.factory(parent_object_=self)
            obj_.build(child_)
            self.memory_pool.append(obj_)
            obj_.original_tagname_ = 'memory_pool'
        super(GlusterMemoryPools, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterMemoryPools


class GlusterBrickMemoryInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, memory_pools=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.memory_pools = memory_pools
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterBrickMemoryInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterBrickMemoryInfo.subclass:
            return GlusterBrickMemoryInfo.subclass(*args_, **kwargs_)
        else:
            return GlusterBrickMemoryInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memory_pools(self):
        return self.memory_pools
    def set_memory_pools(self, memory_pools):
        self.memory_pools = memory_pools
    memory_poolsProp = property(get_memory_pools, set_memory_pools)
    def hasContent_(self):
        if (
            self.memory_pools is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='brick_memoryinfo', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brick_memoryinfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_memoryinfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='brick_memoryinfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='brick_memoryinfo'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='brick_memoryinfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.memory_pools is not None:
            self.memory_pools.export(outfile, level, namespaceprefix_, name_='memory_pools', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memory_pools':
            obj_ = GlusterMemoryPools.factory(parent_object_=self)
            obj_.build(child_)
            self.memory_pools = obj_
            obj_.original_tagname_ = 'memory_pools'
# end class GlusterBrickMemoryInfo


class GlusterBrickAdvancedDetails(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, port=None, pid=None, device=None, mnt_options=None, fs_name=None, gluster_clients=None, memory_pools=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterBrickAdvancedDetails, self).__init__(actions, href, id, name, description, comment, creation_status, link, extensiontype_,  **kwargs_)
        self.port = port
        self.pid = pid
        self.device = device
        self.mnt_options = mnt_options
        self.fs_name = fs_name
        self.gluster_clients = gluster_clients
        self.memory_pools = memory_pools
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterBrickAdvancedDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterBrickAdvancedDetails.subclass:
            return GlusterBrickAdvancedDetails.subclass(*args_, **kwargs_)
        else:
            return GlusterBrickAdvancedDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_pid(self):
        return self.pid
    def set_pid(self, pid):
        self.pid = pid
    pidProp = property(get_pid, set_pid)
    def get_device(self):
        return self.device
    def set_device(self, device):
        self.device = device
    deviceProp = property(get_device, set_device)
    def get_mnt_options(self):
        return self.mnt_options
    def set_mnt_options(self, mnt_options):
        self.mnt_options = mnt_options
    mnt_optionsProp = property(get_mnt_options, set_mnt_options)
    def get_fs_name(self):
        return self.fs_name
    def set_fs_name(self, fs_name):
        self.fs_name = fs_name
    fs_nameProp = property(get_fs_name, set_fs_name)
    def get_gluster_clients(self):
        return self.gluster_clients
    def set_gluster_clients(self, gluster_clients):
        self.gluster_clients = gluster_clients
    gluster_clientsProp = property(get_gluster_clients, set_gluster_clients)
    def get_memory_pools(self):
        return self.memory_pools
    def set_memory_pools(self, memory_pools):
        self.memory_pools = memory_pools
    memory_poolsProp = property(get_memory_pools, set_memory_pools)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.port is not None or
            self.pid is not None or
            self.device is not None or
            self.mnt_options is not None or
            self.fs_name is not None or
            self.gluster_clients is not None or
            self.memory_pools is not None or
            super(GlusterBrickAdvancedDetails, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='brick_details', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brick_details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='brick_details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='brick_details'):
        super(GlusterBrickAdvancedDetails, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_details')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='brick_details', fromsubclass_=False, pretty_print=True):
        super(GlusterBrickAdvancedDetails, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.pid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spid>%s</%spid>%s' % (namespaceprefix_ , self.gds_format_integer(self.pid, input_name='pid'), namespaceprefix_ , eol_))
        if self.device is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdevice>%s</%sdevice>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.device), input_name='device')), namespaceprefix_ , eol_))
        if self.mnt_options is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smnt_options>%s</%smnt_options>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mnt_options), input_name='mnt_options')), namespaceprefix_ , eol_))
        if self.fs_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfs_name>%s</%sfs_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fs_name), input_name='fs_name')), namespaceprefix_ , eol_))
        if self.gluster_clients is not None:
            self.gluster_clients.export(outfile, level, namespaceprefix_, name_='gluster_clients', pretty_print=pretty_print)
        if self.memory_pools is not None:
            self.memory_pools.export(outfile, level, namespaceprefix_, name_='memory_pools', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(GlusterBrickAdvancedDetails, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'pid' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pid')
            self.pid = ival_
        elif nodeName_ == 'device':
            device_ = child_.text
            device_ = self.gds_validate_string(device_, node, 'device')
            self.device = device_
        elif nodeName_ == 'mnt_options':
            mnt_options_ = child_.text
            mnt_options_ = self.gds_validate_string(mnt_options_, node, 'mnt_options')
            self.mnt_options = mnt_options_
        elif nodeName_ == 'fs_name':
            fs_name_ = child_.text
            fs_name_ = self.gds_validate_string(fs_name_, node, 'fs_name')
            self.fs_name = fs_name_
        elif nodeName_ == 'gluster_clients':
            obj_ = GlusterClients.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_clients = obj_
            obj_.original_tagname_ = 'gluster_clients'
        elif nodeName_ == 'memory_pools':
            obj_ = GlusterMemoryPools.factory(parent_object_=self)
            obj_.build(child_)
            self.memory_pools = obj_
            obj_.original_tagname_ = 'memory_pools'
        super(GlusterBrickAdvancedDetails, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterBrickAdvancedDetails


class GlusterBrick(GlusterBrickAdvancedDetails):
    subclass = None
    superclass = GlusterBrickAdvancedDetails
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, port=None, pid=None, device=None, mnt_options=None, fs_name=None, gluster_clients=None, memory_pools=None, gluster_volume=None, server_id=None, brick_dir=None, status=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterBrick, self).__init__(actions, href, id, name, description, comment, creation_status, link, port, pid, device, mnt_options, fs_name, gluster_clients, memory_pools,  **kwargs_)
        self.gluster_volume = gluster_volume
        self.server_id = server_id
        self.brick_dir = brick_dir
        self.status = status
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterBrick)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterBrick.subclass:
            return GlusterBrick.subclass(*args_, **kwargs_)
        else:
            return GlusterBrick(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gluster_volume(self):
        return self.gluster_volume
    def set_gluster_volume(self, gluster_volume):
        self.gluster_volume = gluster_volume
    gluster_volumeProp = property(get_gluster_volume, set_gluster_volume)
    def get_server_id(self):
        return self.server_id
    def set_server_id(self, server_id):
        self.server_id = server_id
    server_idProp = property(get_server_id, set_server_id)
    def get_brick_dir(self):
        return self.brick_dir
    def set_brick_dir(self, brick_dir):
        self.brick_dir = brick_dir
    brick_dirProp = property(get_brick_dir, set_brick_dir)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def hasContent_(self):
        if (
            self.gluster_volume is not None or
            self.server_id is not None or
            self.brick_dir is not None or
            self.status is not None or
            super(GlusterBrick, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='brick', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brick')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='brick', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='brick'):
        super(GlusterBrick, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='brick', fromsubclass_=False, pretty_print=True):
        super(GlusterBrick, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.gluster_volume is not None:
            self.gluster_volume.export(outfile, level, namespaceprefix_, name_='gluster_volume', pretty_print=pretty_print)
        if self.server_id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserver_id>%s</%sserver_id>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.server_id), input_name='server_id')), namespaceprefix_ , eol_))
        if self.brick_dir is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbrick_dir>%s</%sbrick_dir>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.brick_dir), input_name='brick_dir')), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterBrick, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gluster_volume':
            obj_ = GlusterVolume.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_volume = obj_
            obj_.original_tagname_ = 'gluster_volume'
        elif nodeName_ == 'server_id':
            server_id_ = child_.text
            server_id_ = self.gds_validate_string(server_id_, node, 'server_id')
            self.server_id = server_id_
        elif nodeName_ == 'brick_dir':
            brick_dir_ = child_.text
            brick_dir_ = self.gds_validate_string(brick_dir_, node, 'brick_dir')
            self.brick_dir = brick_dir_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        super(GlusterBrick, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterBrick


class GlusterBricks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, replica_count=None, stripe_count=None, brick=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterBricks, self).__init__(actions, size, total, active,  **kwargs_)
        self.replica_count = replica_count
        self.stripe_count = stripe_count
        if brick is None:
            self.brick = []
        else:
            self.brick = brick
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterBricks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterBricks.subclass:
            return GlusterBricks.subclass(*args_, **kwargs_)
        else:
            return GlusterBricks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_replica_count(self):
        return self.replica_count
    def set_replica_count(self, replica_count):
        self.replica_count = replica_count
    replica_countProp = property(get_replica_count, set_replica_count)
    def get_stripe_count(self):
        return self.stripe_count
    def set_stripe_count(self, stripe_count):
        self.stripe_count = stripe_count
    stripe_countProp = property(get_stripe_count, set_stripe_count)
    def get_brick(self):
        return self.brick
    def set_brick(self, brick):
        self.brick = brick
    def add_brick(self, value):
        self.brick.append(value)
    def insert_brick_at(self, index, value):
        self.brick.insert(index, value)
    def replace_brick_at(self, index, value):
        self.brick[index] = value
    brickProp = property(get_brick, set_brick)
    def hasContent_(self):
        if (
            self.replica_count is not None or
            self.stripe_count is not None or
            self.brick or
            super(GlusterBricks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='bricks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bricks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bricks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='bricks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='bricks'):
        super(GlusterBricks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bricks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='bricks', fromsubclass_=False, pretty_print=True):
        super(GlusterBricks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.replica_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreplica_count>%s</%sreplica_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.replica_count, input_name='replica_count'), namespaceprefix_ , eol_))
        if self.stripe_count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstripe_count>%s</%sstripe_count>%s' % (namespaceprefix_ , self.gds_format_integer(self.stripe_count, input_name='stripe_count'), namespaceprefix_ , eol_))
        for brick_ in self.brick:
            brick_.export(outfile, level, namespaceprefix_, name_='brick', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterBricks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'replica_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'replica_count')
            self.replica_count = ival_
        elif nodeName_ == 'stripe_count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'stripe_count')
            self.stripe_count = ival_
        elif nodeName_ == 'brick':
            obj_ = GlusterBrick.factory(parent_object_=self)
            obj_.build(child_)
            self.brick.append(obj_)
            obj_.original_tagname_ = 'brick'
        super(GlusterBricks, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterBricks


class Stages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, stage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if stage is None:
            self.stage = []
        else:
            self.stage = stage
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Stages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Stages.subclass:
            return Stages.subclass(*args_, **kwargs_)
        else:
            return Stages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stage(self):
        return self.stage
    def set_stage(self, stage):
        self.stage = stage
    def add_stage(self, value):
        self.stage.append(value)
    def insert_stage_at(self, index, value):
        self.stage.insert(index, value)
    def replace_stage_at(self, index, value):
        self.stage[index] = value
    stageProp = property(get_stage, set_stage)
    def hasContent_(self):
        if (
            self.stage
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='stages', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stages')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='stages', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='stages'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='stages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for stage_ in self.stage:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstage>%s</%sstage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(stage_), input_name='stage')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stage':
            stage_ = child_.text
            stage_ = self.gds_validate_string(stage_, node, 'stage')
            self.stage.append(stage_)
# end class Stages


class HookStates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hook_state=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if hook_state is None:
            self.hook_state = []
        else:
            self.hook_state = hook_state
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HookStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HookStates.subclass:
            return HookStates.subclass(*args_, **kwargs_)
        else:
            return HookStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hook_state(self):
        return self.hook_state
    def set_hook_state(self, hook_state):
        self.hook_state = hook_state
    def add_hook_state(self, value):
        self.hook_state.append(value)
    def insert_hook_state_at(self, index, value):
        self.hook_state.insert(index, value)
    def replace_hook_state_at(self, index, value):
        self.hook_state[index] = value
    hook_stateProp = property(get_hook_state, set_hook_state)
    def hasContent_(self):
        if (
            self.hook_state
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='hook_states', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hook_states')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hook_states')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='hook_states', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='hook_states'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='hook_states', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for hook_state_ in self.hook_state:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shook_state>%s</%shook_state>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(hook_state_), input_name='hook_state')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hook_state':
            hook_state_ = child_.text
            hook_state_ = self.gds_validate_string(hook_state_, node, 'hook_state')
            self.hook_state.append(hook_state_)
# end class HookStates


class ContentTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if content_type is None:
            self.content_type = []
        else:
            self.content_type = content_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ContentTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ContentTypes.subclass:
            return ContentTypes.subclass(*args_, **kwargs_)
        else:
            return ContentTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content_type(self):
        return self.content_type
    def set_content_type(self, content_type):
        self.content_type = content_type
    def add_content_type(self, value):
        self.content_type.append(value)
    def insert_content_type_at(self, index, value):
        self.content_type.insert(index, value)
    def replace_content_type_at(self, index, value):
        self.content_type[index] = value
    content_typeProp = property(get_content_type, set_content_type)
    def hasContent_(self):
        if (
            self.content_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='content_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('content_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='content_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='content_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='content_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='content_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for content_type_ in self.content_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent_type>%s</%scontent_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(content_type_), input_name='content_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content_type':
            content_type_ = child_.text
            content_type_ = self.gds_validate_string(content_type_, node, 'content_type')
            self.content_type.append(content_type_)
# end class ContentTypes


class GlusterServerHooks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, server_hook=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterServerHooks, self).__init__(actions, size, total, active,  **kwargs_)
        if server_hook is None:
            self.server_hook = []
        else:
            self.server_hook = server_hook
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterServerHooks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterServerHooks.subclass:
            return GlusterServerHooks.subclass(*args_, **kwargs_)
        else:
            return GlusterServerHooks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_server_hook(self):
        return self.server_hook
    def set_server_hook(self, server_hook):
        self.server_hook = server_hook
    def add_server_hook(self, value):
        self.server_hook.append(value)
    def insert_server_hook_at(self, index, value):
        self.server_hook.insert(index, value)
    def replace_server_hook_at(self, index, value):
        self.server_hook[index] = value
    server_hookProp = property(get_server_hook, set_server_hook)
    def hasContent_(self):
        if (
            self.server_hook or
            super(GlusterServerHooks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='server_hooks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('server_hooks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='server_hooks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='server_hooks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='server_hooks'):
        super(GlusterServerHooks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='server_hooks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='server_hooks', fromsubclass_=False, pretty_print=True):
        super(GlusterServerHooks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for server_hook_ in self.server_hook:
            server_hook_.export(outfile, level, namespaceprefix_, name_='server_hook', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterServerHooks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'server_hook':
            obj_ = GlusterServerHook.factory(parent_object_=self)
            obj_.build(child_)
            self.server_hook.append(obj_)
            obj_.original_tagname_ = 'server_hook'
        super(GlusterServerHooks, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterServerHooks


class GlusterServerHook(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host=None, content_type=None, status=None, checksum=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterServerHook, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.host = host
        self.content_type = content_type
        self.status = status
        self.checksum = checksum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterServerHook)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterServerHook.subclass:
            return GlusterServerHook.subclass(*args_, **kwargs_)
        else:
            return GlusterServerHook(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_content_type(self):
        return self.content_type
    def set_content_type(self, content_type):
        self.content_type = content_type
    content_typeProp = property(get_content_type, set_content_type)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    checksumProp = property(get_checksum, set_checksum)
    def hasContent_(self):
        if (
            self.host is not None or
            self.content_type is not None or
            self.status is not None or
            self.checksum is not None or
            super(GlusterServerHook, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='server_hook', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('server_hook')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='server_hook')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='server_hook', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='server_hook'):
        super(GlusterServerHook, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='server_hook')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='server_hook', fromsubclass_=False, pretty_print=True):
        super(GlusterServerHook, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.content_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent_type>%s</%scontent_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.content_type), input_name='content_type')), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.checksum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schecksum>%s</%schecksum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.checksum), input_name='checksum')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterServerHook, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'content_type':
            content_type_ = child_.text
            content_type_ = self.gds_validate_string(content_type_, node, 'content_type')
            self.content_type = content_type_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'checksum':
            checksum_ = child_.text
            checksum_ = self.gds_validate_string(checksum_, node, 'checksum')
            self.checksum = checksum_
        super(GlusterServerHook, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterServerHook


class GlusterHook(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, cluster=None, gluster_command=None, stage=None, content_type=None, checksum=None, content=None, conflict_status=None, conflicts=None, status=None, server_hooks=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterHook, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.cluster = cluster
        self.gluster_command = gluster_command
        self.stage = stage
        self.content_type = content_type
        self.checksum = checksum
        self.content = content
        self.conflict_status = conflict_status
        self.conflicts = conflicts
        self.status = status
        self.server_hooks = server_hooks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterHook)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterHook.subclass:
            return GlusterHook.subclass(*args_, **kwargs_)
        else:
            return GlusterHook(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_gluster_command(self):
        return self.gluster_command
    def set_gluster_command(self, gluster_command):
        self.gluster_command = gluster_command
    gluster_commandProp = property(get_gluster_command, set_gluster_command)
    def get_stage(self):
        return self.stage
    def set_stage(self, stage):
        self.stage = stage
    stageProp = property(get_stage, set_stage)
    def get_content_type(self):
        return self.content_type
    def set_content_type(self, content_type):
        self.content_type = content_type
    content_typeProp = property(get_content_type, set_content_type)
    def get_checksum(self):
        return self.checksum
    def set_checksum(self, checksum):
        self.checksum = checksum
    checksumProp = property(get_checksum, set_checksum)
    def get_content(self):
        return self.content
    def set_content(self, content):
        self.content = content
    contentProp = property(get_content, set_content)
    def get_conflict_status(self):
        return self.conflict_status
    def set_conflict_status(self, conflict_status):
        self.conflict_status = conflict_status
    conflict_statusProp = property(get_conflict_status, set_conflict_status)
    def get_conflicts(self):
        return self.conflicts
    def set_conflicts(self, conflicts):
        self.conflicts = conflicts
    conflictsProp = property(get_conflicts, set_conflicts)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_server_hooks(self):
        return self.server_hooks
    def set_server_hooks(self, server_hooks):
        self.server_hooks = server_hooks
    server_hooksProp = property(get_server_hooks, set_server_hooks)
    def hasContent_(self):
        if (
            self.cluster is not None or
            self.gluster_command is not None or
            self.stage is not None or
            self.content_type is not None or
            self.checksum is not None or
            self.content is not None or
            self.conflict_status is not None or
            self.conflicts is not None or
            self.status is not None or
            self.server_hooks is not None or
            super(GlusterHook, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_hook', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_hook')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_hook')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_hook', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_hook'):
        super(GlusterHook, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_hook')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_hook', fromsubclass_=False, pretty_print=True):
        super(GlusterHook, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.gluster_command is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgluster_command>%s</%sgluster_command>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.gluster_command), input_name='gluster_command')), namespaceprefix_ , eol_))
        if self.stage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstage>%s</%sstage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.stage), input_name='stage')), namespaceprefix_ , eol_))
        if self.content_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent_type>%s</%scontent_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.content_type), input_name='content_type')), namespaceprefix_ , eol_))
        if self.checksum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schecksum>%s</%schecksum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.checksum), input_name='checksum')), namespaceprefix_ , eol_))
        if self.content is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontent>%s</%scontent>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.content), input_name='content')), namespaceprefix_ , eol_))
        if self.conflict_status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconflict_status>%s</%sconflict_status>%s' % (namespaceprefix_ , self.gds_format_integer(self.conflict_status, input_name='conflict_status'), namespaceprefix_ , eol_))
        if self.conflicts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconflicts>%s</%sconflicts>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.conflicts), input_name='conflicts')), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.server_hooks is not None:
            self.server_hooks.export(outfile, level, namespaceprefix_, name_='server_hooks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterHook, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'gluster_command':
            gluster_command_ = child_.text
            gluster_command_ = self.gds_validate_string(gluster_command_, node, 'gluster_command')
            self.gluster_command = gluster_command_
        elif nodeName_ == 'stage':
            stage_ = child_.text
            stage_ = self.gds_validate_string(stage_, node, 'stage')
            self.stage = stage_
        elif nodeName_ == 'content_type':
            content_type_ = child_.text
            content_type_ = self.gds_validate_string(content_type_, node, 'content_type')
            self.content_type = content_type_
        elif nodeName_ == 'checksum':
            checksum_ = child_.text
            checksum_ = self.gds_validate_string(checksum_, node, 'checksum')
            self.checksum = checksum_
        elif nodeName_ == 'content':
            content_ = child_.text
            content_ = self.gds_validate_string(content_, node, 'content')
            self.content = content_
        elif nodeName_ == 'conflict_status' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'conflict_status')
            self.conflict_status = ival_
        elif nodeName_ == 'conflicts':
            conflicts_ = child_.text
            conflicts_ = self.gds_validate_string(conflicts_, node, 'conflicts')
            self.conflicts = conflicts_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'server_hooks':
            obj_ = GlusterServerHooks.factory(parent_object_=self)
            obj_.build(child_)
            self.server_hooks = obj_
            obj_.original_tagname_ = 'server_hooks'
        super(GlusterHook, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterHook


class GlusterHooks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, gluster_hook=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterHooks, self).__init__(actions, size, total, active,  **kwargs_)
        if gluster_hook is None:
            self.gluster_hook = []
        else:
            self.gluster_hook = gluster_hook
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterHooks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterHooks.subclass:
            return GlusterHooks.subclass(*args_, **kwargs_)
        else:
            return GlusterHooks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gluster_hook(self):
        return self.gluster_hook
    def set_gluster_hook(self, gluster_hook):
        self.gluster_hook = gluster_hook
    def add_gluster_hook(self, value):
        self.gluster_hook.append(value)
    def insert_gluster_hook_at(self, index, value):
        self.gluster_hook.insert(index, value)
    def replace_gluster_hook_at(self, index, value):
        self.gluster_hook[index] = value
    gluster_hookProp = property(get_gluster_hook, set_gluster_hook)
    def hasContent_(self):
        if (
            self.gluster_hook or
            super(GlusterHooks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='gluster_hooks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('gluster_hooks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_hooks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='gluster_hooks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='gluster_hooks'):
        super(GlusterHooks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='gluster_hooks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='gluster_hooks', fromsubclass_=False, pretty_print=True):
        super(GlusterHooks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for gluster_hook_ in self.gluster_hook:
            gluster_hook_.export(outfile, level, namespaceprefix_, name_='gluster_hook', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterHooks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'gluster_hook':
            obj_ = GlusterHook.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_hook.append(obj_)
            obj_.original_tagname_ = 'gluster_hook'
        super(GlusterHooks, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterHooks


class GlusterVolumeProfileDetails(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, brick_profile_details=None, nfs_profile_details=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GlusterVolumeProfileDetails, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.brick_profile_details = brick_profile_details
        self.nfs_profile_details = nfs_profile_details
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GlusterVolumeProfileDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GlusterVolumeProfileDetails.subclass:
            return GlusterVolumeProfileDetails.subclass(*args_, **kwargs_)
        else:
            return GlusterVolumeProfileDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brick_profile_details(self):
        return self.brick_profile_details
    def set_brick_profile_details(self, brick_profile_details):
        self.brick_profile_details = brick_profile_details
    brick_profile_detailsProp = property(get_brick_profile_details, set_brick_profile_details)
    def get_nfs_profile_details(self):
        return self.nfs_profile_details
    def set_nfs_profile_details(self, nfs_profile_details):
        self.nfs_profile_details = nfs_profile_details
    nfs_profile_detailsProp = property(get_nfs_profile_details, set_nfs_profile_details)
    def hasContent_(self):
        if (
            self.brick_profile_details is not None or
            self.nfs_profile_details is not None or
            super(GlusterVolumeProfileDetails, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='volume_profile_details', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('volume_profile_details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='volume_profile_details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='volume_profile_details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='volume_profile_details'):
        super(GlusterVolumeProfileDetails, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='volume_profile_details')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='volume_profile_details', fromsubclass_=False, pretty_print=True):
        super(GlusterVolumeProfileDetails, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.brick_profile_details is not None:
            self.brick_profile_details.export(outfile, level, namespaceprefix_, name_='brick_profile_details', pretty_print=pretty_print)
        if self.nfs_profile_details is not None:
            self.nfs_profile_details.export(outfile, level, namespaceprefix_, name_='nfs_profile_details', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GlusterVolumeProfileDetails, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'brick_profile_details':
            obj_ = BrickProfileDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.brick_profile_details = obj_
            obj_.original_tagname_ = 'brick_profile_details'
        elif nodeName_ == 'nfs_profile_details':
            obj_ = NfsProfileDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.nfs_profile_details = obj_
            obj_.original_tagname_ = 'nfs_profile_details'
        super(GlusterVolumeProfileDetails, self).buildChildren(child_, node, nodeName_, True)
# end class GlusterVolumeProfileDetails


class BrickProfileDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, brick_profile_detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if brick_profile_detail is None:
            self.brick_profile_detail = []
        else:
            self.brick_profile_detail = brick_profile_detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrickProfileDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrickProfileDetails.subclass:
            return BrickProfileDetails.subclass(*args_, **kwargs_)
        else:
            return BrickProfileDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brick_profile_detail(self):
        return self.brick_profile_detail
    def set_brick_profile_detail(self, brick_profile_detail):
        self.brick_profile_detail = brick_profile_detail
    def add_brick_profile_detail(self, value):
        self.brick_profile_detail.append(value)
    def insert_brick_profile_detail_at(self, index, value):
        self.brick_profile_detail.insert(index, value)
    def replace_brick_profile_detail_at(self, index, value):
        self.brick_profile_detail[index] = value
    brick_profile_detailProp = property(get_brick_profile_detail, set_brick_profile_detail)
    def hasContent_(self):
        if (
            self.brick_profile_detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='brick_profile_details', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brick_profile_details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_profile_details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='brick_profile_details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='brick_profile_details'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='brick_profile_details', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for brick_profile_detail_ in self.brick_profile_detail:
            brick_profile_detail_.export(outfile, level, namespaceprefix_, name_='brick_profile_detail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'brick_profile_detail':
            obj_ = BrickProfileDetail.factory(parent_object_=self)
            obj_.build(child_)
            self.brick_profile_detail.append(obj_)
            obj_.original_tagname_ = 'brick_profile_detail'
# end class BrickProfileDetails


class NfsProfileDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nfs_profile_detail=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if nfs_profile_detail is None:
            self.nfs_profile_detail = []
        else:
            self.nfs_profile_detail = nfs_profile_detail
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NfsProfileDetails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NfsProfileDetails.subclass:
            return NfsProfileDetails.subclass(*args_, **kwargs_)
        else:
            return NfsProfileDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nfs_profile_detail(self):
        return self.nfs_profile_detail
    def set_nfs_profile_detail(self, nfs_profile_detail):
        self.nfs_profile_detail = nfs_profile_detail
    def add_nfs_profile_detail(self, value):
        self.nfs_profile_detail.append(value)
    def insert_nfs_profile_detail_at(self, index, value):
        self.nfs_profile_detail.insert(index, value)
    def replace_nfs_profile_detail_at(self, index, value):
        self.nfs_profile_detail[index] = value
    nfs_profile_detailProp = property(get_nfs_profile_detail, set_nfs_profile_detail)
    def hasContent_(self):
        if (
            self.nfs_profile_detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nfs_profile_details', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nfs_profile_details')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nfs_profile_details')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nfs_profile_details', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nfs_profile_details'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nfs_profile_details', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for nfs_profile_detail_ in self.nfs_profile_detail:
            nfs_profile_detail_.export(outfile, level, namespaceprefix_, name_='nfs_profile_detail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nfs_profile_detail':
            obj_ = NfsProfileDetail.factory(parent_object_=self)
            obj_.build(child_)
            self.nfs_profile_detail.append(obj_)
            obj_.original_tagname_ = 'nfs_profile_detail'
# end class NfsProfileDetails


class EntityProfileDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, profile_detail=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if profile_detail is None:
            self.profile_detail = []
        else:
            self.profile_detail = profile_detail
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntityProfileDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntityProfileDetail.subclass:
            return EntityProfileDetail.subclass(*args_, **kwargs_)
        else:
            return EntityProfileDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_profile_detail(self):
        return self.profile_detail
    def set_profile_detail(self, profile_detail):
        self.profile_detail = profile_detail
    def add_profile_detail(self, value):
        self.profile_detail.append(value)
    def insert_profile_detail_at(self, index, value):
        self.profile_detail.insert(index, value)
    def replace_profile_detail_at(self, index, value):
        self.profile_detail[index] = value
    profile_detailProp = property(get_profile_detail, set_profile_detail)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.profile_detail
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='entity_profile_detail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('entity_profile_detail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='entity_profile_detail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='entity_profile_detail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='entity_profile_detail'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='entity_profile_detail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for profile_detail_ in self.profile_detail:
            profile_detail_.export(outfile, level, namespaceprefix_, name_='profile_detail', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'profile_detail':
            obj_ = ProfileDetail.factory(parent_object_=self)
            obj_.build(child_)
            self.profile_detail.append(obj_)
            obj_.original_tagname_ = 'profile_detail'
# end class EntityProfileDetail


class NfsProfileDetail(EntityProfileDetail):
    subclass = None
    superclass = EntityProfileDetail
    def __init__(self, profile_detail=None, nfs_server_ip=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(NfsProfileDetail, self).__init__(profile_detail,  **kwargs_)
        self.nfs_server_ip = nfs_server_ip
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NfsProfileDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NfsProfileDetail.subclass:
            return NfsProfileDetail.subclass(*args_, **kwargs_)
        else:
            return NfsProfileDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nfs_server_ip(self):
        return self.nfs_server_ip
    def set_nfs_server_ip(self, nfs_server_ip):
        self.nfs_server_ip = nfs_server_ip
    nfs_server_ipProp = property(get_nfs_server_ip, set_nfs_server_ip)
    def hasContent_(self):
        if (
            self.nfs_server_ip is not None or
            super(NfsProfileDetail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='nfs_profile_detail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nfs_profile_detail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nfs_profile_detail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='nfs_profile_detail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nfs_profile_detail'):
        super(NfsProfileDetail, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nfs_profile_detail')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='nfs_profile_detail', fromsubclass_=False, pretty_print=True):
        super(NfsProfileDetail, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nfs_server_ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfs_server_ip>%s</%snfs_server_ip>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nfs_server_ip), input_name='nfs_server_ip')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NfsProfileDetail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nfs_server_ip':
            nfs_server_ip_ = child_.text
            nfs_server_ip_ = self.gds_validate_string(nfs_server_ip_, node, 'nfs_server_ip')
            self.nfs_server_ip = nfs_server_ip_
        super(NfsProfileDetail, self).buildChildren(child_, node, nodeName_, True)
# end class NfsProfileDetail


class ProfileDetail(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, profile_type=None, duration=None, statistic=None, block_statistic=None, fop_statistic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.profile_type = profile_type
        self.duration = duration
        if statistic is None:
            self.statistic = []
        else:
            self.statistic = statistic
        if block_statistic is None:
            self.block_statistic = []
        else:
            self.block_statistic = block_statistic
        if fop_statistic is None:
            self.fop_statistic = []
        else:
            self.fop_statistic = fop_statistic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileDetail.subclass:
            return ProfileDetail.subclass(*args_, **kwargs_)
        else:
            return ProfileDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_profile_type(self):
        return self.profile_type
    def set_profile_type(self, profile_type):
        self.profile_type = profile_type
    profile_typeProp = property(get_profile_type, set_profile_type)
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    durationProp = property(get_duration, set_duration)
    def get_statistic(self):
        return self.statistic
    def set_statistic(self, statistic):
        self.statistic = statistic
    def add_statistic(self, value):
        self.statistic.append(value)
    def insert_statistic_at(self, index, value):
        self.statistic.insert(index, value)
    def replace_statistic_at(self, index, value):
        self.statistic[index] = value
    statisticProp = property(get_statistic, set_statistic)
    def get_block_statistic(self):
        return self.block_statistic
    def set_block_statistic(self, block_statistic):
        self.block_statistic = block_statistic
    def add_block_statistic(self, value):
        self.block_statistic.append(value)
    def insert_block_statistic_at(self, index, value):
        self.block_statistic.insert(index, value)
    def replace_block_statistic_at(self, index, value):
        self.block_statistic[index] = value
    block_statisticProp = property(get_block_statistic, set_block_statistic)
    def get_fop_statistic(self):
        return self.fop_statistic
    def set_fop_statistic(self, fop_statistic):
        self.fop_statistic = fop_statistic
    def add_fop_statistic(self, value):
        self.fop_statistic.append(value)
    def insert_fop_statistic_at(self, index, value):
        self.fop_statistic.insert(index, value)
    def replace_fop_statistic_at(self, index, value):
        self.fop_statistic[index] = value
    fop_statisticProp = property(get_fop_statistic, set_fop_statistic)
    def hasContent_(self):
        if (
            self.profile_type is not None or
            self.duration is not None or
            self.statistic or
            self.block_statistic or
            self.fop_statistic
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='profile_detail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('profile_detail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='profile_detail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='profile_detail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='profile_detail'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='profile_detail', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.profile_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprofile_type>%s</%sprofile_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.profile_type), input_name='profile_type')), namespaceprefix_ , eol_))
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespaceprefix_ , self.gds_format_integer(self.duration, input_name='duration'), namespaceprefix_ , eol_))
        for statistic_ in self.statistic:
            statistic_.export(outfile, level, namespaceprefix_, name_='statistic', pretty_print=pretty_print)
        for block_statistic_ in self.block_statistic:
            block_statistic_.export(outfile, level, namespaceprefix_, name_='block_statistic', pretty_print=pretty_print)
        for fop_statistic_ in self.fop_statistic:
            fop_statistic_.export(outfile, level, namespaceprefix_, name_='fop_statistic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'profile_type':
            profile_type_ = child_.text
            profile_type_ = self.gds_validate_string(profile_type_, node, 'profile_type')
            self.profile_type = profile_type_
        elif nodeName_ == 'duration' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'duration')
            self.duration = ival_
        elif nodeName_ == 'statistic':
            obj_ = Statistic.factory(parent_object_=self)
            obj_.build(child_)
            self.statistic.append(obj_)
            obj_.original_tagname_ = 'statistic'
        elif nodeName_ == 'block_statistic':
            obj_ = BlockStatistic.factory(parent_object_=self)
            obj_.build(child_)
            self.block_statistic.append(obj_)
            obj_.original_tagname_ = 'block_statistic'
        elif nodeName_ == 'fop_statistic':
            obj_ = FopStatistic.factory(parent_object_=self)
            obj_.build(child_)
            self.fop_statistic.append(obj_)
            obj_.original_tagname_ = 'fop_statistic'
# end class ProfileDetail


class BlockStatistic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, statistic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if statistic is None:
            self.statistic = []
        else:
            self.statistic = statistic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BlockStatistic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BlockStatistic.subclass:
            return BlockStatistic.subclass(*args_, **kwargs_)
        else:
            return BlockStatistic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statistic(self):
        return self.statistic
    def set_statistic(self, statistic):
        self.statistic = statistic
    def add_statistic(self, value):
        self.statistic.append(value)
    def insert_statistic_at(self, index, value):
        self.statistic.insert(index, value)
    def replace_statistic_at(self, index, value):
        self.statistic[index] = value
    statisticProp = property(get_statistic, set_statistic)
    def hasContent_(self):
        if (
            self.statistic
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='block_statistic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('block_statistic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='block_statistic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='block_statistic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='block_statistic'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='block_statistic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for statistic_ in self.statistic:
            statistic_.export(outfile, level, namespaceprefix_, name_='statistic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'statistic':
            obj_ = Statistic.factory(parent_object_=self)
            obj_.build(child_)
            self.statistic.append(obj_)
            obj_.original_tagname_ = 'statistic'
# end class BlockStatistic


class FopStatistic(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, statistic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        if statistic is None:
            self.statistic = []
        else:
            self.statistic = statistic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FopStatistic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FopStatistic.subclass:
            return FopStatistic.subclass(*args_, **kwargs_)
        else:
            return FopStatistic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def get_statistic(self):
        return self.statistic
    def set_statistic(self, statistic):
        self.statistic = statistic
    def add_statistic(self, value):
        self.statistic.append(value)
    def insert_statistic_at(self, index, value):
        self.statistic.insert(index, value)
    def replace_statistic_at(self, index, value):
        self.statistic[index] = value
    statisticProp = property(get_statistic, set_statistic)
    def hasContent_(self):
        if (
            self.name is not None or
            self.statistic
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='fop_statistic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fop_statistic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fop_statistic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='fop_statistic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fop_statistic'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='fop_statistic', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        for statistic_ in self.statistic:
            statistic_.export(outfile, level, namespaceprefix_, name_='statistic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'statistic':
            obj_ = Statistic.factory(parent_object_=self)
            obj_.build(child_)
            self.statistic.append(obj_)
            obj_.original_tagname_ = 'statistic'
# end class FopStatistic


class PmProxies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pm_proxy=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if pm_proxy is None:
            self.pm_proxy = []
        else:
            self.pm_proxy = pm_proxy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PmProxies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PmProxies.subclass:
            return PmProxies.subclass(*args_, **kwargs_)
        else:
            return PmProxies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pm_proxy(self):
        return self.pm_proxy
    def set_pm_proxy(self, pm_proxy):
        self.pm_proxy = pm_proxy
    def add_pm_proxy(self, value):
        self.pm_proxy.append(value)
    def insert_pm_proxy_at(self, index, value):
        self.pm_proxy.insert(index, value)
    def replace_pm_proxy_at(self, index, value):
        self.pm_proxy[index] = value
    pm_proxyProp = property(get_pm_proxy, set_pm_proxy)
    def hasContent_(self):
        if (
            self.pm_proxy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='pm_proxies', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pm_proxies')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pm_proxies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='pm_proxies', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pm_proxies'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='pm_proxies', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pm_proxy_ in self.pm_proxy:
            pm_proxy_.export(outfile, level, namespaceprefix_, name_='pm_proxy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pm_proxy':
            obj_ = PmProxy.factory(parent_object_=self)
            obj_.build(child_)
            self.pm_proxy.append(obj_)
            obj_.original_tagname_ = 'pm_proxy'
# end class PmProxies


class PmProxy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PmProxy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PmProxy.subclass:
            return PmProxy.subclass(*args_, **kwargs_)
        else:
            return PmProxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='pm_proxy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pm_proxy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pm_proxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='pm_proxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pm_proxy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='pm_proxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
# end class PmProxy


class StepTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, step_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if step_type is None:
            self.step_type = []
        else:
            self.step_type = step_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StepTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StepTypes.subclass:
            return StepTypes.subclass(*args_, **kwargs_)
        else:
            return StepTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_step_type(self):
        return self.step_type
    def set_step_type(self, step_type):
        self.step_type = step_type
    def add_step_type(self, value):
        self.step_type.append(value)
    def insert_step_type_at(self, index, value):
        self.step_type.insert(index, value)
    def replace_step_type_at(self, index, value):
        self.step_type[index] = value
    step_typeProp = property(get_step_type, set_step_type)
    def hasContent_(self):
        if (
            self.step_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='step_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('step_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='step_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='step_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='step_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='step_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for step_type_ in self.step_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstep_type>%s</%sstep_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(step_type_), input_name='step_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'step_type':
            step_type_ = child_.text
            step_type_ = self.gds_validate_string(step_type_, node, 'step_type')
            self.step_type.append(step_type_)
# end class StepTypes


class Step(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, parent_step=None, job=None, type_=None, number=None, status=None, start_time=None, end_time=None, external=None, external_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Step, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.parent_step = parent_step
        self.job = job
        self.type_ = type_
        self.number = number
        self.status = status
        if isinstance(start_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(start_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = start_time
        self.start_time = initvalue_
        if isinstance(end_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(end_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = end_time
        self.end_time = initvalue_
        self.external = external
        self.external_type = external_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Step)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Step.subclass:
            return Step.subclass(*args_, **kwargs_)
        else:
            return Step(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parent_step(self):
        return self.parent_step
    def set_parent_step(self, parent_step):
        self.parent_step = parent_step
    parent_stepProp = property(get_parent_step, set_parent_step)
    def get_job(self):
        return self.job
    def set_job(self, job):
        self.job = job
    jobProp = property(get_job, set_job)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_number(self):
        return self.number
    def set_number(self, number):
        self.number = number
    numberProp = property(get_number, set_number)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_start_time(self):
        return self.start_time
    def set_start_time(self, start_time):
        self.start_time = start_time
    start_timeProp = property(get_start_time, set_start_time)
    def get_end_time(self):
        return self.end_time
    def set_end_time(self, end_time):
        self.end_time = end_time
    end_timeProp = property(get_end_time, set_end_time)
    def get_external(self):
        return self.external
    def set_external(self, external):
        self.external = external
    externalProp = property(get_external, set_external)
    def get_external_type(self):
        return self.external_type
    def set_external_type(self, external_type):
        self.external_type = external_type
    external_typeProp = property(get_external_type, set_external_type)
    def hasContent_(self):
        if (
            self.parent_step is not None or
            self.job is not None or
            self.type_ is not None or
            self.number is not None or
            self.status is not None or
            self.start_time is not None or
            self.end_time is not None or
            self.external is not None or
            self.external_type is not None or
            super(Step, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='step', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('step')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='step')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='step', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='step'):
        super(Step, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='step')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='step', fromsubclass_=False, pretty_print=True):
        super(Step, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parent_step is not None:
            self.parent_step.export(outfile, level, namespaceprefix_, name_='parent_step', pretty_print=pretty_print)
        if self.job is not None:
            self.job.export(outfile, level, namespaceprefix_, name_='job', pretty_print=pretty_print)
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumber>%s</%snumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.number, input_name='number'), namespaceprefix_ , eol_))
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.start_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart_time>%s</%sstart_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.start_time, input_name='start_time'), namespaceprefix_ , eol_))
        if self.end_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send_time>%s</%send_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.end_time, input_name='end_time'), namespaceprefix_ , eol_))
        if self.external is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal>%s</%sexternal>%s' % (namespaceprefix_ , self.gds_format_boolean(self.external, input_name='external'), namespaceprefix_ , eol_))
        if self.external_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal_type>%s</%sexternal_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.external_type), input_name='external_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Step, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parent_step':
            obj_ = Step.factory(parent_object_=self)
            obj_.build(child_)
            self.parent_step = obj_
            obj_.original_tagname_ = 'parent_step'
        elif nodeName_ == 'job':
            obj_ = Job.factory(parent_object_=self)
            obj_.build(child_)
            self.job = obj_
            obj_.original_tagname_ = 'job'
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'number' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'number')
            self.number = ival_
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'start_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.start_time = dval_
        elif nodeName_ == 'end_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.end_time = dval_
        elif nodeName_ == 'external':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'external')
            self.external = ival_
        elif nodeName_ == 'external_type':
            external_type_ = child_.text
            external_type_ = self.gds_validate_string(external_type_, node, 'external_type')
            self.external_type = external_type_
        super(Step, self).buildChildren(child_, node, nodeName_, True)
# end class Step


class Steps(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, step=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Steps, self).__init__(actions, size, total, active,  **kwargs_)
        if step is None:
            self.step = []
        else:
            self.step = step
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Steps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Steps.subclass:
            return Steps.subclass(*args_, **kwargs_)
        else:
            return Steps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_step(self):
        return self.step
    def set_step(self, step):
        self.step = step
    def add_step(self, value):
        self.step.append(value)
    def insert_step_at(self, index, value):
        self.step.insert(index, value)
    def replace_step_at(self, index, value):
        self.step[index] = value
    stepProp = property(get_step, set_step)
    def hasContent_(self):
        if (
            self.step or
            super(Steps, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='steps', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('steps')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='steps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='steps', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='steps'):
        super(Steps, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='steps')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='steps', fromsubclass_=False, pretty_print=True):
        super(Steps, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for step_ in self.step:
            step_.export(outfile, level, namespaceprefix_, name_='step', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Steps, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'step':
            obj_ = Step.factory(parent_object_=self)
            obj_.build(child_)
            self.step.append(obj_)
            obj_.original_tagname_ = 'step'
        super(Steps, self).buildChildren(child_, node, nodeName_, True)
# end class Steps


class Job(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, status=None, owner=None, start_time=None, end_time=None, last_updated=None, external=None, auto_cleared=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Job, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.status = status
        self.owner = owner
        if isinstance(start_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(start_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = start_time
        self.start_time = initvalue_
        if isinstance(end_time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(end_time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = end_time
        self.end_time = initvalue_
        if isinstance(last_updated, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(last_updated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = last_updated
        self.last_updated = initvalue_
        self.external = external
        self.auto_cleared = auto_cleared
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Job)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Job.subclass:
            return Job.subclass(*args_, **kwargs_)
        else:
            return Job(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_owner(self):
        return self.owner
    def set_owner(self, owner):
        self.owner = owner
    ownerProp = property(get_owner, set_owner)
    def get_start_time(self):
        return self.start_time
    def set_start_time(self, start_time):
        self.start_time = start_time
    start_timeProp = property(get_start_time, set_start_time)
    def get_end_time(self):
        return self.end_time
    def set_end_time(self, end_time):
        self.end_time = end_time
    end_timeProp = property(get_end_time, set_end_time)
    def get_last_updated(self):
        return self.last_updated
    def set_last_updated(self, last_updated):
        self.last_updated = last_updated
    last_updatedProp = property(get_last_updated, set_last_updated)
    def get_external(self):
        return self.external
    def set_external(self, external):
        self.external = external
    externalProp = property(get_external, set_external)
    def get_auto_cleared(self):
        return self.auto_cleared
    def set_auto_cleared(self, auto_cleared):
        self.auto_cleared = auto_cleared
    auto_clearedProp = property(get_auto_cleared, set_auto_cleared)
    def hasContent_(self):
        if (
            self.status is not None or
            self.owner is not None or
            self.start_time is not None or
            self.end_time is not None or
            self.last_updated is not None or
            self.external is not None or
            self.auto_cleared is not None or
            super(Job, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='job', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('job')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='job')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='job', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='job'):
        super(Job, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='job')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='job', fromsubclass_=False, pretty_print=True):
        super(Job, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.owner is not None:
            self.owner.export(outfile, level, namespaceprefix_, name_='owner', pretty_print=pretty_print)
        if self.start_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstart_time>%s</%sstart_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.start_time, input_name='start_time'), namespaceprefix_ , eol_))
        if self.end_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%send_time>%s</%send_time>%s' % (namespaceprefix_ , self.gds_format_datetime(self.end_time, input_name='end_time'), namespaceprefix_ , eol_))
        if self.last_updated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast_updated>%s</%slast_updated>%s' % (namespaceprefix_ , self.gds_format_datetime(self.last_updated, input_name='last_updated'), namespaceprefix_ , eol_))
        if self.external is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexternal>%s</%sexternal>%s' % (namespaceprefix_ , self.gds_format_boolean(self.external, input_name='external'), namespaceprefix_ , eol_))
        if self.auto_cleared is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauto_cleared>%s</%sauto_cleared>%s' % (namespaceprefix_ , self.gds_format_boolean(self.auto_cleared, input_name='auto_cleared'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Job, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'owner':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.owner = obj_
            obj_.original_tagname_ = 'owner'
        elif nodeName_ == 'start_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.start_time = dval_
        elif nodeName_ == 'end_time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.end_time = dval_
        elif nodeName_ == 'last_updated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.last_updated = dval_
        elif nodeName_ == 'external':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'external')
            self.external = ival_
        elif nodeName_ == 'auto_cleared':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'auto_cleared')
            self.auto_cleared = ival_
        super(Job, self).buildChildren(child_, node, nodeName_, True)
# end class Job


class Jobs(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, job=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Jobs, self).__init__(actions, size, total, active,  **kwargs_)
        if job is None:
            self.job = []
        else:
            self.job = job
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Jobs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Jobs.subclass:
            return Jobs.subclass(*args_, **kwargs_)
        else:
            return Jobs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_job(self):
        return self.job
    def set_job(self, job):
        self.job = job
    def add_job(self, value):
        self.job.append(value)
    def insert_job_at(self, index, value):
        self.job.insert(index, value)
    def replace_job_at(self, index, value):
        self.job[index] = value
    jobProp = property(get_job, set_job)
    def hasContent_(self):
        if (
            self.job or
            super(Jobs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='jobs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('jobs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='jobs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='jobs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='jobs'):
        super(Jobs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='jobs')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='jobs', fromsubclass_=False, pretty_print=True):
        super(Jobs, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for job_ in self.job:
            job_.export(outfile, level, namespaceprefix_, name_='job', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Jobs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'job':
            obj_ = Job.factory(parent_object_=self)
            obj_.build(child_)
            self.job.append(obj_)
            obj_.original_tagname_ = 'job'
        super(Jobs, self).buildChildren(child_, node, nodeName_, True)
# end class Jobs


class AffinityGroup(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, cluster=None, positive=None, enforcing=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AffinityGroup, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.cluster = cluster
        self.positive = positive
        self.enforcing = enforcing
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AffinityGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AffinityGroup.subclass:
            return AffinityGroup.subclass(*args_, **kwargs_)
        else:
            return AffinityGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_positive(self):
        return self.positive
    def set_positive(self, positive):
        self.positive = positive
    positiveProp = property(get_positive, set_positive)
    def get_enforcing(self):
        return self.enforcing
    def set_enforcing(self, enforcing):
        self.enforcing = enforcing
    enforcingProp = property(get_enforcing, set_enforcing)
    def hasContent_(self):
        if (
            self.cluster is not None or
            self.positive is not None or
            self.enforcing is not None or
            super(AffinityGroup, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='affinity_group', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('affinity_group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='affinity_group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='affinity_group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='affinity_group'):
        super(AffinityGroup, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='affinity_group')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='affinity_group', fromsubclass_=False, pretty_print=True):
        super(AffinityGroup, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.positive is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spositive>%s</%spositive>%s' % (namespaceprefix_ , self.gds_format_boolean(self.positive, input_name='positive'), namespaceprefix_ , eol_))
        if self.enforcing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senforcing>%s</%senforcing>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enforcing, input_name='enforcing'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AffinityGroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'positive':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'positive')
            self.positive = ival_
        elif nodeName_ == 'enforcing':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'enforcing')
            self.enforcing = ival_
        super(AffinityGroup, self).buildChildren(child_, node, nodeName_, True)
# end class AffinityGroup


class AffinityGroups(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, affinity_group=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AffinityGroups, self).__init__(actions, size, total, active,  **kwargs_)
        if affinity_group is None:
            self.affinity_group = []
        else:
            self.affinity_group = affinity_group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AffinityGroups)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AffinityGroups.subclass:
            return AffinityGroups.subclass(*args_, **kwargs_)
        else:
            return AffinityGroups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_affinity_group(self):
        return self.affinity_group
    def set_affinity_group(self, affinity_group):
        self.affinity_group = affinity_group
    def add_affinity_group(self, value):
        self.affinity_group.append(value)
    def insert_affinity_group_at(self, index, value):
        self.affinity_group.insert(index, value)
    def replace_affinity_group_at(self, index, value):
        self.affinity_group[index] = value
    affinity_groupProp = property(get_affinity_group, set_affinity_group)
    def hasContent_(self):
        if (
            self.affinity_group or
            super(AffinityGroups, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='affinity_groups', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('affinity_groups')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='affinity_groups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='affinity_groups', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='affinity_groups'):
        super(AffinityGroups, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='affinity_groups')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='affinity_groups', fromsubclass_=False, pretty_print=True):
        super(AffinityGroups, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for affinity_group_ in self.affinity_group:
            affinity_group_.export(outfile, level, namespaceprefix_, name_='affinity_group', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AffinityGroups, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'affinity_group':
            obj_ = AffinityGroup.factory(parent_object_=self)
            obj_.build(child_)
            self.affinity_group.append(obj_)
            obj_.original_tagname_ = 'affinity_group'
        super(AffinityGroups, self).buildChildren(child_, node, nodeName_, True)
# end class AffinityGroups


class NumaNode(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host=None, index=None, memory=None, cpu=None, statistics=None, node_distance=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(NumaNode, self).__init__(actions, href, id, name, description, comment, creation_status, link, extensiontype_,  **kwargs_)
        self.host = host
        self.index = index
        self.memory = memory
        self.cpu = cpu
        self.statistics = statistics
        self.node_distance = node_distance
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumaNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumaNode.subclass:
            return NumaNode.subclass(*args_, **kwargs_)
        else:
            return NumaNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    indexProp = property(get_index, set_index)
    def get_memory(self):
        return self.memory
    def set_memory(self, memory):
        self.memory = memory
    memoryProp = property(get_memory, set_memory)
    def get_cpu(self):
        return self.cpu
    def set_cpu(self, cpu):
        self.cpu = cpu
    cpuProp = property(get_cpu, set_cpu)
    def get_statistics(self):
        return self.statistics
    def set_statistics(self, statistics):
        self.statistics = statistics
    statisticsProp = property(get_statistics, set_statistics)
    def get_node_distance(self):
        return self.node_distance
    def set_node_distance(self, node_distance):
        self.node_distance = node_distance
    node_distanceProp = property(get_node_distance, set_node_distance)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.host is not None or
            self.index is not None or
            self.memory is not None or
            self.cpu is not None or
            self.statistics is not None or
            self.node_distance is not None or
            super(NumaNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_numa_node', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_numa_node')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_numa_node')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_numa_node', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_numa_node'):
        super(NumaNode, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_numa_node')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_numa_node', fromsubclass_=False, pretty_print=True):
        super(NumaNode, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.index is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindex>%s</%sindex>%s' % (namespaceprefix_ , self.gds_format_integer(self.index, input_name='index'), namespaceprefix_ , eol_))
        if self.memory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemory>%s</%smemory>%s' % (namespaceprefix_ , self.gds_format_integer(self.memory, input_name='memory'), namespaceprefix_ , eol_))
        if self.cpu is not None:
            self.cpu.export(outfile, level, namespaceprefix_, name_='cpu', pretty_print=pretty_print)
        if self.statistics is not None:
            self.statistics.export(outfile, level, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
        if self.node_distance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snode_distance>%s</%snode_distance>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.node_distance), input_name='node_distance')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NumaNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'index' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'index')
            self.index = ival_
        elif nodeName_ == 'memory' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'memory')
            self.memory = ival_
        elif nodeName_ == 'cpu':
            obj_ = CPU.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu = obj_
            obj_.original_tagname_ = 'cpu'
        elif nodeName_ == 'statistics':
            obj_ = Statistics.factory(parent_object_=self)
            obj_.build(child_)
            self.statistics = obj_
            obj_.original_tagname_ = 'statistics'
        elif nodeName_ == 'node_distance':
            node_distance_ = child_.text
            node_distance_ = self.gds_validate_string(node_distance_, node, 'node_distance')
            self.node_distance = node_distance_
        super(NumaNode, self).buildChildren(child_, node, nodeName_, True)
# end class NumaNode


class QoS(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, data_center=None, max_throughput=None, max_read_throughput=None, max_write_throughput=None, max_iops=None, max_read_iops=None, max_write_iops=None, cpu_limit=None, inbound_average=None, inbound_peak=None, inbound_burst=None, outbound_average=None, outbound_peak=None, outbound_burst=None, outbound_average_linkshare=None, outbound_average_upperlimit=None, outbound_average_realtime=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QoS, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.data_center = data_center
        self.max_throughput = max_throughput
        self.max_read_throughput = max_read_throughput
        self.max_write_throughput = max_write_throughput
        self.max_iops = max_iops
        self.max_read_iops = max_read_iops
        self.max_write_iops = max_write_iops
        self.cpu_limit = cpu_limit
        self.inbound_average = inbound_average
        self.inbound_peak = inbound_peak
        self.inbound_burst = inbound_burst
        self.outbound_average = outbound_average
        self.outbound_peak = outbound_peak
        self.outbound_burst = outbound_burst
        self.outbound_average_linkshare = outbound_average_linkshare
        self.outbound_average_upperlimit = outbound_average_upperlimit
        self.outbound_average_realtime = outbound_average_realtime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QoS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QoS.subclass:
            return QoS.subclass(*args_, **kwargs_)
        else:
            return QoS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_max_throughput(self):
        return self.max_throughput
    def set_max_throughput(self, max_throughput):
        self.max_throughput = max_throughput
    max_throughputProp = property(get_max_throughput, set_max_throughput)
    def get_max_read_throughput(self):
        return self.max_read_throughput
    def set_max_read_throughput(self, max_read_throughput):
        self.max_read_throughput = max_read_throughput
    max_read_throughputProp = property(get_max_read_throughput, set_max_read_throughput)
    def get_max_write_throughput(self):
        return self.max_write_throughput
    def set_max_write_throughput(self, max_write_throughput):
        self.max_write_throughput = max_write_throughput
    max_write_throughputProp = property(get_max_write_throughput, set_max_write_throughput)
    def get_max_iops(self):
        return self.max_iops
    def set_max_iops(self, max_iops):
        self.max_iops = max_iops
    max_iopsProp = property(get_max_iops, set_max_iops)
    def get_max_read_iops(self):
        return self.max_read_iops
    def set_max_read_iops(self, max_read_iops):
        self.max_read_iops = max_read_iops
    max_read_iopsProp = property(get_max_read_iops, set_max_read_iops)
    def get_max_write_iops(self):
        return self.max_write_iops
    def set_max_write_iops(self, max_write_iops):
        self.max_write_iops = max_write_iops
    max_write_iopsProp = property(get_max_write_iops, set_max_write_iops)
    def get_cpu_limit(self):
        return self.cpu_limit
    def set_cpu_limit(self, cpu_limit):
        self.cpu_limit = cpu_limit
    cpu_limitProp = property(get_cpu_limit, set_cpu_limit)
    def get_inbound_average(self):
        return self.inbound_average
    def set_inbound_average(self, inbound_average):
        self.inbound_average = inbound_average
    inbound_averageProp = property(get_inbound_average, set_inbound_average)
    def get_inbound_peak(self):
        return self.inbound_peak
    def set_inbound_peak(self, inbound_peak):
        self.inbound_peak = inbound_peak
    inbound_peakProp = property(get_inbound_peak, set_inbound_peak)
    def get_inbound_burst(self):
        return self.inbound_burst
    def set_inbound_burst(self, inbound_burst):
        self.inbound_burst = inbound_burst
    inbound_burstProp = property(get_inbound_burst, set_inbound_burst)
    def get_outbound_average(self):
        return self.outbound_average
    def set_outbound_average(self, outbound_average):
        self.outbound_average = outbound_average
    outbound_averageProp = property(get_outbound_average, set_outbound_average)
    def get_outbound_peak(self):
        return self.outbound_peak
    def set_outbound_peak(self, outbound_peak):
        self.outbound_peak = outbound_peak
    outbound_peakProp = property(get_outbound_peak, set_outbound_peak)
    def get_outbound_burst(self):
        return self.outbound_burst
    def set_outbound_burst(self, outbound_burst):
        self.outbound_burst = outbound_burst
    outbound_burstProp = property(get_outbound_burst, set_outbound_burst)
    def get_outbound_average_linkshare(self):
        return self.outbound_average_linkshare
    def set_outbound_average_linkshare(self, outbound_average_linkshare):
        self.outbound_average_linkshare = outbound_average_linkshare
    outbound_average_linkshareProp = property(get_outbound_average_linkshare, set_outbound_average_linkshare)
    def get_outbound_average_upperlimit(self):
        return self.outbound_average_upperlimit
    def set_outbound_average_upperlimit(self, outbound_average_upperlimit):
        self.outbound_average_upperlimit = outbound_average_upperlimit
    outbound_average_upperlimitProp = property(get_outbound_average_upperlimit, set_outbound_average_upperlimit)
    def get_outbound_average_realtime(self):
        return self.outbound_average_realtime
    def set_outbound_average_realtime(self, outbound_average_realtime):
        self.outbound_average_realtime = outbound_average_realtime
    outbound_average_realtimeProp = property(get_outbound_average_realtime, set_outbound_average_realtime)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def hasContent_(self):
        if (
            self.data_center is not None or
            self.max_throughput is not None or
            self.max_read_throughput is not None or
            self.max_write_throughput is not None or
            self.max_iops is not None or
            self.max_read_iops is not None or
            self.max_write_iops is not None or
            self.cpu_limit is not None or
            self.inbound_average is not None or
            self.inbound_peak is not None or
            self.inbound_burst is not None or
            self.outbound_average is not None or
            self.outbound_peak is not None or
            self.outbound_burst is not None or
            self.outbound_average_linkshare is not None or
            self.outbound_average_upperlimit is not None or
            self.outbound_average_realtime is not None or
            super(QoS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='qos', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qos')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qos')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='qos', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qos'):
        super(QoS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qos')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='qos', fromsubclass_=False, pretty_print=True):
        super(QoS, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.max_throughput is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_throughput>%s</%smax_throughput>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_throughput, input_name='max_throughput'), namespaceprefix_ , eol_))
        if self.max_read_throughput is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_read_throughput>%s</%smax_read_throughput>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_read_throughput, input_name='max_read_throughput'), namespaceprefix_ , eol_))
        if self.max_write_throughput is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_write_throughput>%s</%smax_write_throughput>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_write_throughput, input_name='max_write_throughput'), namespaceprefix_ , eol_))
        if self.max_iops is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_iops>%s</%smax_iops>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_iops, input_name='max_iops'), namespaceprefix_ , eol_))
        if self.max_read_iops is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_read_iops>%s</%smax_read_iops>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_read_iops, input_name='max_read_iops'), namespaceprefix_ , eol_))
        if self.max_write_iops is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smax_write_iops>%s</%smax_write_iops>%s' % (namespaceprefix_ , self.gds_format_integer(self.max_write_iops, input_name='max_write_iops'), namespaceprefix_ , eol_))
        if self.cpu_limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpu_limit>%s</%scpu_limit>%s' % (namespaceprefix_ , self.gds_format_integer(self.cpu_limit, input_name='cpu_limit'), namespaceprefix_ , eol_))
        if self.inbound_average is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinbound_average>%s</%sinbound_average>%s' % (namespaceprefix_ , self.gds_format_integer(self.inbound_average, input_name='inbound_average'), namespaceprefix_ , eol_))
        if self.inbound_peak is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinbound_peak>%s</%sinbound_peak>%s' % (namespaceprefix_ , self.gds_format_integer(self.inbound_peak, input_name='inbound_peak'), namespaceprefix_ , eol_))
        if self.inbound_burst is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinbound_burst>%s</%sinbound_burst>%s' % (namespaceprefix_ , self.gds_format_integer(self.inbound_burst, input_name='inbound_burst'), namespaceprefix_ , eol_))
        if self.outbound_average is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutbound_average>%s</%soutbound_average>%s' % (namespaceprefix_ , self.gds_format_integer(self.outbound_average, input_name='outbound_average'), namespaceprefix_ , eol_))
        if self.outbound_peak is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutbound_peak>%s</%soutbound_peak>%s' % (namespaceprefix_ , self.gds_format_integer(self.outbound_peak, input_name='outbound_peak'), namespaceprefix_ , eol_))
        if self.outbound_burst is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutbound_burst>%s</%soutbound_burst>%s' % (namespaceprefix_ , self.gds_format_integer(self.outbound_burst, input_name='outbound_burst'), namespaceprefix_ , eol_))
        if self.outbound_average_linkshare is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutbound_average_linkshare>%s</%soutbound_average_linkshare>%s' % (namespaceprefix_ , self.gds_format_integer(self.outbound_average_linkshare, input_name='outbound_average_linkshare'), namespaceprefix_ , eol_))
        if self.outbound_average_upperlimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutbound_average_upperlimit>%s</%soutbound_average_upperlimit>%s' % (namespaceprefix_ , self.gds_format_integer(self.outbound_average_upperlimit, input_name='outbound_average_upperlimit'), namespaceprefix_ , eol_))
        if self.outbound_average_realtime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soutbound_average_realtime>%s</%soutbound_average_realtime>%s' % (namespaceprefix_ , self.gds_format_integer(self.outbound_average_realtime, input_name='outbound_average_realtime'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(QoS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'max_throughput' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_throughput')
            self.max_throughput = ival_
        elif nodeName_ == 'max_read_throughput' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_read_throughput')
            self.max_read_throughput = ival_
        elif nodeName_ == 'max_write_throughput' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_write_throughput')
            self.max_write_throughput = ival_
        elif nodeName_ == 'max_iops' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_iops')
            self.max_iops = ival_
        elif nodeName_ == 'max_read_iops' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_read_iops')
            self.max_read_iops = ival_
        elif nodeName_ == 'max_write_iops' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'max_write_iops')
            self.max_write_iops = ival_
        elif nodeName_ == 'cpu_limit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cpu_limit')
            self.cpu_limit = ival_
        elif nodeName_ == 'inbound_average' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'inbound_average')
            self.inbound_average = ival_
        elif nodeName_ == 'inbound_peak' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'inbound_peak')
            self.inbound_peak = ival_
        elif nodeName_ == 'inbound_burst' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'inbound_burst')
            self.inbound_burst = ival_
        elif nodeName_ == 'outbound_average' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'outbound_average')
            self.outbound_average = ival_
        elif nodeName_ == 'outbound_peak' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'outbound_peak')
            self.outbound_peak = ival_
        elif nodeName_ == 'outbound_burst' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'outbound_burst')
            self.outbound_burst = ival_
        elif nodeName_ == 'outbound_average_linkshare' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'outbound_average_linkshare')
            self.outbound_average_linkshare = ival_
        elif nodeName_ == 'outbound_average_upperlimit' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'outbound_average_upperlimit')
            self.outbound_average_upperlimit = ival_
        elif nodeName_ == 'outbound_average_realtime' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'outbound_average_realtime')
            self.outbound_average_realtime = ival_
        super(QoS, self).buildChildren(child_, node, nodeName_, True)
# end class QoS


class NumaNodes(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, host_numa_node=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(NumaNodes, self).__init__(actions, size, total, active, extensiontype_,  **kwargs_)
        if host_numa_node is None:
            self.host_numa_node = []
        else:
            self.host_numa_node = host_numa_node
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumaNodes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumaNodes.subclass:
            return NumaNodes.subclass(*args_, **kwargs_)
        else:
            return NumaNodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_numa_node(self):
        return self.host_numa_node
    def set_host_numa_node(self, host_numa_node):
        self.host_numa_node = host_numa_node
    def add_host_numa_node(self, value):
        self.host_numa_node.append(value)
    def insert_host_numa_node_at(self, index, value):
        self.host_numa_node.insert(index, value)
    def replace_host_numa_node_at(self, index, value):
        self.host_numa_node[index] = value
    host_numa_nodeProp = property(get_host_numa_node, set_host_numa_node)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.host_numa_node or
            super(NumaNodes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='host_numa_nodes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('host_numa_nodes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_numa_nodes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='host_numa_nodes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='host_numa_nodes'):
        super(NumaNodes, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='host_numa_nodes')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='host_numa_nodes', fromsubclass_=False, pretty_print=True):
        super(NumaNodes, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for host_numa_node_ in self.host_numa_node:
            host_numa_node_.export(outfile, level, namespaceprefix_, name_='host_numa_node', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NumaNodes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_numa_node':
            class_obj_ = self.get_class_obj_(child_, NumaNode)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.host_numa_node.append(obj_)
            obj_.original_tagname_ = 'host_numa_node'
        super(NumaNodes, self).buildChildren(child_, node, nodeName_, True)
# end class NumaNodes


class VirtualNumaNode(NumaNode):
    subclass = None
    superclass = NumaNode
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, host=None, index=None, memory=None, cpu=None, statistics=None, node_distance=None, vm=None, numa_node_pins=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VirtualNumaNode, self).__init__(actions, href, id, name, description, comment, creation_status, link, host, index, memory, cpu, statistics, node_distance,  **kwargs_)
        self.vm = vm
        self.numa_node_pins = numa_node_pins
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VirtualNumaNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VirtualNumaNode.subclass:
            return VirtualNumaNode.subclass(*args_, **kwargs_)
        else:
            return VirtualNumaNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_numa_node_pins(self):
        return self.numa_node_pins
    def set_numa_node_pins(self, numa_node_pins):
        self.numa_node_pins = numa_node_pins
    numa_node_pinsProp = property(get_numa_node_pins, set_numa_node_pins)
    def hasContent_(self):
        if (
            self.vm is not None or
            self.numa_node_pins is not None or
            super(VirtualNumaNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_numa_node', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_numa_node')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_numa_node')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_numa_node', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_numa_node'):
        super(VirtualNumaNode, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_numa_node')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_numa_node', fromsubclass_=False, pretty_print=True):
        super(VirtualNumaNode, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.numa_node_pins is not None:
            self.numa_node_pins.export(outfile, level, namespaceprefix_, name_='numa_node_pins', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualNumaNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'numa_node_pins':
            obj_ = NumaNodePins.factory(parent_object_=self)
            obj_.build(child_)
            self.numa_node_pins = obj_
            obj_.original_tagname_ = 'numa_node_pins'
        super(VirtualNumaNode, self).buildChildren(child_, node, nodeName_, True)
# end class VirtualNumaNode


class VirtualNumaNodes(NumaNodes):
    subclass = None
    superclass = NumaNodes
    def __init__(self, actions=None, size=None, total=None, active=None, host_numa_node=None, vm_numa_node=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VirtualNumaNodes, self).__init__(actions, size, total, active, host_numa_node,  **kwargs_)
        if vm_numa_node is None:
            self.vm_numa_node = []
        else:
            self.vm_numa_node = vm_numa_node
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VirtualNumaNodes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VirtualNumaNodes.subclass:
            return VirtualNumaNodes.subclass(*args_, **kwargs_)
        else:
            return VirtualNumaNodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm_numa_node(self):
        return self.vm_numa_node
    def set_vm_numa_node(self, vm_numa_node):
        self.vm_numa_node = vm_numa_node
    def add_vm_numa_node(self, value):
        self.vm_numa_node.append(value)
    def insert_vm_numa_node_at(self, index, value):
        self.vm_numa_node.insert(index, value)
    def replace_vm_numa_node_at(self, index, value):
        self.vm_numa_node[index] = value
    vm_numa_nodeProp = property(get_vm_numa_node, set_vm_numa_node)
    def hasContent_(self):
        if (
            self.vm_numa_node or
            super(VirtualNumaNodes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='vm_numa_nodes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vm_numa_nodes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_numa_nodes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='vm_numa_nodes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vm_numa_nodes'):
        super(VirtualNumaNodes, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vm_numa_nodes')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='vm_numa_nodes', fromsubclass_=False, pretty_print=True):
        super(VirtualNumaNodes, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vm_numa_node_ in self.vm_numa_node:
            vm_numa_node_.export(outfile, level, namespaceprefix_, name_='vm_numa_node', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualNumaNodes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm_numa_node':
            obj_ = VirtualNumaNode.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_numa_node.append(obj_)
            obj_.original_tagname_ = 'vm_numa_node'
        super(VirtualNumaNodes, self).buildChildren(child_, node, nodeName_, True)
# end class VirtualNumaNodes


class QoSs(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, qos=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QoSs, self).__init__(actions, size, total, active,  **kwargs_)
        if qos is None:
            self.qos = []
        else:
            self.qos = qos
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QoSs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QoSs.subclass:
            return QoSs.subclass(*args_, **kwargs_)
        else:
            return QoSs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    def add_qos(self, value):
        self.qos.append(value)
    def insert_qos_at(self, index, value):
        self.qos.insert(index, value)
    def replace_qos_at(self, index, value):
        self.qos[index] = value
    qosProp = property(get_qos, set_qos)
    def hasContent_(self):
        if (
            self.qos or
            super(QoSs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='qoss', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qoss')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qoss')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='qoss', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qoss'):
        super(QoSs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qoss')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='qoss', fromsubclass_=False, pretty_print=True):
        super(QoSs, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for qos_ in self.qos:
            qos_.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QoSs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos.append(obj_)
            obj_.original_tagname_ = 'qos'
        super(QoSs, self).buildChildren(child_, node, nodeName_, True)
# end class QoSs


class NumaNodePins(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numa_node_pin=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if numa_node_pin is None:
            self.numa_node_pin = []
        else:
            self.numa_node_pin = numa_node_pin
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumaNodePins)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumaNodePins.subclass:
            return NumaNodePins.subclass(*args_, **kwargs_)
        else:
            return NumaNodePins(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numa_node_pin(self):
        return self.numa_node_pin
    def set_numa_node_pin(self, numa_node_pin):
        self.numa_node_pin = numa_node_pin
    def add_numa_node_pin(self, value):
        self.numa_node_pin.append(value)
    def insert_numa_node_pin_at(self, index, value):
        self.numa_node_pin.insert(index, value)
    def replace_numa_node_pin_at(self, index, value):
        self.numa_node_pin[index] = value
    numa_node_pinProp = property(get_numa_node_pin, set_numa_node_pin)
    def hasContent_(self):
        if (
            self.numa_node_pin
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='numa_node_pins', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numa_node_pins')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='numa_node_pins')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='numa_node_pins', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='numa_node_pins'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='numa_node_pins', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for numa_node_pin_ in self.numa_node_pin:
            numa_node_pin_.export(outfile, level, namespaceprefix_, name_='numa_node_pin', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numa_node_pin':
            obj_ = NumaNodePin.factory(parent_object_=self)
            obj_.build(child_)
            self.numa_node_pin.append(obj_)
            obj_.original_tagname_ = 'numa_node_pin'
# end class NumaNodePins


class NumaNodePin(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pinned=None, index=None, host_numa_node=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.pinned = _cast(bool, pinned)
        self.index = _cast(int, index)
        self.host_numa_node = host_numa_node
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumaNodePin)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumaNodePin.subclass:
            return NumaNodePin.subclass(*args_, **kwargs_)
        else:
            return NumaNodePin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host_numa_node(self):
        return self.host_numa_node
    def set_host_numa_node(self, host_numa_node):
        self.host_numa_node = host_numa_node
    host_numa_nodeProp = property(get_host_numa_node, set_host_numa_node)
    def get_pinned(self):
        return self.pinned
    def set_pinned(self, pinned):
        self.pinned = pinned
    pinnedProp = property(get_pinned, set_pinned)
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    indexProp = property(get_index, set_index)
    def hasContent_(self):
        if (
            self.host_numa_node is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='numa_node_pin', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('numa_node_pin')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='numa_node_pin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='numa_node_pin', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='numa_node_pin'):
        if self.pinned is not None and 'pinned' not in already_processed:
            already_processed.add('pinned')
            outfile.write(' pinned="%s"' % self.gds_format_boolean(self.pinned, input_name='pinned'))
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='numa_node_pin', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.host_numa_node is not None:
            self.host_numa_node.export(outfile, level, namespaceprefix_, name_='host_numa_node', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pinned', node)
        if value is not None and 'pinned' not in already_processed:
            already_processed.add('pinned')
            if value in ('true', '1'):
                self.pinned = True
            elif value in ('false', '0'):
                self.pinned = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            try:
                self.index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'host_numa_node':
            class_obj_ = self.get_class_obj_(child_, NumaNode)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.host_numa_node = obj_
            obj_.original_tagname_ = 'host_numa_node'
# end class NumaNodePin


class Cores(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, core=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if core is None:
            self.core = []
        else:
            self.core = core
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cores)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cores.subclass:
            return Cores.subclass(*args_, **kwargs_)
        else:
            return Cores(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_core(self):
        return self.core
    def set_core(self, core):
        self.core = core
    def add_core(self, value):
        self.core.append(value)
    def insert_core_at(self, index, value):
        self.core.insert(index, value)
    def replace_core_at(self, index, value):
        self.core[index] = value
    coreProp = property(get_core, set_core)
    def hasContent_(self):
        if (
            self.core
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cores', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cores')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cores')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cores', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cores'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cores', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for core_ in self.core:
            core_.export(outfile, level, namespaceprefix_, name_='core', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'core':
            obj_ = Core.factory(parent_object_=self)
            obj_.build(child_)
            self.core.append(obj_)
            obj_.original_tagname_ = 'core'
# end class Cores


class Core(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, index=None, socket=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.index = _cast(int, index)
        self.socket = _cast(int, socket)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Core)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Core.subclass:
            return Core.subclass(*args_, **kwargs_)
        else:
            return Core(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    indexProp = property(get_index, set_index)
    def get_socket(self):
        return self.socket
    def set_socket(self, socket):
        self.socket = socket
    socketProp = property(get_socket, set_socket)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='core', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('core')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='core')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='core', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='core'):
        if self.index is not None and 'index' not in already_processed:
            already_processed.add('index')
            outfile.write(' index="%s"' % self.gds_format_integer(self.index, input_name='index'))
        if self.socket is not None and 'socket' not in already_processed:
            already_processed.add('socket')
            outfile.write(' socket="%s"' % self.gds_format_integer(self.socket, input_name='socket'))
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='core', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('index', node)
        if value is not None and 'index' not in already_processed:
            already_processed.add('index')
            try:
                self.index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('socket', node)
        if value is not None and 'socket' not in already_processed:
            already_processed.add('socket')
            try:
                self.socket = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Core


class QosTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qos_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if qos_type is None:
            self.qos_type = []
        else:
            self.qos_type = qos_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QosTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QosTypes.subclass:
            return QosTypes.subclass(*args_, **kwargs_)
        else:
            return QosTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qos_type(self):
        return self.qos_type
    def set_qos_type(self, qos_type):
        self.qos_type = qos_type
    def add_qos_type(self, value):
        self.qos_type.append(value)
    def insert_qos_type_at(self, index, value):
        self.qos_type.insert(index, value)
    def replace_qos_type_at(self, index, value):
        self.qos_type[index] = value
    qos_typeProp = property(get_qos_type, set_qos_type)
    def hasContent_(self):
        if (
            self.qos_type
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='qos_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qos_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qos_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='qos_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qos_types'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='qos_types', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for qos_type_ in self.qos_type:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqos_type>%s</%sqos_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(qos_type_), input_name='qos_type')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qos_type':
            qos_type_ = child_.text
            qos_type_ = self.gds_validate_string(qos_type_, node, 'qos_type')
            self.qos_type.append(qos_type_)
# end class QosTypes


class IscsiBond(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, data_center=None, storage_connections=None, networks=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(IscsiBond, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.data_center = data_center
        self.storage_connections = storage_connections
        self.networks = networks
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IscsiBond)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IscsiBond.subclass:
            return IscsiBond.subclass(*args_, **kwargs_)
        else:
            return IscsiBond(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def get_storage_connections(self):
        return self.storage_connections
    def set_storage_connections(self, storage_connections):
        self.storage_connections = storage_connections
    storage_connectionsProp = property(get_storage_connections, set_storage_connections)
    def get_networks(self):
        return self.networks
    def set_networks(self, networks):
        self.networks = networks
    networksProp = property(get_networks, set_networks)
    def hasContent_(self):
        if (
            self.data_center is not None or
            self.storage_connections is not None or
            self.networks is not None or
            super(IscsiBond, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='iscsi_bond', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iscsi_bond')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iscsi_bond')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='iscsi_bond', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='iscsi_bond'):
        super(IscsiBond, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iscsi_bond')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='iscsi_bond', fromsubclass_=False, pretty_print=True):
        super(IscsiBond, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
        if self.storage_connections is not None:
            self.storage_connections.export(outfile, level, namespaceprefix_, name_='storage_connections', pretty_print=pretty_print)
        if self.networks is not None:
            self.networks.export(outfile, level, namespaceprefix_, name_='networks', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IscsiBond, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        elif nodeName_ == 'storage_connections':
            obj_ = StorageConnections.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_connections = obj_
            obj_.original_tagname_ = 'storage_connections'
        elif nodeName_ == 'networks':
            obj_ = Networks.factory(parent_object_=self)
            obj_.build(child_)
            self.networks = obj_
            obj_.original_tagname_ = 'networks'
        super(IscsiBond, self).buildChildren(child_, node, nodeName_, True)
# end class IscsiBond


class IscsiBonds(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, iscsi_bond=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(IscsiBonds, self).__init__(actions, size, total, active,  **kwargs_)
        if iscsi_bond is None:
            self.iscsi_bond = []
        else:
            self.iscsi_bond = iscsi_bond
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IscsiBonds)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IscsiBonds.subclass:
            return IscsiBonds.subclass(*args_, **kwargs_)
        else:
            return IscsiBonds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iscsi_bond(self):
        return self.iscsi_bond
    def set_iscsi_bond(self, iscsi_bond):
        self.iscsi_bond = iscsi_bond
    def add_iscsi_bond(self, value):
        self.iscsi_bond.append(value)
    def insert_iscsi_bond_at(self, index, value):
        self.iscsi_bond.insert(index, value)
    def replace_iscsi_bond_at(self, index, value):
        self.iscsi_bond[index] = value
    iscsi_bondProp = property(get_iscsi_bond, set_iscsi_bond)
    def hasContent_(self):
        if (
            self.iscsi_bond or
            super(IscsiBonds, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='iscsi_bonds', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('iscsi_bonds')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iscsi_bonds')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='iscsi_bonds', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='iscsi_bonds'):
        super(IscsiBonds, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='iscsi_bonds')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='iscsi_bonds', fromsubclass_=False, pretty_print=True):
        super(IscsiBonds, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for iscsi_bond_ in self.iscsi_bond:
            iscsi_bond_.export(outfile, level, namespaceprefix_, name_='iscsi_bond', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IscsiBonds, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'iscsi_bond':
            obj_ = IscsiBond.factory(parent_object_=self)
            obj_.build(child_)
            self.iscsi_bond.append(obj_)
            obj_.original_tagname_ = 'iscsi_bond'
        super(IscsiBonds, self).buildChildren(child_, node, nodeName_, True)
# end class IscsiBonds


class DiskProfile(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, qos=None, storage_domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DiskProfile, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.qos = qos
        self.storage_domain = storage_domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskProfile.subclass:
            return DiskProfile.subclass(*args_, **kwargs_)
        else:
            return DiskProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    qosProp = property(get_qos, set_qos)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def hasContent_(self):
        if (
            self.qos is not None or
            self.storage_domain is not None or
            super(DiskProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_profile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_profile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_profile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_profile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_profile'):
        super(DiskProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_profile')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_profile', fromsubclass_=False, pretty_print=True):
        super(DiskProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qos is not None:
            self.qos.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos = obj_
            obj_.original_tagname_ = 'qos'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        super(DiskProfile, self).buildChildren(child_, node, nodeName_, True)
# end class DiskProfile


class DiskProfiles(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, disk_profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DiskProfiles, self).__init__(actions, size, total, active,  **kwargs_)
        if disk_profile is None:
            self.disk_profile = []
        else:
            self.disk_profile = disk_profile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DiskProfiles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DiskProfiles.subclass:
            return DiskProfiles.subclass(*args_, **kwargs_)
        else:
            return DiskProfiles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_disk_profile(self):
        return self.disk_profile
    def set_disk_profile(self, disk_profile):
        self.disk_profile = disk_profile
    def add_disk_profile(self, value):
        self.disk_profile.append(value)
    def insert_disk_profile_at(self, index, value):
        self.disk_profile.insert(index, value)
    def replace_disk_profile_at(self, index, value):
        self.disk_profile[index] = value
    disk_profileProp = property(get_disk_profile, set_disk_profile)
    def hasContent_(self):
        if (
            self.disk_profile or
            super(DiskProfiles, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='disk_profiles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('disk_profiles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_profiles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='disk_profiles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='disk_profiles'):
        super(DiskProfiles, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='disk_profiles')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='disk_profiles', fromsubclass_=False, pretty_print=True):
        super(DiskProfiles, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for disk_profile_ in self.disk_profile:
            disk_profile_.export(outfile, level, namespaceprefix_, name_='disk_profile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskProfiles, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'disk_profile':
            obj_ = DiskProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_profile.append(obj_)
            obj_.original_tagname_ = 'disk_profile'
        super(DiskProfiles, self).buildChildren(child_, node, nodeName_, True)
# end class DiskProfiles


class CpuProfile(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, qos=None, cluster=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CpuProfile, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.qos = qos
        self.cluster = cluster
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CpuProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CpuProfile.subclass:
            return CpuProfile.subclass(*args_, **kwargs_)
        else:
            return CpuProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qos(self):
        return self.qos
    def set_qos(self, qos):
        self.qos = qos
    qosProp = property(get_qos, set_qos)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def hasContent_(self):
        if (
            self.qos is not None or
            self.cluster is not None or
            super(CpuProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cpu_profile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpu_profile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu_profile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cpu_profile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpu_profile'):
        super(CpuProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu_profile')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cpu_profile', fromsubclass_=False, pretty_print=True):
        super(CpuProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qos is not None:
            self.qos.export(outfile, level, namespaceprefix_, name_='qos', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CpuProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qos':
            obj_ = QoS.factory(parent_object_=self)
            obj_.build(child_)
            self.qos = obj_
            obj_.original_tagname_ = 'qos'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        super(CpuProfile, self).buildChildren(child_, node, nodeName_, True)
# end class CpuProfile


class CpuProfiles(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, cpu_profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CpuProfiles, self).__init__(actions, size, total, active,  **kwargs_)
        if cpu_profile is None:
            self.cpu_profile = []
        else:
            self.cpu_profile = cpu_profile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CpuProfiles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CpuProfiles.subclass:
            return CpuProfiles.subclass(*args_, **kwargs_)
        else:
            return CpuProfiles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu_profile(self):
        return self.cpu_profile
    def set_cpu_profile(self, cpu_profile):
        self.cpu_profile = cpu_profile
    def add_cpu_profile(self, value):
        self.cpu_profile.append(value)
    def insert_cpu_profile_at(self, index, value):
        self.cpu_profile.insert(index, value)
    def replace_cpu_profile_at(self, index, value):
        self.cpu_profile[index] = value
    cpu_profileProp = property(get_cpu_profile, set_cpu_profile)
    def hasContent_(self):
        if (
            self.cpu_profile or
            super(CpuProfiles, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='cpu_profiles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpu_profiles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu_profiles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='cpu_profiles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpu_profiles'):
        super(CpuProfiles, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpu_profiles')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='cpu_profiles', fromsubclass_=False, pretty_print=True):
        super(CpuProfiles, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cpu_profile_ in self.cpu_profile:
            cpu_profile_.export(outfile, level, namespaceprefix_, name_='cpu_profile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CpuProfiles, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpu_profile':
            obj_ = CpuProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu_profile.append(obj_)
            obj_.original_tagname_ = 'cpu_profile'
        super(CpuProfiles, self).buildChildren(child_, node, nodeName_, True)
# end class CpuProfiles


class OperatingSystemInfo(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, large_icon=None, small_icon=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OperatingSystemInfo, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.large_icon = large_icon
        self.small_icon = small_icon
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperatingSystemInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperatingSystemInfo.subclass:
            return OperatingSystemInfo.subclass(*args_, **kwargs_)
        else:
            return OperatingSystemInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_large_icon(self):
        return self.large_icon
    def set_large_icon(self, large_icon):
        self.large_icon = large_icon
    large_iconProp = property(get_large_icon, set_large_icon)
    def get_small_icon(self):
        return self.small_icon
    def set_small_icon(self, small_icon):
        self.small_icon = small_icon
    small_iconProp = property(get_small_icon, set_small_icon)
    def hasContent_(self):
        if (
            self.large_icon is not None or
            self.small_icon is not None or
            super(OperatingSystemInfo, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='operating_system', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('operating_system')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='operating_system')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='operating_system', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='operating_system'):
        super(OperatingSystemInfo, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='operating_system')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='operating_system', fromsubclass_=False, pretty_print=True):
        super(OperatingSystemInfo, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.large_icon is not None:
            self.large_icon.export(outfile, level, namespaceprefix_, name_='large_icon', pretty_print=pretty_print)
        if self.small_icon is not None:
            self.small_icon.export(outfile, level, namespaceprefix_, name_='small_icon', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OperatingSystemInfo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'large_icon':
            obj_ = Icon.factory(parent_object_=self)
            obj_.build(child_)
            self.large_icon = obj_
            obj_.original_tagname_ = 'large_icon'
        elif nodeName_ == 'small_icon':
            obj_ = Icon.factory(parent_object_=self)
            obj_.build(child_)
            self.small_icon = obj_
            obj_.original_tagname_ = 'small_icon'
        super(OperatingSystemInfo, self).buildChildren(child_, node, nodeName_, True)
# end class OperatingSystemInfo


class OperatingSystemInfos(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, operating_system=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OperatingSystemInfos, self).__init__(actions, size, total, active,  **kwargs_)
        if operating_system is None:
            self.operating_system = []
        else:
            self.operating_system = operating_system
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperatingSystemInfos)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperatingSystemInfos.subclass:
            return OperatingSystemInfos.subclass(*args_, **kwargs_)
        else:
            return OperatingSystemInfos(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operating_system(self):
        return self.operating_system
    def set_operating_system(self, operating_system):
        self.operating_system = operating_system
    def add_operating_system(self, value):
        self.operating_system.append(value)
    def insert_operating_system_at(self, index, value):
        self.operating_system.insert(index, value)
    def replace_operating_system_at(self, index, value):
        self.operating_system[index] = value
    operating_systemProp = property(get_operating_system, set_operating_system)
    def hasContent_(self):
        if (
            self.operating_system or
            super(OperatingSystemInfos, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='operating_systems', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('operating_systems')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='operating_systems')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='operating_systems', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='operating_systems'):
        super(OperatingSystemInfos, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='operating_systems')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='operating_systems', fromsubclass_=False, pretty_print=True):
        super(OperatingSystemInfos, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for operating_system_ in self.operating_system:
            operating_system_.export(outfile, level, namespaceprefix_, name_='operating_system', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OperatingSystemInfos, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'operating_system':
            obj_ = OperatingSystemInfo.factory(parent_object_=self)
            obj_.build(child_)
            self.operating_system.append(obj_)
            obj_.original_tagname_ = 'operating_system'
        super(OperatingSystemInfos, self).buildChildren(child_, node, nodeName_, True)
# end class OperatingSystemInfos


class ExternalProvider(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, url=None, requires_authentication=None, username=None, password=None, authentication_url=None, properties=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalProvider, self).__init__(actions, href, id, name, description, comment, creation_status, link, extensiontype_,  **kwargs_)
        self.url = url
        self.requires_authentication = requires_authentication
        self.username = username
        self.password = password
        self.authentication_url = authentication_url
        self.properties = properties
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalProvider.subclass:
            return ExternalProvider.subclass(*args_, **kwargs_)
        else:
            return ExternalProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    urlProp = property(get_url, set_url)
    def get_requires_authentication(self):
        return self.requires_authentication
    def set_requires_authentication(self, requires_authentication):
        self.requires_authentication = requires_authentication
    requires_authenticationProp = property(get_requires_authentication, set_requires_authentication)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def get_authentication_url(self):
        return self.authentication_url
    def set_authentication_url(self, authentication_url):
        self.authentication_url = authentication_url
    authentication_urlProp = property(get_authentication_url, set_authentication_url)
    def get_properties(self):
        return self.properties
    def set_properties(self, properties):
        self.properties = properties
    propertiesProp = property(get_properties, set_properties)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.url is not None or
            self.requires_authentication is not None or
            self.username is not None or
            self.password is not None or
            self.authentication_url is not None or
            self.properties is not None or
            super(ExternalProvider, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='ExternalProvider', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalProvider')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalProvider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='ExternalProvider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ExternalProvider'):
        super(ExternalProvider, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalProvider')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='ExternalProvider', fromsubclass_=False, pretty_print=True):
        super(ExternalProvider, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespaceprefix_ , eol_))
        if self.requires_authentication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequires_authentication>%s</%srequires_authentication>%s' % (namespaceprefix_ , self.gds_format_boolean(self.requires_authentication, input_name='requires_authentication'), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
        if self.authentication_url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sauthentication_url>%s</%sauthentication_url>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.authentication_url), input_name='authentication_url')), namespaceprefix_ , eol_))
        if self.properties is not None:
            self.properties.export(outfile, level, namespaceprefix_, name_='properties', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExternalProvider, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'requires_authentication':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'requires_authentication')
            self.requires_authentication = ival_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
        elif nodeName_ == 'authentication_url':
            authentication_url_ = child_.text
            authentication_url_ = self.gds_validate_string(authentication_url_, node, 'authentication_url')
            self.authentication_url = authentication_url_
        elif nodeName_ == 'properties':
            obj_ = Properties.factory(parent_object_=self)
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        super(ExternalProvider, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalProvider


class ExternalHostProvider(ExternalProvider):
    subclass = None
    superclass = ExternalProvider
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, url=None, requires_authentication=None, username=None, password=None, authentication_url=None, properties=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalHostProvider, self).__init__(actions, href, id, name, description, comment, creation_status, link, url, requires_authentication, username, password, authentication_url, properties,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalHostProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalHostProvider.subclass:
            return ExternalHostProvider.subclass(*args_, **kwargs_)
        else:
            return ExternalHostProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ExternalHostProvider, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_host_provider', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_host_provider')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_provider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_host_provider'):
        super(ExternalHostProvider, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_provider')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_host_provider', fromsubclass_=False, pretty_print=True):
        super(ExternalHostProvider, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalHostProvider, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExternalHostProvider, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExternalHostProvider


class ExternalHostProviders(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, external_host_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalHostProviders, self).__init__(actions, size, total, active,  **kwargs_)
        if external_host_provider is None:
            self.external_host_provider = []
        else:
            self.external_host_provider = external_host_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalHostProviders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalHostProviders.subclass:
            return ExternalHostProviders.subclass(*args_, **kwargs_)
        else:
            return ExternalHostProviders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    def add_external_host_provider(self, value):
        self.external_host_provider.append(value)
    def insert_external_host_provider_at(self, index, value):
        self.external_host_provider.insert(index, value)
    def replace_external_host_provider_at(self, index, value):
        self.external_host_provider[index] = value
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def hasContent_(self):
        if (
            self.external_host_provider or
            super(ExternalHostProviders, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_host_providers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_host_providers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_providers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_host_providers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_host_providers'):
        super(ExternalHostProviders, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_providers')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_host_providers', fromsubclass_=False, pretty_print=True):
        super(ExternalHostProviders, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_host_provider_ in self.external_host_provider:
            external_host_provider_.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalHostProviders, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider.append(obj_)
            obj_.original_tagname_ = 'external_host_provider'
        super(ExternalHostProviders, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalHostProviders


class ExternalHost(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, external_host_provider=None, address=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalHost, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.external_host_provider = external_host_provider
        self.address = address
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalHost)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalHost.subclass:
            return ExternalHost.subclass(*args_, **kwargs_)
        else:
            return ExternalHost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def hasContent_(self):
        if (
            self.external_host_provider is not None or
            self.address is not None or
            super(ExternalHost, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_host', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_host')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_host', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_host'):
        super(ExternalHost, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_host', fromsubclass_=False, pretty_print=True):
        super(ExternalHost, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.external_host_provider is not None:
            self.external_host_provider.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalHost, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider = obj_
            obj_.original_tagname_ = 'external_host_provider'
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        super(ExternalHost, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalHost


class ExternalHosts(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, external_host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalHosts, self).__init__(actions, size, total, active,  **kwargs_)
        if external_host is None:
            self.external_host = []
        else:
            self.external_host = external_host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalHosts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalHosts.subclass:
            return ExternalHosts.subclass(*args_, **kwargs_)
        else:
            return ExternalHosts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_host(self):
        return self.external_host
    def set_external_host(self, external_host):
        self.external_host = external_host
    def add_external_host(self, value):
        self.external_host.append(value)
    def insert_external_host_at(self, index, value):
        self.external_host.insert(index, value)
    def replace_external_host_at(self, index, value):
        self.external_host[index] = value
    external_hostProp = property(get_external_host, set_external_host)
    def hasContent_(self):
        if (
            self.external_host or
            super(ExternalHosts, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_hosts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_hosts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_hosts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_hosts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_hosts'):
        super(ExternalHosts, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_hosts')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_hosts', fromsubclass_=False, pretty_print=True):
        super(ExternalHosts, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_host_ in self.external_host:
            external_host_.export(outfile, level, namespaceprefix_, name_='external_host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalHosts, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_host':
            obj_ = ExternalHost.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host.append(obj_)
            obj_.original_tagname_ = 'external_host'
        super(ExternalHosts, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalHosts


class ExternalDiscoveredHost(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, ip=None, mac=None, subnet_name=None, last_report=None, external_host_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalDiscoveredHost, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.ip = ip
        self.mac = mac
        self.subnet_name = subnet_name
        self.last_report = last_report
        self.external_host_provider = external_host_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalDiscoveredHost)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalDiscoveredHost.subclass:
            return ExternalDiscoveredHost.subclass(*args_, **kwargs_)
        else:
            return ExternalDiscoveredHost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip(self):
        return self.ip
    def set_ip(self, ip):
        self.ip = ip
    ipProp = property(get_ip, set_ip)
    def get_mac(self):
        return self.mac
    def set_mac(self, mac):
        self.mac = mac
    macProp = property(get_mac, set_mac)
    def get_subnet_name(self):
        return self.subnet_name
    def set_subnet_name(self, subnet_name):
        self.subnet_name = subnet_name
    subnet_nameProp = property(get_subnet_name, set_subnet_name)
    def get_last_report(self):
        return self.last_report
    def set_last_report(self, last_report):
        self.last_report = last_report
    last_reportProp = property(get_last_report, set_last_report)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def hasContent_(self):
        if (
            self.ip is not None or
            self.mac is not None or
            self.subnet_name is not None or
            self.last_report is not None or
            self.external_host_provider is not None or
            super(ExternalDiscoveredHost, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_discovered_host', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_discovered_host')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_discovered_host')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_discovered_host', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_discovered_host'):
        super(ExternalDiscoveredHost, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_discovered_host')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_discovered_host', fromsubclass_=False, pretty_print=True):
        super(ExternalDiscoveredHost, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip>%s</%sip>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ip), input_name='ip')), namespaceprefix_ , eol_))
        if self.mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac>%s</%smac>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mac), input_name='mac')), namespaceprefix_ , eol_))
        if self.subnet_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet_name>%s</%ssubnet_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subnet_name), input_name='subnet_name')), namespaceprefix_ , eol_))
        if self.last_report is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast_report>%s</%slast_report>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.last_report), input_name='last_report')), namespaceprefix_ , eol_))
        if self.external_host_provider is not None:
            self.external_host_provider.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalDiscoveredHost, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip':
            ip_ = child_.text
            ip_ = self.gds_validate_string(ip_, node, 'ip')
            self.ip = ip_
        elif nodeName_ == 'mac':
            mac_ = child_.text
            mac_ = self.gds_validate_string(mac_, node, 'mac')
            self.mac = mac_
        elif nodeName_ == 'subnet_name':
            subnet_name_ = child_.text
            subnet_name_ = self.gds_validate_string(subnet_name_, node, 'subnet_name')
            self.subnet_name = subnet_name_
        elif nodeName_ == 'last_report':
            last_report_ = child_.text
            last_report_ = self.gds_validate_string(last_report_, node, 'last_report')
            self.last_report = last_report_
        elif nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider = obj_
            obj_.original_tagname_ = 'external_host_provider'
        super(ExternalDiscoveredHost, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalDiscoveredHost


class ExternalDiscoveredHosts(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, external_discovered_host=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalDiscoveredHosts, self).__init__(actions, size, total, active,  **kwargs_)
        if external_discovered_host is None:
            self.external_discovered_host = []
        else:
            self.external_discovered_host = external_discovered_host
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalDiscoveredHosts)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalDiscoveredHosts.subclass:
            return ExternalDiscoveredHosts.subclass(*args_, **kwargs_)
        else:
            return ExternalDiscoveredHosts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_discovered_host(self):
        return self.external_discovered_host
    def set_external_discovered_host(self, external_discovered_host):
        self.external_discovered_host = external_discovered_host
    def add_external_discovered_host(self, value):
        self.external_discovered_host.append(value)
    def insert_external_discovered_host_at(self, index, value):
        self.external_discovered_host.insert(index, value)
    def replace_external_discovered_host_at(self, index, value):
        self.external_discovered_host[index] = value
    external_discovered_hostProp = property(get_external_discovered_host, set_external_discovered_host)
    def hasContent_(self):
        if (
            self.external_discovered_host or
            super(ExternalDiscoveredHosts, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_discovered_hosts', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_discovered_hosts')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_discovered_hosts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_discovered_hosts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_discovered_hosts'):
        super(ExternalDiscoveredHosts, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_discovered_hosts')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_discovered_hosts', fromsubclass_=False, pretty_print=True):
        super(ExternalDiscoveredHosts, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_discovered_host_ in self.external_discovered_host:
            external_discovered_host_.export(outfile, level, namespaceprefix_, name_='external_discovered_host', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalDiscoveredHosts, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_discovered_host':
            obj_ = ExternalDiscoveredHost.factory(parent_object_=self)
            obj_.build(child_)
            self.external_discovered_host.append(obj_)
            obj_.original_tagname_ = 'external_discovered_host'
        super(ExternalDiscoveredHosts, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalDiscoveredHosts


class ExternalHostGroup(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, architecture_name=None, operating_system_name=None, domain_name=None, subnet_name=None, external_host_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalHostGroup, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.architecture_name = architecture_name
        self.operating_system_name = operating_system_name
        self.domain_name = domain_name
        self.subnet_name = subnet_name
        self.external_host_provider = external_host_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalHostGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalHostGroup.subclass:
            return ExternalHostGroup.subclass(*args_, **kwargs_)
        else:
            return ExternalHostGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_architecture_name(self):
        return self.architecture_name
    def set_architecture_name(self, architecture_name):
        self.architecture_name = architecture_name
    architecture_nameProp = property(get_architecture_name, set_architecture_name)
    def get_operating_system_name(self):
        return self.operating_system_name
    def set_operating_system_name(self, operating_system_name):
        self.operating_system_name = operating_system_name
    operating_system_nameProp = property(get_operating_system_name, set_operating_system_name)
    def get_domain_name(self):
        return self.domain_name
    def set_domain_name(self, domain_name):
        self.domain_name = domain_name
    domain_nameProp = property(get_domain_name, set_domain_name)
    def get_subnet_name(self):
        return self.subnet_name
    def set_subnet_name(self, subnet_name):
        self.subnet_name = subnet_name
    subnet_nameProp = property(get_subnet_name, set_subnet_name)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def hasContent_(self):
        if (
            self.architecture_name is not None or
            self.operating_system_name is not None or
            self.domain_name is not None or
            self.subnet_name is not None or
            self.external_host_provider is not None or
            super(ExternalHostGroup, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_host_group', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_host_group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_host_group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_host_group'):
        super(ExternalHostGroup, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_group')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_host_group', fromsubclass_=False, pretty_print=True):
        super(ExternalHostGroup, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.architecture_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarchitecture_name>%s</%sarchitecture_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.architecture_name), input_name='architecture_name')), namespaceprefix_ , eol_))
        if self.operating_system_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soperating_system_name>%s</%soperating_system_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.operating_system_name), input_name='operating_system_name')), namespaceprefix_ , eol_))
        if self.domain_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain_name>%s</%sdomain_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.domain_name), input_name='domain_name')), namespaceprefix_ , eol_))
        if self.subnet_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubnet_name>%s</%ssubnet_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subnet_name), input_name='subnet_name')), namespaceprefix_ , eol_))
        if self.external_host_provider is not None:
            self.external_host_provider.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalHostGroup, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'architecture_name':
            architecture_name_ = child_.text
            architecture_name_ = self.gds_validate_string(architecture_name_, node, 'architecture_name')
            self.architecture_name = architecture_name_
        elif nodeName_ == 'operating_system_name':
            operating_system_name_ = child_.text
            operating_system_name_ = self.gds_validate_string(operating_system_name_, node, 'operating_system_name')
            self.operating_system_name = operating_system_name_
        elif nodeName_ == 'domain_name':
            domain_name_ = child_.text
            domain_name_ = self.gds_validate_string(domain_name_, node, 'domain_name')
            self.domain_name = domain_name_
        elif nodeName_ == 'subnet_name':
            subnet_name_ = child_.text
            subnet_name_ = self.gds_validate_string(subnet_name_, node, 'subnet_name')
            self.subnet_name = subnet_name_
        elif nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider = obj_
            obj_.original_tagname_ = 'external_host_provider'
        super(ExternalHostGroup, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalHostGroup


class ExternalHostGroups(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, external_host_group=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalHostGroups, self).__init__(actions, size, total, active,  **kwargs_)
        if external_host_group is None:
            self.external_host_group = []
        else:
            self.external_host_group = external_host_group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalHostGroups)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalHostGroups.subclass:
            return ExternalHostGroups.subclass(*args_, **kwargs_)
        else:
            return ExternalHostGroups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_host_group(self):
        return self.external_host_group
    def set_external_host_group(self, external_host_group):
        self.external_host_group = external_host_group
    def add_external_host_group(self, value):
        self.external_host_group.append(value)
    def insert_external_host_group_at(self, index, value):
        self.external_host_group.insert(index, value)
    def replace_external_host_group_at(self, index, value):
        self.external_host_group[index] = value
    external_host_groupProp = property(get_external_host_group, set_external_host_group)
    def hasContent_(self):
        if (
            self.external_host_group or
            super(ExternalHostGroups, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_host_groups', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_host_groups')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_groups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_host_groups', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_host_groups'):
        super(ExternalHostGroups, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_host_groups')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_host_groups', fromsubclass_=False, pretty_print=True):
        super(ExternalHostGroups, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_host_group_ in self.external_host_group:
            external_host_group_.export(outfile, level, namespaceprefix_, name_='external_host_group', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalHostGroups, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_host_group':
            obj_ = ExternalHostGroup.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_group.append(obj_)
            obj_.original_tagname_ = 'external_host_group'
        super(ExternalHostGroups, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalHostGroups


class ExternalComputeResource(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, provider=None, user=None, url=None, external_host_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalComputeResource, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.provider = provider
        self.user = user
        self.url = url
        self.external_host_provider = external_host_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalComputeResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalComputeResource.subclass:
            return ExternalComputeResource.subclass(*args_, **kwargs_)
        else:
            return ExternalComputeResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_provider(self):
        return self.provider
    def set_provider(self, provider):
        self.provider = provider
    providerProp = property(get_provider, set_provider)
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    userProp = property(get_user, set_user)
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    urlProp = property(get_url, set_url)
    def get_external_host_provider(self):
        return self.external_host_provider
    def set_external_host_provider(self, external_host_provider):
        self.external_host_provider = external_host_provider
    external_host_providerProp = property(get_external_host_provider, set_external_host_provider)
    def hasContent_(self):
        if (
            self.provider is not None or
            self.user is not None or
            self.url is not None or
            self.external_host_provider is not None or
            super(ExternalComputeResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_compute_resource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_compute_resource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_compute_resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_compute_resource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_compute_resource'):
        super(ExternalComputeResource, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_compute_resource')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_compute_resource', fromsubclass_=False, pretty_print=True):
        super(ExternalComputeResource, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.provider is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprovider>%s</%sprovider>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.provider), input_name='provider')), namespaceprefix_ , eol_))
        if self.user is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser>%s</%suser>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.user), input_name='user')), namespaceprefix_ , eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.url), input_name='url')), namespaceprefix_ , eol_))
        if self.external_host_provider is not None:
            self.external_host_provider.export(outfile, level, namespaceprefix_, name_='external_host_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalComputeResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'provider':
            provider_ = child_.text
            provider_ = self.gds_validate_string(provider_, node, 'provider')
            self.provider = provider_
        elif nodeName_ == 'user':
            user_ = child_.text
            user_ = self.gds_validate_string(user_, node, 'user')
            self.user = user_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'external_host_provider':
            obj_ = ExternalHostProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.external_host_provider = obj_
            obj_.original_tagname_ = 'external_host_provider'
        super(ExternalComputeResource, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalComputeResource


class ExternalComputeResources(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, external_compute_resource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalComputeResources, self).__init__(actions, size, total, active,  **kwargs_)
        if external_compute_resource is None:
            self.external_compute_resource = []
        else:
            self.external_compute_resource = external_compute_resource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalComputeResources)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalComputeResources.subclass:
            return ExternalComputeResources.subclass(*args_, **kwargs_)
        else:
            return ExternalComputeResources(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_external_compute_resource(self):
        return self.external_compute_resource
    def set_external_compute_resource(self, external_compute_resource):
        self.external_compute_resource = external_compute_resource
    def add_external_compute_resource(self, value):
        self.external_compute_resource.append(value)
    def insert_external_compute_resource_at(self, index, value):
        self.external_compute_resource.insert(index, value)
    def replace_external_compute_resource_at(self, index, value):
        self.external_compute_resource[index] = value
    external_compute_resourceProp = property(get_external_compute_resource, set_external_compute_resource)
    def hasContent_(self):
        if (
            self.external_compute_resource or
            super(ExternalComputeResources, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='external_compute_resources', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('external_compute_resources')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_compute_resources')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='external_compute_resources', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='external_compute_resources'):
        super(ExternalComputeResources, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='external_compute_resources')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='external_compute_resources', fromsubclass_=False, pretty_print=True):
        super(ExternalComputeResources, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for external_compute_resource_ in self.external_compute_resource:
            external_compute_resource_.export(outfile, level, namespaceprefix_, name_='external_compute_resource', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExternalComputeResources, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'external_compute_resource':
            obj_ = ExternalComputeResource.factory(parent_object_=self)
            obj_.build(child_)
            self.external_compute_resource.append(obj_)
            obj_.original_tagname_ = 'external_compute_resource'
        super(ExternalComputeResources, self).buildChildren(child_, node, nodeName_, True)
# end class ExternalComputeResources


class OpenStackProvider(ExternalProvider):
    subclass = None
    superclass = ExternalProvider
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, url=None, requires_authentication=None, username=None, password=None, authentication_url=None, properties=None, tenant_name=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackProvider, self).__init__(actions, href, id, name, description, comment, creation_status, link, url, requires_authentication, username, password, authentication_url, properties, extensiontype_,  **kwargs_)
        self.tenant_name = tenant_name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackProvider.subclass:
            return OpenStackProvider.subclass(*args_, **kwargs_)
        else:
            return OpenStackProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tenant_name(self):
        return self.tenant_name
    def set_tenant_name(self, tenant_name):
        self.tenant_name = tenant_name
    tenant_nameProp = property(get_tenant_name, set_tenant_name)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.tenant_name is not None or
            super(OpenStackProvider, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_provider', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_provider')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_provider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_provider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_provider'):
        super(OpenStackProvider, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_provider')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_provider', fromsubclass_=False, pretty_print=True):
        super(OpenStackProvider, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tenant_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stenant_name>%s</%stenant_name>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tenant_name), input_name='tenant_name')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(OpenStackProvider, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tenant_name':
            tenant_name_ = child_.text
            tenant_name_ = self.gds_validate_string(tenant_name_, node, 'tenant_name')
            self.tenant_name = tenant_name_
        super(OpenStackProvider, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackProvider


class OpenStackImageProvider(OpenStackProvider):
    subclass = None
    superclass = OpenStackProvider
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, url=None, requires_authentication=None, username=None, password=None, authentication_url=None, properties=None, tenant_name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackImageProvider, self).__init__(actions, href, id, name, description, comment, creation_status, link, url, requires_authentication, username, password, authentication_url, properties, tenant_name,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackImageProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackImageProvider.subclass:
            return OpenStackImageProvider.subclass(*args_, **kwargs_)
        else:
            return OpenStackImageProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(OpenStackImageProvider, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_image_provider', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_image_provider')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_image_provider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_image_provider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_image_provider'):
        super(OpenStackImageProvider, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_image_provider')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_image_provider', fromsubclass_=False, pretty_print=True):
        super(OpenStackImageProvider, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackImageProvider, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OpenStackImageProvider, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OpenStackImageProvider


class OpenStackImageProviders(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_image_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackImageProviders, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_image_provider is None:
            self.openstack_image_provider = []
        else:
            self.openstack_image_provider = openstack_image_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackImageProviders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackImageProviders.subclass:
            return OpenStackImageProviders.subclass(*args_, **kwargs_)
        else:
            return OpenStackImageProviders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_image_provider(self):
        return self.openstack_image_provider
    def set_openstack_image_provider(self, openstack_image_provider):
        self.openstack_image_provider = openstack_image_provider
    def add_openstack_image_provider(self, value):
        self.openstack_image_provider.append(value)
    def insert_openstack_image_provider_at(self, index, value):
        self.openstack_image_provider.insert(index, value)
    def replace_openstack_image_provider_at(self, index, value):
        self.openstack_image_provider[index] = value
    openstack_image_providerProp = property(get_openstack_image_provider, set_openstack_image_provider)
    def hasContent_(self):
        if (
            self.openstack_image_provider or
            super(OpenStackImageProviders, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_image_providers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_image_providers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_image_providers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_image_providers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_image_providers'):
        super(OpenStackImageProviders, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_image_providers')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_image_providers', fromsubclass_=False, pretty_print=True):
        super(OpenStackImageProviders, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_image_provider_ in self.openstack_image_provider:
            openstack_image_provider_.export(outfile, level, namespaceprefix_, name_='openstack_image_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackImageProviders, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_image_provider':
            obj_ = OpenStackImageProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_image_provider.append(obj_)
            obj_.original_tagname_ = 'openstack_image_provider'
        super(OpenStackImageProviders, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackImageProviders


class OpenStackImage(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, openstack_image_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackImage, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.openstack_image_provider = openstack_image_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackImage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackImage.subclass:
            return OpenStackImage.subclass(*args_, **kwargs_)
        else:
            return OpenStackImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_image_provider(self):
        return self.openstack_image_provider
    def set_openstack_image_provider(self, openstack_image_provider):
        self.openstack_image_provider = openstack_image_provider
    openstack_image_providerProp = property(get_openstack_image_provider, set_openstack_image_provider)
    def hasContent_(self):
        if (
            self.openstack_image_provider is not None or
            super(OpenStackImage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_image', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_image')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_image')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_image', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_image'):
        super(OpenStackImage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_image')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_image', fromsubclass_=False, pretty_print=True):
        super(OpenStackImage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openstack_image_provider is not None:
            self.openstack_image_provider.export(outfile, level, namespaceprefix_, name_='openstack_image_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackImage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_image_provider':
            obj_ = OpenStackImageProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_image_provider = obj_
            obj_.original_tagname_ = 'openstack_image_provider'
        super(OpenStackImage, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackImage


class OpenStackImages(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_image=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackImages, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_image is None:
            self.openstack_image = []
        else:
            self.openstack_image = openstack_image
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackImages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackImages.subclass:
            return OpenStackImages.subclass(*args_, **kwargs_)
        else:
            return OpenStackImages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_image(self):
        return self.openstack_image
    def set_openstack_image(self, openstack_image):
        self.openstack_image = openstack_image
    def add_openstack_image(self, value):
        self.openstack_image.append(value)
    def insert_openstack_image_at(self, index, value):
        self.openstack_image.insert(index, value)
    def replace_openstack_image_at(self, index, value):
        self.openstack_image[index] = value
    openstack_imageProp = property(get_openstack_image, set_openstack_image)
    def hasContent_(self):
        if (
            self.openstack_image or
            super(OpenStackImages, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_images', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_images')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_images')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_images', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_images'):
        super(OpenStackImages, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_images')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_images', fromsubclass_=False, pretty_print=True):
        super(OpenStackImages, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_image_ in self.openstack_image:
            openstack_image_.export(outfile, level, namespaceprefix_, name_='openstack_image', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackImages, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_image':
            obj_ = OpenStackImage.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_image.append(obj_)
            obj_.original_tagname_ = 'openstack_image'
        super(OpenStackImages, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackImages


class OpenStackVolumeProvider(OpenStackProvider):
    subclass = None
    superclass = OpenStackProvider
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, url=None, requires_authentication=None, username=None, password=None, authentication_url=None, properties=None, tenant_name=None, data_center=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackVolumeProvider, self).__init__(actions, href, id, name, description, comment, creation_status, link, url, requires_authentication, username, password, authentication_url, properties, tenant_name,  **kwargs_)
        self.data_center = data_center
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackVolumeProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackVolumeProvider.subclass:
            return OpenStackVolumeProvider.subclass(*args_, **kwargs_)
        else:
            return OpenStackVolumeProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_center(self):
        return self.data_center
    def set_data_center(self, data_center):
        self.data_center = data_center
    data_centerProp = property(get_data_center, set_data_center)
    def hasContent_(self):
        if (
            self.data_center is not None or
            super(OpenStackVolumeProvider, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_volume_provider', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_volume_provider')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_provider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_volume_provider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_volume_provider'):
        super(OpenStackVolumeProvider, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_provider')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_volume_provider', fromsubclass_=False, pretty_print=True):
        super(OpenStackVolumeProvider, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_center is not None:
            self.data_center.export(outfile, level, namespaceprefix_, name_='data_center', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackVolumeProvider, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_center':
            obj_ = DataCenter.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center = obj_
            obj_.original_tagname_ = 'data_center'
        super(OpenStackVolumeProvider, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackVolumeProvider


class OpenStackVolumeProviders(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_volume_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackVolumeProviders, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_volume_provider is None:
            self.openstack_volume_provider = []
        else:
            self.openstack_volume_provider = openstack_volume_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackVolumeProviders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackVolumeProviders.subclass:
            return OpenStackVolumeProviders.subclass(*args_, **kwargs_)
        else:
            return OpenStackVolumeProviders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_volume_provider(self):
        return self.openstack_volume_provider
    def set_openstack_volume_provider(self, openstack_volume_provider):
        self.openstack_volume_provider = openstack_volume_provider
    def add_openstack_volume_provider(self, value):
        self.openstack_volume_provider.append(value)
    def insert_openstack_volume_provider_at(self, index, value):
        self.openstack_volume_provider.insert(index, value)
    def replace_openstack_volume_provider_at(self, index, value):
        self.openstack_volume_provider[index] = value
    openstack_volume_providerProp = property(get_openstack_volume_provider, set_openstack_volume_provider)
    def hasContent_(self):
        if (
            self.openstack_volume_provider or
            super(OpenStackVolumeProviders, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_volume_providers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_volume_providers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_providers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_volume_providers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_volume_providers'):
        super(OpenStackVolumeProviders, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_providers')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_volume_providers', fromsubclass_=False, pretty_print=True):
        super(OpenStackVolumeProviders, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_volume_provider_ in self.openstack_volume_provider:
            openstack_volume_provider_.export(outfile, level, namespaceprefix_, name_='openstack_volume_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackVolumeProviders, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_volume_provider':
            obj_ = OpenStackVolumeProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_volume_provider.append(obj_)
            obj_.original_tagname_ = 'openstack_volume_provider'
        super(OpenStackVolumeProviders, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackVolumeProviders


class OpenStackVolumeType(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, properties=None, openstack_volume_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackVolumeType, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.properties = properties
        self.openstack_volume_provider = openstack_volume_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackVolumeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackVolumeType.subclass:
            return OpenStackVolumeType.subclass(*args_, **kwargs_)
        else:
            return OpenStackVolumeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_properties(self):
        return self.properties
    def set_properties(self, properties):
        self.properties = properties
    propertiesProp = property(get_properties, set_properties)
    def get_openstack_volume_provider(self):
        return self.openstack_volume_provider
    def set_openstack_volume_provider(self, openstack_volume_provider):
        self.openstack_volume_provider = openstack_volume_provider
    openstack_volume_providerProp = property(get_openstack_volume_provider, set_openstack_volume_provider)
    def hasContent_(self):
        if (
            self.properties is not None or
            self.openstack_volume_provider is not None or
            super(OpenStackVolumeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_volume_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_volume_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_volume_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_volume_type'):
        super(OpenStackVolumeType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_type')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_volume_type', fromsubclass_=False, pretty_print=True):
        super(OpenStackVolumeType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.properties is not None:
            self.properties.export(outfile, level, namespaceprefix_, name_='properties', pretty_print=pretty_print)
        if self.openstack_volume_provider is not None:
            self.openstack_volume_provider.export(outfile, level, namespaceprefix_, name_='openstack_volume_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackVolumeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'properties':
            obj_ = Properties.factory(parent_object_=self)
            obj_.build(child_)
            self.properties = obj_
            obj_.original_tagname_ = 'properties'
        elif nodeName_ == 'openstack_volume_provider':
            obj_ = OpenStackVolumeProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_volume_provider = obj_
            obj_.original_tagname_ = 'openstack_volume_provider'
        super(OpenStackVolumeType, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackVolumeType


class OpenStackVolumeTypes(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_volume_type=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackVolumeTypes, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_volume_type is None:
            self.openstack_volume_type = []
        else:
            self.openstack_volume_type = openstack_volume_type
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackVolumeTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackVolumeTypes.subclass:
            return OpenStackVolumeTypes.subclass(*args_, **kwargs_)
        else:
            return OpenStackVolumeTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_volume_type(self):
        return self.openstack_volume_type
    def set_openstack_volume_type(self, openstack_volume_type):
        self.openstack_volume_type = openstack_volume_type
    def add_openstack_volume_type(self, value):
        self.openstack_volume_type.append(value)
    def insert_openstack_volume_type_at(self, index, value):
        self.openstack_volume_type.insert(index, value)
    def replace_openstack_volume_type_at(self, index, value):
        self.openstack_volume_type[index] = value
    openstack_volume_typeProp = property(get_openstack_volume_type, set_openstack_volume_type)
    def hasContent_(self):
        if (
            self.openstack_volume_type or
            super(OpenStackVolumeTypes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_volume_types', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_volume_types')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_types')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_volume_types', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_volume_types'):
        super(OpenStackVolumeTypes, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_types')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_volume_types', fromsubclass_=False, pretty_print=True):
        super(OpenStackVolumeTypes, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_volume_type_ in self.openstack_volume_type:
            openstack_volume_type_.export(outfile, level, namespaceprefix_, name_='openstack_volume_type', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackVolumeTypes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_volume_type':
            obj_ = OpenStackVolumeType.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_volume_type.append(obj_)
            obj_.original_tagname_ = 'openstack_volume_type'
        super(OpenStackVolumeTypes, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackVolumeTypes


class OpenstackVolumeAuthenticationKey(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, uuid=None, value=None, usage_type=None, creation_date=None, openstack_volume_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenstackVolumeAuthenticationKey, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.uuid = uuid
        self.value = value
        self.usage_type = usage_type
        if isinstance(creation_date, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(creation_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creation_date
        self.creation_date = initvalue_
        self.openstack_volume_provider = openstack_volume_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenstackVolumeAuthenticationKey)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenstackVolumeAuthenticationKey.subclass:
            return OpenstackVolumeAuthenticationKey.subclass(*args_, **kwargs_)
        else:
            return OpenstackVolumeAuthenticationKey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self):
        return self.uuid
    def set_uuid(self, uuid):
        self.uuid = uuid
    uuidProp = property(get_uuid, set_uuid)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    valueProp = property(get_value, set_value)
    def get_usage_type(self):
        return self.usage_type
    def set_usage_type(self, usage_type):
        self.usage_type = usage_type
    usage_typeProp = property(get_usage_type, set_usage_type)
    def get_creation_date(self):
        return self.creation_date
    def set_creation_date(self, creation_date):
        self.creation_date = creation_date
    creation_dateProp = property(get_creation_date, set_creation_date)
    def get_openstack_volume_provider(self):
        return self.openstack_volume_provider
    def set_openstack_volume_provider(self, openstack_volume_provider):
        self.openstack_volume_provider = openstack_volume_provider
    openstack_volume_providerProp = property(get_openstack_volume_provider, set_openstack_volume_provider)
    def hasContent_(self):
        if (
            self.uuid is not None or
            self.value is not None or
            self.usage_type is not None or
            self.creation_date is not None or
            self.openstack_volume_provider is not None or
            super(OpenstackVolumeAuthenticationKey, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_volume_authentication_key', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_volume_authentication_key')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_authentication_key')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_volume_authentication_key', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_volume_authentication_key'):
        super(OpenstackVolumeAuthenticationKey, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_authentication_key')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_volume_authentication_key', fromsubclass_=False, pretty_print=True):
        super(OpenstackVolumeAuthenticationKey, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.uuid), input_name='uuid')), namespaceprefix_ , eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
        if self.usage_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage_type>%s</%susage_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage_type), input_name='usage_type')), namespaceprefix_ , eol_))
        if self.creation_date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screation_date>%s</%screation_date>%s' % (namespaceprefix_ , self.gds_format_datetime(self.creation_date, input_name='creation_date'), namespaceprefix_ , eol_))
        if self.openstack_volume_provider is not None:
            self.openstack_volume_provider.export(outfile, level, namespaceprefix_, name_='openstack_volume_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenstackVolumeAuthenticationKey, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'usage_type':
            usage_type_ = child_.text
            usage_type_ = self.gds_validate_string(usage_type_, node, 'usage_type')
            self.usage_type = usage_type_
        elif nodeName_ == 'creation_date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.creation_date = dval_
        elif nodeName_ == 'openstack_volume_provider':
            obj_ = OpenStackVolumeProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_volume_provider = obj_
            obj_.original_tagname_ = 'openstack_volume_provider'
        super(OpenstackVolumeAuthenticationKey, self).buildChildren(child_, node, nodeName_, True)
# end class OpenstackVolumeAuthenticationKey


class OpenstackVolumeAuthenticationKeys(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_volume_authentication_key=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenstackVolumeAuthenticationKeys, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_volume_authentication_key is None:
            self.openstack_volume_authentication_key = []
        else:
            self.openstack_volume_authentication_key = openstack_volume_authentication_key
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenstackVolumeAuthenticationKeys)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenstackVolumeAuthenticationKeys.subclass:
            return OpenstackVolumeAuthenticationKeys.subclass(*args_, **kwargs_)
        else:
            return OpenstackVolumeAuthenticationKeys(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_volume_authentication_key(self):
        return self.openstack_volume_authentication_key
    def set_openstack_volume_authentication_key(self, openstack_volume_authentication_key):
        self.openstack_volume_authentication_key = openstack_volume_authentication_key
    def add_openstack_volume_authentication_key(self, value):
        self.openstack_volume_authentication_key.append(value)
    def insert_openstack_volume_authentication_key_at(self, index, value):
        self.openstack_volume_authentication_key.insert(index, value)
    def replace_openstack_volume_authentication_key_at(self, index, value):
        self.openstack_volume_authentication_key[index] = value
    openstack_volume_authentication_keyProp = property(get_openstack_volume_authentication_key, set_openstack_volume_authentication_key)
    def hasContent_(self):
        if (
            self.openstack_volume_authentication_key or
            super(OpenstackVolumeAuthenticationKeys, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_volume_authentication_keys', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_volume_authentication_keys')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_authentication_keys')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_volume_authentication_keys', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_volume_authentication_keys'):
        super(OpenstackVolumeAuthenticationKeys, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_volume_authentication_keys')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_volume_authentication_keys', fromsubclass_=False, pretty_print=True):
        super(OpenstackVolumeAuthenticationKeys, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_volume_authentication_key_ in self.openstack_volume_authentication_key:
            openstack_volume_authentication_key_.export(outfile, level, namespaceprefix_, name_='openstack_volume_authentication_key', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenstackVolumeAuthenticationKeys, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_volume_authentication_key':
            obj_ = OpenstackVolumeAuthenticationKey.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_volume_authentication_key.append(obj_)
            obj_.original_tagname_ = 'openstack_volume_authentication_key'
        super(OpenstackVolumeAuthenticationKeys, self).buildChildren(child_, node, nodeName_, True)
# end class OpenstackVolumeAuthenticationKeys


class OpenStackNetworkProvider(OpenStackProvider):
    subclass = None
    superclass = OpenStackProvider
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, url=None, requires_authentication=None, username=None, password=None, authentication_url=None, properties=None, tenant_name=None, plugin_type=None, agent_configuration=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackNetworkProvider, self).__init__(actions, href, id, name, description, comment, creation_status, link, url, requires_authentication, username, password, authentication_url, properties, tenant_name,  **kwargs_)
        self.plugin_type = plugin_type
        self.agent_configuration = agent_configuration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackNetworkProvider)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackNetworkProvider.subclass:
            return OpenStackNetworkProvider.subclass(*args_, **kwargs_)
        else:
            return OpenStackNetworkProvider(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_plugin_type(self):
        return self.plugin_type
    def set_plugin_type(self, plugin_type):
        self.plugin_type = plugin_type
    plugin_typeProp = property(get_plugin_type, set_plugin_type)
    def get_agent_configuration(self):
        return self.agent_configuration
    def set_agent_configuration(self, agent_configuration):
        self.agent_configuration = agent_configuration
    agent_configurationProp = property(get_agent_configuration, set_agent_configuration)
    def hasContent_(self):
        if (
            self.plugin_type is not None or
            self.agent_configuration is not None or
            super(OpenStackNetworkProvider, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_network_provider', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_network_provider')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_network_provider')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_network_provider', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_network_provider'):
        super(OpenStackNetworkProvider, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_network_provider')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_network_provider', fromsubclass_=False, pretty_print=True):
        super(OpenStackNetworkProvider, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.plugin_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splugin_type>%s</%splugin_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.plugin_type), input_name='plugin_type')), namespaceprefix_ , eol_))
        if self.agent_configuration is not None:
            self.agent_configuration.export(outfile, level, namespaceprefix_, name_='agent_configuration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackNetworkProvider, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'plugin_type':
            plugin_type_ = child_.text
            plugin_type_ = self.gds_validate_string(plugin_type_, node, 'plugin_type')
            self.plugin_type = plugin_type_
        elif nodeName_ == 'agent_configuration':
            obj_ = AgentConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.agent_configuration = obj_
            obj_.original_tagname_ = 'agent_configuration'
        super(OpenStackNetworkProvider, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackNetworkProvider


class AgentConfiguration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, network_mappings=None, broker_type=None, address=None, port=None, username=None, password=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.network_mappings = network_mappings
        self.broker_type = broker_type
        self.address = address
        self.port = port
        self.username = username
        self.password = password
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AgentConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AgentConfiguration.subclass:
            return AgentConfiguration.subclass(*args_, **kwargs_)
        else:
            return AgentConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_network_mappings(self):
        return self.network_mappings
    def set_network_mappings(self, network_mappings):
        self.network_mappings = network_mappings
    network_mappingsProp = property(get_network_mappings, set_network_mappings)
    def get_broker_type(self):
        return self.broker_type
    def set_broker_type(self, broker_type):
        self.broker_type = broker_type
    broker_typeProp = property(get_broker_type, set_broker_type)
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    addressProp = property(get_address, set_address)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    portProp = property(get_port, set_port)
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    usernameProp = property(get_username, set_username)
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    passwordProp = property(get_password, set_password)
    def hasContent_(self):
        if (
            self.network_mappings is not None or
            self.broker_type is not None or
            self.address is not None or
            self.port is not None or
            self.username is not None or
            self.password is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='agent_configuration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('agent_configuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='agent_configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='agent_configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='agent_configuration'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='agent_configuration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.network_mappings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snetwork_mappings>%s</%snetwork_mappings>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.network_mappings), input_name='network_mappings')), namespaceprefix_ , eol_))
        if self.broker_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbroker_type>%s</%sbroker_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.broker_type), input_name='broker_type')), namespaceprefix_ , eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespaceprefix_ , self.gds_format_integer(self.port, input_name='port'), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spassword>%s</%spassword>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.password), input_name='password')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'network_mappings':
            network_mappings_ = child_.text
            network_mappings_ = self.gds_validate_string(network_mappings_, node, 'network_mappings')
            self.network_mappings = network_mappings_
        elif nodeName_ == 'broker_type':
            broker_type_ = child_.text
            broker_type_ = self.gds_validate_string(broker_type_, node, 'broker_type')
            self.broker_type = broker_type_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'port' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'password':
            password_ = child_.text
            password_ = self.gds_validate_string(password_, node, 'password')
            self.password = password_
# end class AgentConfiguration


class OpenStackNetworkProviders(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_network_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackNetworkProviders, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_network_provider is None:
            self.openstack_network_provider = []
        else:
            self.openstack_network_provider = openstack_network_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackNetworkProviders)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackNetworkProviders.subclass:
            return OpenStackNetworkProviders.subclass(*args_, **kwargs_)
        else:
            return OpenStackNetworkProviders(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_network_provider(self):
        return self.openstack_network_provider
    def set_openstack_network_provider(self, openstack_network_provider):
        self.openstack_network_provider = openstack_network_provider
    def add_openstack_network_provider(self, value):
        self.openstack_network_provider.append(value)
    def insert_openstack_network_provider_at(self, index, value):
        self.openstack_network_provider.insert(index, value)
    def replace_openstack_network_provider_at(self, index, value):
        self.openstack_network_provider[index] = value
    openstack_network_providerProp = property(get_openstack_network_provider, set_openstack_network_provider)
    def hasContent_(self):
        if (
            self.openstack_network_provider or
            super(OpenStackNetworkProviders, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_network_providers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_network_providers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_network_providers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_network_providers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_network_providers'):
        super(OpenStackNetworkProviders, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_network_providers')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_network_providers', fromsubclass_=False, pretty_print=True):
        super(OpenStackNetworkProviders, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_network_provider_ in self.openstack_network_provider:
            openstack_network_provider_.export(outfile, level, namespaceprefix_, name_='openstack_network_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackNetworkProviders, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_network_provider':
            obj_ = OpenStackNetworkProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_network_provider.append(obj_)
            obj_.original_tagname_ = 'openstack_network_provider'
        super(OpenStackNetworkProviders, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackNetworkProviders


class OpenStackNetwork(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, openstack_network_provider=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackNetwork, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.openstack_network_provider = openstack_network_provider
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackNetwork.subclass:
            return OpenStackNetwork.subclass(*args_, **kwargs_)
        else:
            return OpenStackNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_network_provider(self):
        return self.openstack_network_provider
    def set_openstack_network_provider(self, openstack_network_provider):
        self.openstack_network_provider = openstack_network_provider
    openstack_network_providerProp = property(get_openstack_network_provider, set_openstack_network_provider)
    def hasContent_(self):
        if (
            self.openstack_network_provider is not None or
            super(OpenStackNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_network', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_network')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_network')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_network', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_network'):
        super(OpenStackNetwork, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_network')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_network', fromsubclass_=False, pretty_print=True):
        super(OpenStackNetwork, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.openstack_network_provider is not None:
            self.openstack_network_provider.export(outfile, level, namespaceprefix_, name_='openstack_network_provider', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_network_provider':
            obj_ = OpenStackNetworkProvider.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_network_provider = obj_
            obj_.original_tagname_ = 'openstack_network_provider'
        super(OpenStackNetwork, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackNetwork


class OpenStackNetworks(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_network=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackNetworks, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_network is None:
            self.openstack_network = []
        else:
            self.openstack_network = openstack_network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackNetworks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackNetworks.subclass:
            return OpenStackNetworks.subclass(*args_, **kwargs_)
        else:
            return OpenStackNetworks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_network(self):
        return self.openstack_network
    def set_openstack_network(self, openstack_network):
        self.openstack_network = openstack_network
    def add_openstack_network(self, value):
        self.openstack_network.append(value)
    def insert_openstack_network_at(self, index, value):
        self.openstack_network.insert(index, value)
    def replace_openstack_network_at(self, index, value):
        self.openstack_network[index] = value
    openstack_networkProp = property(get_openstack_network, set_openstack_network)
    def hasContent_(self):
        if (
            self.openstack_network or
            super(OpenStackNetworks, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_networks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_networks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_networks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_networks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_networks'):
        super(OpenStackNetworks, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_networks')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_networks', fromsubclass_=False, pretty_print=True):
        super(OpenStackNetworks, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_network_ in self.openstack_network:
            openstack_network_.export(outfile, level, namespaceprefix_, name_='openstack_network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackNetworks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_network':
            obj_ = OpenStackNetwork.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_network.append(obj_)
            obj_.original_tagname_ = 'openstack_network'
        super(OpenStackNetworks, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackNetworks


class DnsServers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dns_server=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if dns_server is None:
            self.dns_server = []
        else:
            self.dns_server = dns_server
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DnsServers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DnsServers.subclass:
            return DnsServers.subclass(*args_, **kwargs_)
        else:
            return DnsServers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dns_server(self):
        return self.dns_server
    def set_dns_server(self, dns_server):
        self.dns_server = dns_server
    def add_dns_server(self, value):
        self.dns_server.append(value)
    def insert_dns_server_at(self, index, value):
        self.dns_server.insert(index, value)
    def replace_dns_server_at(self, index, value):
        self.dns_server[index] = value
    dns_serverProp = property(get_dns_server, set_dns_server)
    def hasContent_(self):
        if (
            self.dns_server
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='dns_servers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dns_servers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dns_servers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='dns_servers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dns_servers'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='dns_servers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dns_server_ in self.dns_server:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns_server>%s</%sdns_server>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(dns_server_), input_name='dns_server')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dns_server':
            dns_server_ = child_.text
            dns_server_ = self.gds_validate_string(dns_server_, node, 'dns_server')
            self.dns_server.append(dns_server_)
# end class DnsServers


class OpenStackSubnet(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, cidr=None, ip_version=None, gateway=None, dns_servers=None, openstack_network=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackSubnet, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.cidr = cidr
        self.ip_version = ip_version
        self.gateway = gateway
        self.dns_servers = dns_servers
        self.openstack_network = openstack_network
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackSubnet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackSubnet.subclass:
            return OpenStackSubnet.subclass(*args_, **kwargs_)
        else:
            return OpenStackSubnet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cidr(self):
        return self.cidr
    def set_cidr(self, cidr):
        self.cidr = cidr
    cidrProp = property(get_cidr, set_cidr)
    def get_ip_version(self):
        return self.ip_version
    def set_ip_version(self, ip_version):
        self.ip_version = ip_version
    ip_versionProp = property(get_ip_version, set_ip_version)
    def get_gateway(self):
        return self.gateway
    def set_gateway(self, gateway):
        self.gateway = gateway
    gatewayProp = property(get_gateway, set_gateway)
    def get_dns_servers(self):
        return self.dns_servers
    def set_dns_servers(self, dns_servers):
        self.dns_servers = dns_servers
    dns_serversProp = property(get_dns_servers, set_dns_servers)
    def get_openstack_network(self):
        return self.openstack_network
    def set_openstack_network(self, openstack_network):
        self.openstack_network = openstack_network
    openstack_networkProp = property(get_openstack_network, set_openstack_network)
    def hasContent_(self):
        if (
            self.cidr is not None or
            self.ip_version is not None or
            self.gateway is not None or
            self.dns_servers is not None or
            self.openstack_network is not None or
            super(OpenStackSubnet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_subnet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_subnet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_subnet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_subnet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_subnet'):
        super(OpenStackSubnet, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_subnet')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_subnet', fromsubclass_=False, pretty_print=True):
        super(OpenStackSubnet, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cidr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scidr>%s</%scidr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cidr), input_name='cidr')), namespaceprefix_ , eol_))
        if self.ip_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip_version>%s</%sip_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ip_version), input_name='ip_version')), namespaceprefix_ , eol_))
        if self.gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgateway>%s</%sgateway>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.gateway), input_name='gateway')), namespaceprefix_ , eol_))
        if self.dns_servers is not None:
            self.dns_servers.export(outfile, level, namespaceprefix_, name_='dns_servers', pretty_print=pretty_print)
        if self.openstack_network is not None:
            self.openstack_network.export(outfile, level, namespaceprefix_, name_='openstack_network', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackSubnet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cidr':
            cidr_ = child_.text
            cidr_ = self.gds_validate_string(cidr_, node, 'cidr')
            self.cidr = cidr_
        elif nodeName_ == 'ip_version':
            ip_version_ = child_.text
            ip_version_ = self.gds_validate_string(ip_version_, node, 'ip_version')
            self.ip_version = ip_version_
        elif nodeName_ == 'gateway':
            gateway_ = child_.text
            gateway_ = self.gds_validate_string(gateway_, node, 'gateway')
            self.gateway = gateway_
        elif nodeName_ == 'dns_servers':
            obj_ = DnsServers.factory(parent_object_=self)
            obj_.build(child_)
            self.dns_servers = obj_
            obj_.original_tagname_ = 'dns_servers'
        elif nodeName_ == 'openstack_network':
            obj_ = OpenStackNetwork.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_network = obj_
            obj_.original_tagname_ = 'openstack_network'
        super(OpenStackSubnet, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackSubnet


class OpenStackSubnets(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, openstack_subnet=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OpenStackSubnets, self).__init__(actions, size, total, active,  **kwargs_)
        if openstack_subnet is None:
            self.openstack_subnet = []
        else:
            self.openstack_subnet = openstack_subnet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OpenStackSubnets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OpenStackSubnets.subclass:
            return OpenStackSubnets.subclass(*args_, **kwargs_)
        else:
            return OpenStackSubnets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_openstack_subnet(self):
        return self.openstack_subnet
    def set_openstack_subnet(self, openstack_subnet):
        self.openstack_subnet = openstack_subnet
    def add_openstack_subnet(self, value):
        self.openstack_subnet.append(value)
    def insert_openstack_subnet_at(self, index, value):
        self.openstack_subnet.insert(index, value)
    def replace_openstack_subnet_at(self, index, value):
        self.openstack_subnet[index] = value
    openstack_subnetProp = property(get_openstack_subnet, set_openstack_subnet)
    def hasContent_(self):
        if (
            self.openstack_subnet or
            super(OpenStackSubnets, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='openstack_subnets', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('openstack_subnets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_subnets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='openstack_subnets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='openstack_subnets'):
        super(OpenStackSubnets, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='openstack_subnets')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='openstack_subnets', fromsubclass_=False, pretty_print=True):
        super(OpenStackSubnets, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for openstack_subnet_ in self.openstack_subnet:
            openstack_subnet_.export(outfile, level, namespaceprefix_, name_='openstack_subnet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OpenStackSubnets, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'openstack_subnet':
            obj_ = OpenStackSubnet.factory(parent_object_=self)
            obj_.build(child_)
            self.openstack_subnet.append(obj_)
            obj_.original_tagname_ = 'openstack_subnet'
        super(OpenStackSubnets, self).buildChildren(child_, node, nodeName_, True)
# end class OpenStackSubnets


class KatelloErratum(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, title=None, type_=None, issued=None, severity=None, solution=None, summary=None, packages=None, host=None, vm=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(KatelloErratum, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.title = title
        self.type_ = type_
        if isinstance(issued, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(issued, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = issued
        self.issued = initvalue_
        self.severity = severity
        self.solution = solution
        self.summary = summary
        self.packages = packages
        self.host = host
        self.vm = vm
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KatelloErratum)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KatelloErratum.subclass:
            return KatelloErratum.subclass(*args_, **kwargs_)
        else:
            return KatelloErratum(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    titleProp = property(get_title, set_title)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_issued(self):
        return self.issued
    def set_issued(self, issued):
        self.issued = issued
    issuedProp = property(get_issued, set_issued)
    def get_severity(self):
        return self.severity
    def set_severity(self, severity):
        self.severity = severity
    severityProp = property(get_severity, set_severity)
    def get_solution(self):
        return self.solution
    def set_solution(self, solution):
        self.solution = solution
    solutionProp = property(get_solution, set_solution)
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    summaryProp = property(get_summary, set_summary)
    def get_packages(self):
        return self.packages
    def set_packages(self, packages):
        self.packages = packages
    packagesProp = property(get_packages, set_packages)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def hasContent_(self):
        if (
            self.title is not None or
            self.type_ is not None or
            self.issued is not None or
            self.severity is not None or
            self.solution is not None or
            self.summary is not None or
            self.packages is not None or
            self.host is not None or
            self.vm is not None or
            super(KatelloErratum, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='katello_erratum', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('katello_erratum')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='katello_erratum')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='katello_erratum', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='katello_erratum'):
        super(KatelloErratum, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='katello_erratum')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='katello_erratum', fromsubclass_=False, pretty_print=True):
        super(KatelloErratum, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.title), input_name='title')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.issued is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sissued>%s</%sissued>%s' % (namespaceprefix_ , self.gds_format_datetime(self.issued, input_name='issued'), namespaceprefix_ , eol_))
        if self.severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseverity>%s</%sseverity>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.severity), input_name='severity')), namespaceprefix_ , eol_))
        if self.solution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssolution>%s</%ssolution>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.solution), input_name='solution')), namespaceprefix_ , eol_))
        if self.summary is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssummary>%s</%ssummary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.summary), input_name='summary')), namespaceprefix_ , eol_))
        if self.packages is not None:
            self.packages.export(outfile, level, namespaceprefix_, name_='packages', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(KatelloErratum, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
        elif nodeName_ == 'issued':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.issued = dval_
        elif nodeName_ == 'severity':
            severity_ = child_.text
            severity_ = self.gds_validate_string(severity_, node, 'severity')
            self.severity = severity_
        elif nodeName_ == 'solution':
            solution_ = child_.text
            solution_ = self.gds_validate_string(solution_, node, 'solution')
            self.solution = solution_
        elif nodeName_ == 'summary':
            summary_ = child_.text
            summary_ = self.gds_validate_string(summary_, node, 'summary')
            self.summary = summary_
        elif nodeName_ == 'packages':
            obj_ = Packages.factory(parent_object_=self)
            obj_.build(child_)
            self.packages = obj_
            obj_.original_tagname_ = 'packages'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        super(KatelloErratum, self).buildChildren(child_, node, nodeName_, True)
# end class KatelloErratum


class KatelloErrata(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, katello_erratum=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(KatelloErrata, self).__init__(actions, size, total, active,  **kwargs_)
        if katello_erratum is None:
            self.katello_erratum = []
        else:
            self.katello_erratum = katello_erratum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KatelloErrata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KatelloErrata.subclass:
            return KatelloErrata.subclass(*args_, **kwargs_)
        else:
            return KatelloErrata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_katello_erratum(self):
        return self.katello_erratum
    def set_katello_erratum(self, katello_erratum):
        self.katello_erratum = katello_erratum
    def add_katello_erratum(self, value):
        self.katello_erratum.append(value)
    def insert_katello_erratum_at(self, index, value):
        self.katello_erratum.insert(index, value)
    def replace_katello_erratum_at(self, index, value):
        self.katello_erratum[index] = value
    katello_erratumProp = property(get_katello_erratum, set_katello_erratum)
    def hasContent_(self):
        if (
            self.katello_erratum or
            super(KatelloErrata, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='katello_errata', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('katello_errata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='katello_errata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='katello_errata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='katello_errata'):
        super(KatelloErrata, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='katello_errata')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='katello_errata', fromsubclass_=False, pretty_print=True):
        super(KatelloErrata, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for katello_erratum_ in self.katello_erratum:
            katello_erratum_.export(outfile, level, namespaceprefix_, name_='katello_erratum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(KatelloErrata, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'katello_erratum':
            obj_ = KatelloErratum.factory(parent_object_=self)
            obj_.build(child_)
            self.katello_erratum.append(obj_)
            obj_.original_tagname_ = 'katello_erratum'
        super(KatelloErrata, self).buildChildren(child_, node, nodeName_, True)
# end class KatelloErrata


class Packages(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, package=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if package is None:
            self.package = []
        else:
            self.package = package
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Packages)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Packages.subclass:
            return Packages.subclass(*args_, **kwargs_)
        else:
            return Packages(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_package(self):
        return self.package
    def set_package(self, package):
        self.package = package
    def add_package(self, value):
        self.package.append(value)
    def insert_package_at(self, index, value):
        self.package.insert(index, value)
    def replace_package_at(self, index, value):
        self.package[index] = value
    packageProp = property(get_package, set_package)
    def hasContent_(self):
        if (
            self.package
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='packages', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('packages')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='packages')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='packages', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='packages'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='packages', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for package_ in self.package:
            package_.export(outfile, level, namespaceprefix_, name_='package', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'package':
            obj_ = Package.factory(parent_object_=self)
            obj_.build(child_)
            self.package.append(obj_)
            obj_.original_tagname_ = 'package'
# end class Packages


class Package(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Package)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Package.subclass:
            return Package.subclass(*args_, **kwargs_)
        else:
            return Package(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='package', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('package')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='package')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='package', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='package'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='package', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
# end class Package


class BrickProfileDetail(EntityProfileDetail):
    subclass = None
    superclass = EntityProfileDetail
    def __init__(self, profile_detail=None, brick=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BrickProfileDetail, self).__init__(profile_detail,  **kwargs_)
        self.brick = brick
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BrickProfileDetail)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BrickProfileDetail.subclass:
            return BrickProfileDetail.subclass(*args_, **kwargs_)
        else:
            return BrickProfileDetail(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_brick(self):
        return self.brick
    def set_brick(self, brick):
        self.brick = brick
    brickProp = property(get_brick, set_brick)
    def hasContent_(self):
        if (
            self.brick is not None or
            super(BrickProfileDetail, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='brick_profile_detail', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('brick_profile_detail')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_profile_detail')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='brick_profile_detail', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='brick_profile_detail'):
        super(BrickProfileDetail, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='brick_profile_detail')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='brick_profile_detail', fromsubclass_=False, pretty_print=True):
        super(BrickProfileDetail, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.brick is not None:
            self.brick.export(outfile, level, namespaceprefix_, name_='brick', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BrickProfileDetail, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'brick':
            obj_ = GlusterBrick.factory(parent_object_=self)
            obj_.build(child_)
            self.brick = obj_
            obj_.original_tagname_ = 'brick'
        super(BrickProfileDetail, self).buildChildren(child_, node, nodeName_, True)
# end class BrickProfileDetail


class Template(VmBase):
    subclass = None
    superclass = VmBase
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, status=None, memory=None, cpu=None, cpu_shares=None, bios=None, os=None, cluster=None, storage_domain=None, creation_time=None, origin=None, stateless=None, delete_protected=None, high_availability=None, display=None, sso=None, rng_device=None, console=None, timezone=None, domain=None, usb=None, soundcard_enabled=None, tunnel_migration=None, migration_downtime=None, virtio_scsi=None, serial_number=None, start_paused=None, cpu_profile=None, migration=None, io=None, custom_properties=None, custom_emulated_machine=None, custom_cpu_model=None, time_zone=None, small_icon=None, large_icon=None, memory_policy=None, vm=None, version=None, permissions=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Template, self).__init__(actions, href, id, name, description, comment, creation_status, link, type_, status, memory, cpu, cpu_shares, bios, os, cluster, storage_domain, creation_time, origin, stateless, delete_protected, high_availability, display, sso, rng_device, console, timezone, domain, usb, soundcard_enabled, tunnel_migration, migration_downtime, virtio_scsi, serial_number, start_paused, cpu_profile, migration, io, custom_properties, custom_emulated_machine, custom_cpu_model, time_zone, small_icon, large_icon, memory_policy, extensiontype_,  **kwargs_)
        self.vm = vm
        self.version = version
        self.permissions = permissions
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Template)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Template.subclass:
            return Template.subclass(*args_, **kwargs_)
        else:
            return Template(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_permissions(self):
        return self.permissions
    def set_permissions(self, permissions):
        self.permissions = permissions
    permissionsProp = property(get_permissions, set_permissions)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.vm is not None or
            self.version is not None or
            self.permissions is not None or
            super(Template, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='template', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('template')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='template')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='template', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='template'):
        super(Template, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='template')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='template', fromsubclass_=False, pretty_print=True):
        super(Template, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.permissions is not None:
            self.permissions.export(outfile, level, namespaceprefix_, name_='permissions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Template, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'permissions':
            obj_ = Permissions.factory(parent_object_=self)
            obj_.build(child_)
            self.permissions = obj_
            obj_.original_tagname_ = 'permissions'
        super(Template, self).buildChildren(child_, node, nodeName_, True)
# end class Template


class InstanceType(Template):
    subclass = None
    superclass = Template
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, type_=None, status=None, memory=None, cpu=None, cpu_shares=None, bios=None, os=None, cluster=None, storage_domain=None, creation_time=None, origin=None, stateless=None, delete_protected=None, high_availability=None, display=None, sso=None, rng_device=None, console=None, timezone=None, domain=None, usb=None, soundcard_enabled=None, tunnel_migration=None, migration_downtime=None, virtio_scsi=None, serial_number=None, start_paused=None, cpu_profile=None, migration=None, io=None, custom_properties=None, custom_emulated_machine=None, custom_cpu_model=None, time_zone=None, small_icon=None, large_icon=None, memory_policy=None, vm=None, version=None, permissions=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(InstanceType, self).__init__(actions, href, id, name, description, comment, creation_status, link, type_, status, memory, cpu, cpu_shares, bios, os, cluster, storage_domain, creation_time, origin, stateless, delete_protected, high_availability, display, sso, rng_device, console, timezone, domain, usb, soundcard_enabled, tunnel_migration, migration_downtime, virtio_scsi, serial_number, start_paused, cpu_profile, migration, io, custom_properties, custom_emulated_machine, custom_cpu_model, time_zone, small_icon, large_icon, memory_policy, vm, version, permissions,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceType.subclass:
            return InstanceType.subclass(*args_, **kwargs_)
        else:
            return InstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(InstanceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='instance_type', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instance_type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instance_type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='instance_type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instance_type'):
        super(InstanceType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instance_type')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='instance_type', fromsubclass_=False, pretty_print=True):
        super(InstanceType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstanceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstanceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstanceType


class WatchDog(BaseDevice):
    subclass = None
    superclass = BaseDevice
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, template=None, instance_type=None, vms=None, vm=None, model=None, action=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WatchDog, self).__init__(actions, href, id, name, description, comment, creation_status, link, template, instance_type, vms, vm,  **kwargs_)
        self.model = model
        self.action = action
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WatchDog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WatchDog.subclass:
            return WatchDog.subclass(*args_, **kwargs_)
        else:
            return WatchDog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    modelProp = property(get_model, set_model)
    def get_action(self):
        return self.action
    def set_action(self, action):
        self.action = action
    actionProp = property(get_action, set_action)
    def hasContent_(self):
        if (
            self.model is not None or
            self.action is not None or
            super(WatchDog, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='watchdog', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('watchdog')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='watchdog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='watchdog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='watchdog'):
        super(WatchDog, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='watchdog')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='watchdog', fromsubclass_=False, pretty_print=True):
        super(WatchDog, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.model is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodel>%s</%smodel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.model), input_name='model')), namespaceprefix_ , eol_))
        if self.action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.action), input_name='action')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WatchDog, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'model':
            model_ = child_.text
            model_ = self.gds_validate_string(model_, node, 'model')
            self.model = model_
        elif nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action = action_
        super(WatchDog, self).buildChildren(child_, node, nodeName_, True)
# end class WatchDog


class WatchDogs(BaseDevices):
    subclass = None
    superclass = BaseDevices
    def __init__(self, actions=None, size=None, total=None, active=None, watchdog=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WatchDogs, self).__init__(actions, size, total, active,  **kwargs_)
        if watchdog is None:
            self.watchdog = []
        else:
            self.watchdog = watchdog
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WatchDogs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WatchDogs.subclass:
            return WatchDogs.subclass(*args_, **kwargs_)
        else:
            return WatchDogs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_watchdog(self):
        return self.watchdog
    def set_watchdog(self, watchdog):
        self.watchdog = watchdog
    def add_watchdog(self, value):
        self.watchdog.append(value)
    def insert_watchdog_at(self, index, value):
        self.watchdog.insert(index, value)
    def replace_watchdog_at(self, index, value):
        self.watchdog[index] = value
    watchdogProp = property(get_watchdog, set_watchdog)
    def hasContent_(self):
        if (
            self.watchdog or
            super(WatchDogs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='watchdogs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('watchdogs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='watchdogs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='watchdogs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='watchdogs'):
        super(WatchDogs, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='watchdogs')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='watchdogs', fromsubclass_=False, pretty_print=True):
        super(WatchDogs, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for watchdog_ in self.watchdog:
            watchdog_.export(outfile, level, namespaceprefix_, name_='watchdog', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WatchDogs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'watchdog':
            obj_ = WatchDog.factory(parent_object_=self)
            obj_.build(child_)
            self.watchdog.append(obj_)
            obj_.original_tagname_ = 'watchdog'
        super(WatchDogs, self).buildChildren(child_, node, nodeName_, True)
# end class WatchDogs


class Feature(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, transparent_hugepages=None, gluster_volumes=None, vm_device_types=None, storage_types=None, storage_domain=None, nic=None, api=None, host=None, url=None, headers=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Feature, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.transparent_hugepages = transparent_hugepages
        self.gluster_volumes = gluster_volumes
        self.vm_device_types = vm_device_types
        self.storage_types = storage_types
        self.storage_domain = storage_domain
        self.nic = nic
        self.api = api
        self.host = host
        self.url = url
        self.headers = headers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Feature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Feature.subclass:
            return Feature.subclass(*args_, **kwargs_)
        else:
            return Feature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transparent_hugepages(self):
        return self.transparent_hugepages
    def set_transparent_hugepages(self, transparent_hugepages):
        self.transparent_hugepages = transparent_hugepages
    transparent_hugepagesProp = property(get_transparent_hugepages, set_transparent_hugepages)
    def get_gluster_volumes(self):
        return self.gluster_volumes
    def set_gluster_volumes(self, gluster_volumes):
        self.gluster_volumes = gluster_volumes
    gluster_volumesProp = property(get_gluster_volumes, set_gluster_volumes)
    def get_vm_device_types(self):
        return self.vm_device_types
    def set_vm_device_types(self, vm_device_types):
        self.vm_device_types = vm_device_types
    vm_device_typesProp = property(get_vm_device_types, set_vm_device_types)
    def get_storage_types(self):
        return self.storage_types
    def set_storage_types(self, storage_types):
        self.storage_types = storage_types
    storage_typesProp = property(get_storage_types, set_storage_types)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_nic(self):
        return self.nic
    def set_nic(self, nic):
        self.nic = nic
    nicProp = property(get_nic, set_nic)
    def get_api(self):
        return self.api
    def set_api(self, api):
        self.api = api
    apiProp = property(get_api, set_api)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    urlProp = property(get_url, set_url)
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    headersProp = property(get_headers, set_headers)
    def hasContent_(self):
        if (
            self.transparent_hugepages is not None or
            self.gluster_volumes is not None or
            self.vm_device_types is not None or
            self.storage_types is not None or
            self.storage_domain is not None or
            self.nic is not None or
            self.api is not None or
            self.host is not None or
            self.url is not None or
            self.headers is not None or
            super(Feature, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='feature', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('feature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='feature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='feature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='feature'):
        super(Feature, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='feature')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='feature', fromsubclass_=False, pretty_print=True):
        super(Feature, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transparent_hugepages is not None:
            self.transparent_hugepages.export(outfile, level, namespaceprefix_, name_='transparent_hugepages', pretty_print=pretty_print)
        if self.gluster_volumes is not None:
            self.gluster_volumes.export(outfile, level, namespaceprefix_, name_='gluster_volumes', pretty_print=pretty_print)
        if self.vm_device_types is not None:
            self.vm_device_types.export(outfile, level, namespaceprefix_, name_='vm_device_types', pretty_print=pretty_print)
        if self.storage_types is not None:
            self.storage_types.export(outfile, level, namespaceprefix_, name_='storage_types', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.nic is not None:
            self.nic.export(outfile, level, namespaceprefix_, name_='nic', pretty_print=pretty_print)
        if self.api is not None:
            self.api.export(outfile, level, namespaceprefix_, name_='api', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.url is not None:
            self.url.export(outfile, level, namespaceprefix_, name_='url', pretty_print=pretty_print)
        if self.headers is not None:
            self.headers.export(outfile, level, namespaceprefix_, name_='headers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Feature, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transparent_hugepages':
            obj_ = TransparentHugePages.factory(parent_object_=self)
            obj_.build(child_)
            self.transparent_hugepages = obj_
            obj_.original_tagname_ = 'transparent_hugepages'
        elif nodeName_ == 'gluster_volumes':
            obj_ = GlusterVolumes.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_volumes = obj_
            obj_.original_tagname_ = 'gluster_volumes'
        elif nodeName_ == 'vm_device_types':
            obj_ = VmDeviceTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_device_types = obj_
            obj_.original_tagname_ = 'vm_device_types'
        elif nodeName_ == 'storage_types':
            obj_ = StorageTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_types = obj_
            obj_.original_tagname_ = 'storage_types'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'nic':
            obj_ = NIC.factory(parent_object_=self)
            obj_.build(child_)
            self.nic = obj_
            obj_.original_tagname_ = 'nic'
        elif nodeName_ == 'api':
            obj_ = API.factory(parent_object_=self)
            obj_.build(child_)
            self.api = obj_
            obj_.original_tagname_ = 'api'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'headers':
            obj_ = Headers.factory(parent_object_=self)
            obj_.build(child_)
            self.headers = obj_
            obj_.original_tagname_ = 'headers'
        super(Feature, self).buildChildren(child_, node, nodeName_, True)
# end class Feature


class SchedulingPolicies(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, scheduling_policy=None, policy=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SchedulingPolicies, self).__init__(actions, size, total, active,  **kwargs_)
        if scheduling_policy is None:
            self.scheduling_policy = []
        else:
            self.scheduling_policy = scheduling_policy
        if policy is None:
            self.policy = []
        else:
            self.policy = policy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulingPolicies)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulingPolicies.subclass:
            return SchedulingPolicies.subclass(*args_, **kwargs_)
        else:
            return SchedulingPolicies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scheduling_policy(self):
        return self.scheduling_policy
    def set_scheduling_policy(self, scheduling_policy):
        self.scheduling_policy = scheduling_policy
    def add_scheduling_policy(self, value):
        self.scheduling_policy.append(value)
    def insert_scheduling_policy_at(self, index, value):
        self.scheduling_policy.insert(index, value)
    def replace_scheduling_policy_at(self, index, value):
        self.scheduling_policy[index] = value
    scheduling_policyProp = property(get_scheduling_policy, set_scheduling_policy)
    def get_policy(self):
        return self.policy
    def set_policy(self, policy):
        self.policy = policy
    def add_policy(self, value):
        self.policy.append(value)
    def insert_policy_at(self, index, value):
        self.policy.insert(index, value)
    def replace_policy_at(self, index, value):
        self.policy[index] = value
    policyProp = property(get_policy, set_policy)
    def hasContent_(self):
        if (
            self.scheduling_policy or
            self.policy or
            super(SchedulingPolicies, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='scheduling_policies', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('scheduling_policies')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policies')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='scheduling_policies', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='scheduling_policies'):
        super(SchedulingPolicies, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='scheduling_policies')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='scheduling_policies', fromsubclass_=False, pretty_print=True):
        super(SchedulingPolicies, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for scheduling_policy_ in self.scheduling_policy:
            scheduling_policy_.export(outfile, level, namespaceprefix_, name_='scheduling_policy', pretty_print=pretty_print)
        for policy_ in self.policy:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spolicy>%s</%spolicy>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(policy_), input_name='policy')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SchedulingPolicies, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scheduling_policy':
            obj_ = SchedulingPolicy.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy.append(obj_)
            obj_.original_tagname_ = 'scheduling_policy'
        elif nodeName_ == 'policy':
            policy_ = child_.text
            policy_ = self.gds_validate_string(policy_, node, 'policy')
            self.policy.append(policy_)
        super(SchedulingPolicies, self).buildChildren(child_, node, nodeName_, True)
# end class SchedulingPolicies


class Capabilities(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, version=None, permits=None, scheduling_policies=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Capabilities, self).__init__(actions, size, total, active,  **kwargs_)
        if version is None:
            self.version = []
        else:
            self.version = version
        self.permits = permits
        self.scheduling_policies = scheduling_policies
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Capabilities)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Capabilities.subclass:
            return Capabilities.subclass(*args_, **kwargs_)
        else:
            return Capabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def add_version(self, value):
        self.version.append(value)
    def insert_version_at(self, index, value):
        self.version.insert(index, value)
    def replace_version_at(self, index, value):
        self.version[index] = value
    versionProp = property(get_version, set_version)
    def get_permits(self):
        return self.permits
    def set_permits(self, permits):
        self.permits = permits
    permitsProp = property(get_permits, set_permits)
    def get_scheduling_policies(self):
        return self.scheduling_policies
    def set_scheduling_policies(self, scheduling_policies):
        self.scheduling_policies = scheduling_policies
    scheduling_policiesProp = property(get_scheduling_policies, set_scheduling_policies)
    def hasContent_(self):
        if (
            self.version or
            self.permits is not None or
            self.scheduling_policies is not None or
            super(Capabilities, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='capabilities', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('capabilities')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='capabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='capabilities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='capabilities'):
        super(Capabilities, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='capabilities')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='capabilities', fromsubclass_=False, pretty_print=True):
        super(Capabilities, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for version_ in self.version:
            version_.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.permits is not None:
            self.permits.export(outfile, level, namespaceprefix_, name_='permits', pretty_print=pretty_print)
        if self.scheduling_policies is not None:
            self.scheduling_policies.export(outfile, level, namespaceprefix_, name_='scheduling_policies', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Capabilities, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version.append(obj_)
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'permits':
            obj_ = Permits.factory(parent_object_=self)
            obj_.build(child_)
            self.permits = obj_
            obj_.original_tagname_ = 'permits'
        elif nodeName_ == 'scheduling_policies':
            obj_ = SchedulingPolicies.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policies = obj_
            obj_.original_tagname_ = 'scheduling_policies'
        super(Capabilities, self).buildChildren(child_, node, nodeName_, True)
# end class Capabilities


class ProductInfo(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, vendor=None, version=None, full_version=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ProductInfo, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.vendor = vendor
        self.version = version
        self.full_version = full_version
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProductInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProductInfo.subclass:
            return ProductInfo.subclass(*args_, **kwargs_)
        else:
            return ProductInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    vendorProp = property(get_vendor, set_vendor)
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    versionProp = property(get_version, set_version)
    def get_full_version(self):
        return self.full_version
    def set_full_version(self, full_version):
        self.full_version = full_version
    full_versionProp = property(get_full_version, set_full_version)
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.version is not None or
            self.full_version is not None or
            super(ProductInfo, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='product_info', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('product_info')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='product_info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='product_info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='product_info'):
        super(ProductInfo, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='product_info')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='product_info', fromsubclass_=False, pretty_print=True):
        super(ProductInfo, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespaceprefix_, name_='version', pretty_print=pretty_print)
        if self.full_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfull_version>%s</%sfull_version>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.full_version), input_name='full_version')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProductInfo, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'version':
            obj_ = VersionCaps.factory(parent_object_=self)
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        elif nodeName_ == 'full_version':
            full_version_ = child_.text
            full_version_ = self.gds_validate_string(full_version_, node, 'full_version')
            self.full_version = full_version_
        super(ProductInfo, self).buildChildren(child_, node, nodeName_, True)
# end class ProductInfo


class Version(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, major=None, minor=None, build_=None, revision=None, full_version=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Version, self).__init__(actions, href, id, name, description, comment, creation_status, link, extensiontype_,  **kwargs_)
        self.major = _cast(int, major)
        self.minor = _cast(int, minor)
        self.build_ = _cast(int, build_)
        self.revision = _cast(int, revision)
        self.full_version = _cast(None, full_version)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Version)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Version.subclass:
            return Version.subclass(*args_, **kwargs_)
        else:
            return Version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_major(self):
        return self.major
    def set_major(self, major):
        self.major = major
    majorProp = property(get_major, set_major)
    def get_minor(self):
        return self.minor
    def set_minor(self, minor):
        self.minor = minor
    minorProp = property(get_minor, set_minor)
    def get_build(self):
        return self.build_
    def set_build(self, build_):
        self.build_ = build_
    buildProp = property(get_build, set_build)
    def get_revision(self):
        return self.revision
    def set_revision(self, revision):
        self.revision = revision
    revisionProp = property(get_revision, set_revision)
    def get_full_version(self):
        return self.full_version
    def set_full_version(self, full_version):
        self.full_version = full_version
    full_versionProp = property(get_full_version, set_full_version)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Version, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='system_version', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('system_version')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='system_version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='system_version', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='system_version'):
        super(Version, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='system_version')
        if self.major is not None and 'major' not in already_processed:
            already_processed.add('major')
            outfile.write(' major="%s"' % self.gds_format_integer(self.major, input_name='major'))
        if self.minor is not None and 'minor' not in already_processed:
            already_processed.add('minor')
            outfile.write(' minor="%s"' % self.gds_format_integer(self.minor, input_name='minor'))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build="%s"' % self.gds_format_integer(self.build_, input_name='build'))
        if self.revision is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            outfile.write(' revision="%s"' % self.gds_format_integer(self.revision, input_name='revision'))
        if self.full_version is not None and 'full_version' not in already_processed:
            already_processed.add('full_version')
            outfile.write(' full_version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.full_version), input_name='full_version')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='system_version', fromsubclass_=False, pretty_print=True):
        super(Version, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('major', node)
        if value is not None and 'major' not in already_processed:
            already_processed.add('major')
            try:
                self.major = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minor', node)
        if value is not None and 'minor' not in already_processed:
            already_processed.add('minor')
            try:
                self.minor = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            try:
                self.build_ = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('revision', node)
        if value is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            try:
                self.revision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('full_version', node)
        if value is not None and 'full_version' not in already_processed:
            already_processed.add('full_version')
            self.full_version = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Version, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Version, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Version


class Statistics(BaseResources):
    subclass = None
    superclass = BaseResources
    def __init__(self, actions=None, size=None, total=None, active=None, statistic=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Statistics, self).__init__(actions, size, total, active,  **kwargs_)
        if statistic is None:
            self.statistic = []
        else:
            self.statistic = statistic
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Statistics)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Statistics.subclass:
            return Statistics.subclass(*args_, **kwargs_)
        else:
            return Statistics(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statistic(self):
        return self.statistic
    def set_statistic(self, statistic):
        self.statistic = statistic
    def add_statistic(self, value):
        self.statistic.append(value)
    def insert_statistic_at(self, index, value):
        self.statistic.insert(index, value)
    def replace_statistic_at(self, index, value):
        self.statistic[index] = value
    statisticProp = property(get_statistic, set_statistic)
    def hasContent_(self):
        if (
            self.statistic or
            super(Statistics, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='statistics', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('statistics')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='statistics')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='statistics', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='statistics'):
        super(Statistics, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='statistics')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='statistics', fromsubclass_=False, pretty_print=True):
        super(Statistics, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for statistic_ in self.statistic:
            statistic_.export(outfile, level, namespaceprefix_, name_='statistic', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Statistics, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'statistic':
            obj_ = Statistic.factory(parent_object_=self)
            obj_.build(child_)
            self.statistic.append(obj_)
            obj_.original_tagname_ = 'statistic'
        super(Statistics, self).buildChildren(child_, node, nodeName_, True)
# end class Statistics


class Statistic(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, values=None, type_=None, unit=None, disk=None, host=None, host_nic=None, host_numa_node=None, nic=None, vm=None, brick=None, step=None, gluster_volume=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Statistic, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.values = values
        self.type_ = type_
        self.validate_StatisticType(self.type_)
        self.unit = unit
        self.validate_StatisticUnit(self.unit)
        self.disk = disk
        self.host = host
        self.host_nic = host_nic
        self.host_numa_node = host_numa_node
        self.nic = nic
        self.vm = vm
        self.brick = brick
        self.step = step
        self.gluster_volume = gluster_volume
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Statistic)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Statistic.subclass:
            return Statistic.subclass(*args_, **kwargs_)
        else:
            return Statistic(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_values(self):
        return self.values
    def set_values(self, values):
        self.values = values
    valuesProp = property(get_values, set_values)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    typeProp = property(get_type, set_type)
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    unitProp = property(get_unit, set_unit)
    def get_disk(self):
        return self.disk
    def set_disk(self, disk):
        self.disk = disk
    diskProp = property(get_disk, set_disk)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_host_nic(self):
        return self.host_nic
    def set_host_nic(self, host_nic):
        self.host_nic = host_nic
    host_nicProp = property(get_host_nic, set_host_nic)
    def get_host_numa_node(self):
        return self.host_numa_node
    def set_host_numa_node(self, host_numa_node):
        self.host_numa_node = host_numa_node
    host_numa_nodeProp = property(get_host_numa_node, set_host_numa_node)
    def get_nic(self):
        return self.nic
    def set_nic(self, nic):
        self.nic = nic
    nicProp = property(get_nic, set_nic)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_brick(self):
        return self.brick
    def set_brick(self, brick):
        self.brick = brick
    brickProp = property(get_brick, set_brick)
    def get_step(self):
        return self.step
    def set_step(self, step):
        self.step = step
    stepProp = property(get_step, set_step)
    def get_gluster_volume(self):
        return self.gluster_volume
    def set_gluster_volume(self, gluster_volume):
        self.gluster_volume = gluster_volume
    gluster_volumeProp = property(get_gluster_volume, set_gluster_volume)
    def validate_StatisticType(self, value):
        # Validate type StatisticType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GAUGE', 'COUNTER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StatisticType' % {"value" : value.encode("utf-8")} )
    def validate_StatisticUnit(self, value):
        # Validate type StatisticUnit, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['NONE', 'PERCENT', 'BYTES', 'SECONDS', 'BYTES_PER_SECOND', 'BITS_PER_SECOND', 'COUNT_PER_SECOND']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on StatisticUnit' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.values is not None or
            self.type_ is not None or
            self.unit is not None or
            self.disk is not None or
            self.host is not None or
            self.host_nic is not None or
            self.host_numa_node is not None or
            self.nic is not None or
            self.vm is not None or
            self.brick is not None or
            self.step is not None or
            self.gluster_volume is not None or
            super(Statistic, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='statistic', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('statistic')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='statistic')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='statistic', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='statistic'):
        super(Statistic, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='statistic')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='statistic', fromsubclass_=False, pretty_print=True):
        super(Statistic, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.values is not None:
            self.values.export(outfile, level, namespaceprefix_, name_='values', pretty_print=pretty_print)
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.unit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunit>%s</%sunit>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.unit), input_name='unit')), namespaceprefix_ , eol_))
        if self.disk is not None:
            self.disk.export(outfile, level, namespaceprefix_, name_='disk', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.host_nic is not None:
            self.host_nic.export(outfile, level, namespaceprefix_, name_='host_nic', pretty_print=pretty_print)
        if self.host_numa_node is not None:
            self.host_numa_node.export(outfile, level, namespaceprefix_, name_='host_numa_node', pretty_print=pretty_print)
        if self.nic is not None:
            self.nic.export(outfile, level, namespaceprefix_, name_='nic', pretty_print=pretty_print)
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.brick is not None:
            self.brick.export(outfile, level, namespaceprefix_, name_='brick', pretty_print=pretty_print)
        if self.step is not None:
            self.step.export(outfile, level, namespaceprefix_, name_='step', pretty_print=pretty_print)
        if self.gluster_volume is not None:
            self.gluster_volume.export(outfile, level, namespaceprefix_, name_='gluster_volume', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Statistic, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'values':
            obj_ = Values.factory(parent_object_=self)
            obj_.build(child_)
            self.values = obj_
            obj_.original_tagname_ = 'values'
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type StatisticType
            self.validate_StatisticType(self.type_)
        elif nodeName_ == 'unit':
            unit_ = child_.text
            unit_ = self.gds_validate_string(unit_, node, 'unit')
            self.unit = unit_
            # validate type StatisticUnit
            self.validate_StatisticUnit(self.unit)
        elif nodeName_ == 'disk':
            class_obj_ = self.get_class_obj_(child_, Disk)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.disk = obj_
            obj_.original_tagname_ = 'disk'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'host_nic':
            obj_ = HostNIC.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic = obj_
            obj_.original_tagname_ = 'host_nic'
        elif nodeName_ == 'host_numa_node':
            class_obj_ = self.get_class_obj_(child_, NumaNode)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.host_numa_node = obj_
            obj_.original_tagname_ = 'host_numa_node'
        elif nodeName_ == 'nic':
            obj_ = NIC.factory(parent_object_=self)
            obj_.build(child_)
            self.nic = obj_
            obj_.original_tagname_ = 'nic'
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'brick':
            obj_ = GlusterBrick.factory(parent_object_=self)
            obj_.build(child_)
            self.brick = obj_
            obj_.original_tagname_ = 'brick'
        elif nodeName_ == 'step':
            obj_ = Step.factory(parent_object_=self)
            obj_.build(child_)
            self.step = obj_
            obj_.original_tagname_ = 'step'
        elif nodeName_ == 'gluster_volume':
            obj_ = GlusterVolume.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_volume = obj_
            obj_.original_tagname_ = 'gluster_volume'
        super(Statistic, self).buildChildren(child_, node, nodeName_, True)
# end class Statistic


class Creation(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, status=None, fault=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Creation, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.status = status
        self.fault = fault
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Creation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Creation.subclass:
            return Creation.subclass(*args_, **kwargs_)
        else:
            return Creation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_fault(self):
        return self.fault
    def set_fault(self, fault):
        self.fault = fault
    faultProp = property(get_fault, set_fault)
    def hasContent_(self):
        if (
            self.status is not None or
            self.fault is not None or
            super(Creation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='creation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('creation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='creation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='creation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='creation'):
        super(Creation, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='creation')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='creation', fromsubclass_=False, pretty_print=True):
        super(Creation, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.fault is not None:
            self.fault.export(outfile, level, namespaceprefix_, name_='fault', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Creation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'fault':
            obj_ = Fault.factory(parent_object_=self)
            obj_.build(child_)
            self.fault = obj_
            obj_.original_tagname_ = 'fault'
        super(Creation, self).buildChildren(child_, node, nodeName_, True)
# end class Creation


class Action(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, async=None, grace_period=None, host=None, network=None, root_password=None, ssh=None, image=None, fence_type=None, ticket=None, proxy_ticket=None, iscsi=None, storage_domain=None, cluster=None, discard_snapshots=None, exclusive=None, vm=None, snapshot=None, template=None, host_nics=None, modified_network_attachments=None, removed_network_attachments=None, synchronized_network_attachments=None, modified_bonds=None, removed_bonds=None, modified_labels=None, removed_labels=None, check_connectivity=None, connectivity_timeout=None, virtual_functions_configuration=None, pause=None, force=None, option=None, fix_layout=None, brick=None, detach=None, clone=None, restore_memory=None, disks=None, succeeded=None, resolution_type=None, bricks=None, job=None, import_as_template=None, maintenance_enabled=None, storage_domains=None, disk=None, reason=None, logical_units=None, use_sysprep=None, use_cloud_init=None, certificates=None, status=None, fault=None, iscsi_target=None, power_management=None, is_attached=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Action, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.async = async
        self.grace_period = grace_period
        self.host = host
        self.network = network
        self.root_password = root_password
        self.ssh = ssh
        self.image = image
        self.fence_type = fence_type
        self.ticket = ticket
        self.proxy_ticket = proxy_ticket
        self.iscsi = iscsi
        self.storage_domain = storage_domain
        self.cluster = cluster
        self.discard_snapshots = discard_snapshots
        self.exclusive = exclusive
        self.vm = vm
        self.snapshot = snapshot
        self.template = template
        self.host_nics = host_nics
        self.modified_network_attachments = modified_network_attachments
        self.removed_network_attachments = removed_network_attachments
        self.synchronized_network_attachments = synchronized_network_attachments
        self.modified_bonds = modified_bonds
        self.removed_bonds = removed_bonds
        self.modified_labels = modified_labels
        self.removed_labels = removed_labels
        self.check_connectivity = check_connectivity
        self.connectivity_timeout = connectivity_timeout
        self.virtual_functions_configuration = virtual_functions_configuration
        self.pause = pause
        self.force = force
        self.option = option
        self.fix_layout = fix_layout
        self.brick = brick
        self.detach = detach
        self.clone = clone
        self.restore_memory = restore_memory
        self.disks = disks
        self.succeeded = succeeded
        self.resolution_type = resolution_type
        self.bricks = bricks
        self.job = job
        self.import_as_template = import_as_template
        self.maintenance_enabled = maintenance_enabled
        self.storage_domains = storage_domains
        self.disk = disk
        self.reason = reason
        self.logical_units = logical_units
        self.use_sysprep = use_sysprep
        self.use_cloud_init = use_cloud_init
        self.certificates = certificates
        self.status = status
        self.fault = fault
        if iscsi_target is None:
            self.iscsi_target = []
        else:
            self.iscsi_target = iscsi_target
        self.power_management = power_management
        self.is_attached = is_attached
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Action)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Action.subclass:
            return Action.subclass(*args_, **kwargs_)
        else:
            return Action(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_async(self):
        return self.async
    def set_async(self, async):
        self.async = async
    asyncProp = property(get_async, set_async)
    def get_grace_period(self):
        return self.grace_period
    def set_grace_period(self, grace_period):
        self.grace_period = grace_period
    grace_periodProp = property(get_grace_period, set_grace_period)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    hostProp = property(get_host, set_host)
    def get_network(self):
        return self.network
    def set_network(self, network):
        self.network = network
    networkProp = property(get_network, set_network)
    def get_root_password(self):
        return self.root_password
    def set_root_password(self, root_password):
        self.root_password = root_password
    root_passwordProp = property(get_root_password, set_root_password)
    def get_ssh(self):
        return self.ssh
    def set_ssh(self, ssh):
        self.ssh = ssh
    sshProp = property(get_ssh, set_ssh)
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    imageProp = property(get_image, set_image)
    def get_fence_type(self):
        return self.fence_type
    def set_fence_type(self, fence_type):
        self.fence_type = fence_type
    fence_typeProp = property(get_fence_type, set_fence_type)
    def get_ticket(self):
        return self.ticket
    def set_ticket(self, ticket):
        self.ticket = ticket
    ticketProp = property(get_ticket, set_ticket)
    def get_proxy_ticket(self):
        return self.proxy_ticket
    def set_proxy_ticket(self, proxy_ticket):
        self.proxy_ticket = proxy_ticket
    proxy_ticketProp = property(get_proxy_ticket, set_proxy_ticket)
    def get_iscsi(self):
        return self.iscsi
    def set_iscsi(self, iscsi):
        self.iscsi = iscsi
    iscsiProp = property(get_iscsi, set_iscsi)
    def get_storage_domain(self):
        return self.storage_domain
    def set_storage_domain(self, storage_domain):
        self.storage_domain = storage_domain
    storage_domainProp = property(get_storage_domain, set_storage_domain)
    def get_cluster(self):
        return self.cluster
    def set_cluster(self, cluster):
        self.cluster = cluster
    clusterProp = property(get_cluster, set_cluster)
    def get_discard_snapshots(self):
        return self.discard_snapshots
    def set_discard_snapshots(self, discard_snapshots):
        self.discard_snapshots = discard_snapshots
    discard_snapshotsProp = property(get_discard_snapshots, set_discard_snapshots)
    def get_exclusive(self):
        return self.exclusive
    def set_exclusive(self, exclusive):
        self.exclusive = exclusive
    exclusiveProp = property(get_exclusive, set_exclusive)
    def get_vm(self):
        return self.vm
    def set_vm(self, vm):
        self.vm = vm
    vmProp = property(get_vm, set_vm)
    def get_snapshot(self):
        return self.snapshot
    def set_snapshot(self, snapshot):
        self.snapshot = snapshot
    snapshotProp = property(get_snapshot, set_snapshot)
    def get_template(self):
        return self.template
    def set_template(self, template):
        self.template = template
    templateProp = property(get_template, set_template)
    def get_host_nics(self):
        return self.host_nics
    def set_host_nics(self, host_nics):
        self.host_nics = host_nics
    host_nicsProp = property(get_host_nics, set_host_nics)
    def get_modified_network_attachments(self):
        return self.modified_network_attachments
    def set_modified_network_attachments(self, modified_network_attachments):
        self.modified_network_attachments = modified_network_attachments
    modified_network_attachmentsProp = property(get_modified_network_attachments, set_modified_network_attachments)
    def get_removed_network_attachments(self):
        return self.removed_network_attachments
    def set_removed_network_attachments(self, removed_network_attachments):
        self.removed_network_attachments = removed_network_attachments
    removed_network_attachmentsProp = property(get_removed_network_attachments, set_removed_network_attachments)
    def get_synchronized_network_attachments(self):
        return self.synchronized_network_attachments
    def set_synchronized_network_attachments(self, synchronized_network_attachments):
        self.synchronized_network_attachments = synchronized_network_attachments
    synchronized_network_attachmentsProp = property(get_synchronized_network_attachments, set_synchronized_network_attachments)
    def get_modified_bonds(self):
        return self.modified_bonds
    def set_modified_bonds(self, modified_bonds):
        self.modified_bonds = modified_bonds
    modified_bondsProp = property(get_modified_bonds, set_modified_bonds)
    def get_removed_bonds(self):
        return self.removed_bonds
    def set_removed_bonds(self, removed_bonds):
        self.removed_bonds = removed_bonds
    removed_bondsProp = property(get_removed_bonds, set_removed_bonds)
    def get_modified_labels(self):
        return self.modified_labels
    def set_modified_labels(self, modified_labels):
        self.modified_labels = modified_labels
    modified_labelsProp = property(get_modified_labels, set_modified_labels)
    def get_removed_labels(self):
        return self.removed_labels
    def set_removed_labels(self, removed_labels):
        self.removed_labels = removed_labels
    removed_labelsProp = property(get_removed_labels, set_removed_labels)
    def get_check_connectivity(self):
        return self.check_connectivity
    def set_check_connectivity(self, check_connectivity):
        self.check_connectivity = check_connectivity
    check_connectivityProp = property(get_check_connectivity, set_check_connectivity)
    def get_connectivity_timeout(self):
        return self.connectivity_timeout
    def set_connectivity_timeout(self, connectivity_timeout):
        self.connectivity_timeout = connectivity_timeout
    connectivity_timeoutProp = property(get_connectivity_timeout, set_connectivity_timeout)
    def get_virtual_functions_configuration(self):
        return self.virtual_functions_configuration
    def set_virtual_functions_configuration(self, virtual_functions_configuration):
        self.virtual_functions_configuration = virtual_functions_configuration
    virtual_functions_configurationProp = property(get_virtual_functions_configuration, set_virtual_functions_configuration)
    def get_pause(self):
        return self.pause
    def set_pause(self, pause):
        self.pause = pause
    pauseProp = property(get_pause, set_pause)
    def get_force(self):
        return self.force
    def set_force(self, force):
        self.force = force
    forceProp = property(get_force, set_force)
    def get_option(self):
        return self.option
    def set_option(self, option):
        self.option = option
    optionProp = property(get_option, set_option)
    def get_fix_layout(self):
        return self.fix_layout
    def set_fix_layout(self, fix_layout):
        self.fix_layout = fix_layout
    fix_layoutProp = property(get_fix_layout, set_fix_layout)
    def get_brick(self):
        return self.brick
    def set_brick(self, brick):
        self.brick = brick
    brickProp = property(get_brick, set_brick)
    def get_detach(self):
        return self.detach
    def set_detach(self, detach):
        self.detach = detach
    detachProp = property(get_detach, set_detach)
    def get_clone(self):
        return self.clone
    def set_clone(self, clone):
        self.clone = clone
    cloneProp = property(get_clone, set_clone)
    def get_restore_memory(self):
        return self.restore_memory
    def set_restore_memory(self, restore_memory):
        self.restore_memory = restore_memory
    restore_memoryProp = property(get_restore_memory, set_restore_memory)
    def get_disks(self):
        return self.disks
    def set_disks(self, disks):
        self.disks = disks
    disksProp = property(get_disks, set_disks)
    def get_succeeded(self):
        return self.succeeded
    def set_succeeded(self, succeeded):
        self.succeeded = succeeded
    succeededProp = property(get_succeeded, set_succeeded)
    def get_resolution_type(self):
        return self.resolution_type
    def set_resolution_type(self, resolution_type):
        self.resolution_type = resolution_type
    resolution_typeProp = property(get_resolution_type, set_resolution_type)
    def get_bricks(self):
        return self.bricks
    def set_bricks(self, bricks):
        self.bricks = bricks
    bricksProp = property(get_bricks, set_bricks)
    def get_job(self):
        return self.job
    def set_job(self, job):
        self.job = job
    jobProp = property(get_job, set_job)
    def get_import_as_template(self):
        return self.import_as_template
    def set_import_as_template(self, import_as_template):
        self.import_as_template = import_as_template
    import_as_templateProp = property(get_import_as_template, set_import_as_template)
    def get_maintenance_enabled(self):
        return self.maintenance_enabled
    def set_maintenance_enabled(self, maintenance_enabled):
        self.maintenance_enabled = maintenance_enabled
    maintenance_enabledProp = property(get_maintenance_enabled, set_maintenance_enabled)
    def get_storage_domains(self):
        return self.storage_domains
    def set_storage_domains(self, storage_domains):
        self.storage_domains = storage_domains
    storage_domainsProp = property(get_storage_domains, set_storage_domains)
    def get_disk(self):
        return self.disk
    def set_disk(self, disk):
        self.disk = disk
    diskProp = property(get_disk, set_disk)
    def get_reason(self):
        return self.reason
    def set_reason(self, reason):
        self.reason = reason
    reasonProp = property(get_reason, set_reason)
    def get_logical_units(self):
        return self.logical_units
    def set_logical_units(self, logical_units):
        self.logical_units = logical_units
    logical_unitsProp = property(get_logical_units, set_logical_units)
    def get_use_sysprep(self):
        return self.use_sysprep
    def set_use_sysprep(self, use_sysprep):
        self.use_sysprep = use_sysprep
    use_sysprepProp = property(get_use_sysprep, set_use_sysprep)
    def get_use_cloud_init(self):
        return self.use_cloud_init
    def set_use_cloud_init(self, use_cloud_init):
        self.use_cloud_init = use_cloud_init
    use_cloud_initProp = property(get_use_cloud_init, set_use_cloud_init)
    def get_certificates(self):
        return self.certificates
    def set_certificates(self, certificates):
        self.certificates = certificates
    certificatesProp = property(get_certificates, set_certificates)
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    statusProp = property(get_status, set_status)
    def get_fault(self):
        return self.fault
    def set_fault(self, fault):
        self.fault = fault
    faultProp = property(get_fault, set_fault)
    def get_iscsi_target(self):
        return self.iscsi_target
    def set_iscsi_target(self, iscsi_target):
        self.iscsi_target = iscsi_target
    def add_iscsi_target(self, value):
        self.iscsi_target.append(value)
    def insert_iscsi_target_at(self, index, value):
        self.iscsi_target.insert(index, value)
    def replace_iscsi_target_at(self, index, value):
        self.iscsi_target[index] = value
    iscsi_targetProp = property(get_iscsi_target, set_iscsi_target)
    def get_power_management(self):
        return self.power_management
    def set_power_management(self, power_management):
        self.power_management = power_management
    power_managementProp = property(get_power_management, set_power_management)
    def get_is_attached(self):
        return self.is_attached
    def set_is_attached(self, is_attached):
        self.is_attached = is_attached
    is_attachedProp = property(get_is_attached, set_is_attached)
    def hasContent_(self):
        if (
            self.async is not None or
            self.grace_period is not None or
            self.host is not None or
            self.network is not None or
            self.root_password is not None or
            self.ssh is not None or
            self.image is not None or
            self.fence_type is not None or
            self.ticket is not None or
            self.proxy_ticket is not None or
            self.iscsi is not None or
            self.storage_domain is not None or
            self.cluster is not None or
            self.discard_snapshots is not None or
            self.exclusive is not None or
            self.vm is not None or
            self.snapshot is not None or
            self.template is not None or
            self.host_nics is not None or
            self.modified_network_attachments is not None or
            self.removed_network_attachments is not None or
            self.synchronized_network_attachments is not None or
            self.modified_bonds is not None or
            self.removed_bonds is not None or
            self.modified_labels is not None or
            self.removed_labels is not None or
            self.check_connectivity is not None or
            self.connectivity_timeout is not None or
            self.virtual_functions_configuration is not None or
            self.pause is not None or
            self.force is not None or
            self.option is not None or
            self.fix_layout is not None or
            self.brick is not None or
            self.detach is not None or
            self.clone is not None or
            self.restore_memory is not None or
            self.disks is not None or
            self.succeeded is not None or
            self.resolution_type is not None or
            self.bricks is not None or
            self.job is not None or
            self.import_as_template is not None or
            self.maintenance_enabled is not None or
            self.storage_domains is not None or
            self.disk is not None or
            self.reason is not None or
            self.logical_units is not None or
            self.use_sysprep is not None or
            self.use_cloud_init is not None or
            self.certificates is not None or
            self.status is not None or
            self.fault is not None or
            self.iscsi_target or
            self.power_management is not None or
            self.is_attached is not None or
            super(Action, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='action', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('action')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='action')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='action', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='action'):
        super(Action, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='action')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='action', fromsubclass_=False, pretty_print=True):
        super(Action, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.async is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sasync>%s</%sasync>%s' % (namespaceprefix_ , self.gds_format_boolean(self.async, input_name='async'), namespaceprefix_ , eol_))
        if self.grace_period is not None:
            self.grace_period.export(outfile, level, namespaceprefix_, name_='grace_period', pretty_print=pretty_print)
        if self.host is not None:
            self.host.export(outfile, level, namespaceprefix_, name_='host', pretty_print=pretty_print)
        if self.network is not None:
            self.network.export(outfile, level, namespaceprefix_, name_='network', pretty_print=pretty_print)
        if self.root_password is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sroot_password>%s</%sroot_password>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.root_password), input_name='root_password')), namespaceprefix_ , eol_))
        if self.ssh is not None:
            self.ssh.export(outfile, level, namespaceprefix_, name_='ssh', pretty_print=pretty_print)
        if self.image is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simage>%s</%simage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.image), input_name='image')), namespaceprefix_ , eol_))
        if self.fence_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfence_type>%s</%sfence_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fence_type), input_name='fence_type')), namespaceprefix_ , eol_))
        if self.ticket is not None:
            self.ticket.export(outfile, level, namespaceprefix_, name_='ticket', pretty_print=pretty_print)
        if self.proxy_ticket is not None:
            self.proxy_ticket.export(outfile, level, namespaceprefix_, name_='proxy_ticket', pretty_print=pretty_print)
        if self.iscsi is not None:
            self.iscsi.export(outfile, level, namespaceprefix_, name_='iscsi', pretty_print=pretty_print)
        if self.storage_domain is not None:
            self.storage_domain.export(outfile, level, namespaceprefix_, name_='storage_domain', pretty_print=pretty_print)
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespaceprefix_, name_='cluster', pretty_print=pretty_print)
        if self.discard_snapshots is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdiscard_snapshots>%s</%sdiscard_snapshots>%s' % (namespaceprefix_ , self.gds_format_boolean(self.discard_snapshots, input_name='discard_snapshots'), namespaceprefix_ , eol_))
        if self.exclusive is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexclusive>%s</%sexclusive>%s' % (namespaceprefix_ , self.gds_format_boolean(self.exclusive, input_name='exclusive'), namespaceprefix_ , eol_))
        if self.vm is not None:
            self.vm.export(outfile, level, namespaceprefix_, name_='vm', pretty_print=pretty_print)
        if self.snapshot is not None:
            self.snapshot.export(outfile, level, namespaceprefix_, name_='snapshot', pretty_print=pretty_print)
        if self.template is not None:
            self.template.export(outfile, level, namespaceprefix_, name_='template', pretty_print=pretty_print)
        if self.host_nics is not None:
            self.host_nics.export(outfile, level, namespaceprefix_, name_='host_nics', pretty_print=pretty_print)
        if self.modified_network_attachments is not None:
            self.modified_network_attachments.export(outfile, level, namespaceprefix_, name_='modified_network_attachments', pretty_print=pretty_print)
        if self.removed_network_attachments is not None:
            self.removed_network_attachments.export(outfile, level, namespaceprefix_, name_='removed_network_attachments', pretty_print=pretty_print)
        if self.synchronized_network_attachments is not None:
            self.synchronized_network_attachments.export(outfile, level, namespaceprefix_, name_='synchronized_network_attachments', pretty_print=pretty_print)
        if self.modified_bonds is not None:
            self.modified_bonds.export(outfile, level, namespaceprefix_, name_='modified_bonds', pretty_print=pretty_print)
        if self.removed_bonds is not None:
            self.removed_bonds.export(outfile, level, namespaceprefix_, name_='removed_bonds', pretty_print=pretty_print)
        if self.modified_labels is not None:
            self.modified_labels.export(outfile, level, namespaceprefix_, name_='modified_labels', pretty_print=pretty_print)
        if self.removed_labels is not None:
            self.removed_labels.export(outfile, level, namespaceprefix_, name_='removed_labels', pretty_print=pretty_print)
        if self.check_connectivity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scheck_connectivity>%s</%scheck_connectivity>%s' % (namespaceprefix_ , self.gds_format_boolean(self.check_connectivity, input_name='check_connectivity'), namespaceprefix_ , eol_))
        if self.connectivity_timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconnectivity_timeout>%s</%sconnectivity_timeout>%s' % (namespaceprefix_ , self.gds_format_integer(self.connectivity_timeout, input_name='connectivity_timeout'), namespaceprefix_ , eol_))
        if self.virtual_functions_configuration is not None:
            self.virtual_functions_configuration.export(outfile, level, namespaceprefix_, name_='virtual_functions_configuration', pretty_print=pretty_print)
        if self.pause is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spause>%s</%spause>%s' % (namespaceprefix_ , self.gds_format_boolean(self.pause, input_name='pause'), namespaceprefix_ , eol_))
        if self.force is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sforce>%s</%sforce>%s' % (namespaceprefix_ , self.gds_format_boolean(self.force, input_name='force'), namespaceprefix_ , eol_))
        if self.option is not None:
            self.option.export(outfile, level, namespaceprefix_, name_='option', pretty_print=pretty_print)
        if self.fix_layout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfix_layout>%s</%sfix_layout>%s' % (namespaceprefix_ , self.gds_format_boolean(self.fix_layout, input_name='fix_layout'), namespaceprefix_ , eol_))
        if self.brick is not None:
            self.brick.export(outfile, level, namespaceprefix_, name_='brick', pretty_print=pretty_print)
        if self.detach is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetach>%s</%sdetach>%s' % (namespaceprefix_ , self.gds_format_boolean(self.detach, input_name='detach'), namespaceprefix_ , eol_))
        if self.clone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclone>%s</%sclone>%s' % (namespaceprefix_ , self.gds_format_boolean(self.clone, input_name='clone'), namespaceprefix_ , eol_))
        if self.restore_memory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srestore_memory>%s</%srestore_memory>%s' % (namespaceprefix_ , self.gds_format_boolean(self.restore_memory, input_name='restore_memory'), namespaceprefix_ , eol_))
        if self.disks is not None:
            self.disks.export(outfile, level, namespaceprefix_, name_='disks', pretty_print=pretty_print)
        if self.succeeded is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssucceeded>%s</%ssucceeded>%s' % (namespaceprefix_ , self.gds_format_boolean(self.succeeded, input_name='succeeded'), namespaceprefix_ , eol_))
        if self.resolution_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresolution_type>%s</%sresolution_type>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.resolution_type), input_name='resolution_type')), namespaceprefix_ , eol_))
        if self.bricks is not None:
            self.bricks.export(outfile, level, namespaceprefix_, name_='bricks', pretty_print=pretty_print)
        if self.job is not None:
            self.job.export(outfile, level, namespaceprefix_, name_='job', pretty_print=pretty_print)
        if self.import_as_template is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simport_as_template>%s</%simport_as_template>%s' % (namespaceprefix_ , self.gds_format_boolean(self.import_as_template, input_name='import_as_template'), namespaceprefix_ , eol_))
        if self.maintenance_enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaintenance_enabled>%s</%smaintenance_enabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.maintenance_enabled, input_name='maintenance_enabled'), namespaceprefix_ , eol_))
        if self.storage_domains is not None:
            self.storage_domains.export(outfile, level, namespaceprefix_, name_='storage_domains', pretty_print=pretty_print)
        if self.disk is not None:
            self.disk.export(outfile, level, namespaceprefix_, name_='disk', pretty_print=pretty_print)
        if self.reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reason), input_name='reason')), namespaceprefix_ , eol_))
        if self.logical_units is not None:
            self.logical_units.export(outfile, level, namespaceprefix_, name_='logical_units', pretty_print=pretty_print)
        if self.use_sysprep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suse_sysprep>%s</%suse_sysprep>%s' % (namespaceprefix_ , self.gds_format_boolean(self.use_sysprep, input_name='use_sysprep'), namespaceprefix_ , eol_))
        if self.use_cloud_init is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suse_cloud_init>%s</%suse_cloud_init>%s' % (namespaceprefix_ , self.gds_format_boolean(self.use_cloud_init, input_name='use_cloud_init'), namespaceprefix_ , eol_))
        if self.certificates is not None:
            self.certificates.export(outfile, level, namespaceprefix_, name_='certificates', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespaceprefix_, name_='status', pretty_print=pretty_print)
        if self.fault is not None:
            self.fault.export(outfile, level, namespaceprefix_, name_='fault', pretty_print=pretty_print)
        for iscsi_target_ in self.iscsi_target:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%siscsi_target>%s</%siscsi_target>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(iscsi_target_), input_name='iscsi_target')), namespaceprefix_ , eol_))
        if self.power_management is not None:
            self.power_management.export(outfile, level, namespaceprefix_, name_='power_management', pretty_print=pretty_print)
        if self.is_attached is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sis_attached>%s</%sis_attached>%s' % (namespaceprefix_ , self.gds_format_boolean(self.is_attached, input_name='is_attached'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Action, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'async':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'async')
            self.async = ival_
        elif nodeName_ == 'grace_period':
            obj_ = GracePeriod.factory(parent_object_=self)
            obj_.build(child_)
            self.grace_period = obj_
            obj_.original_tagname_ = 'grace_period'
        elif nodeName_ == 'host':
            obj_ = Host.factory(parent_object_=self)
            obj_.build(child_)
            self.host = obj_
            obj_.original_tagname_ = 'host'
        elif nodeName_ == 'network':
            obj_ = Network.factory(parent_object_=self)
            obj_.build(child_)
            self.network = obj_
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'root_password':
            root_password_ = child_.text
            root_password_ = self.gds_validate_string(root_password_, node, 'root_password')
            self.root_password = root_password_
        elif nodeName_ == 'ssh':
            obj_ = SSH.factory(parent_object_=self)
            obj_.build(child_)
            self.ssh = obj_
            obj_.original_tagname_ = 'ssh'
        elif nodeName_ == 'image':
            image_ = child_.text
            image_ = self.gds_validate_string(image_, node, 'image')
            self.image = image_
        elif nodeName_ == 'fence_type':
            fence_type_ = child_.text
            fence_type_ = self.gds_validate_string(fence_type_, node, 'fence_type')
            self.fence_type = fence_type_
        elif nodeName_ == 'ticket':
            obj_ = Ticket.factory(parent_object_=self)
            obj_.build(child_)
            self.ticket = obj_
            obj_.original_tagname_ = 'ticket'
        elif nodeName_ == 'proxy_ticket':
            obj_ = ProxyTicket.factory(parent_object_=self)
            obj_.build(child_)
            self.proxy_ticket = obj_
            obj_.original_tagname_ = 'proxy_ticket'
        elif nodeName_ == 'iscsi':
            obj_ = IscsiDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.iscsi = obj_
            obj_.original_tagname_ = 'iscsi'
        elif nodeName_ == 'storage_domain':
            obj_ = StorageDomain.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain = obj_
            obj_.original_tagname_ = 'storage_domain'
        elif nodeName_ == 'cluster':
            obj_ = Cluster.factory(parent_object_=self)
            obj_.build(child_)
            self.cluster = obj_
            obj_.original_tagname_ = 'cluster'
        elif nodeName_ == 'discard_snapshots':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'discard_snapshots')
            self.discard_snapshots = ival_
        elif nodeName_ == 'exclusive':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'exclusive')
            self.exclusive = ival_
        elif nodeName_ == 'vm':
            class_obj_ = self.get_class_obj_(child_, VM)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.vm = obj_
            obj_.original_tagname_ = 'vm'
        elif nodeName_ == 'snapshot':
            obj_ = Snapshot.factory(parent_object_=self)
            obj_.build(child_)
            self.snapshot = obj_
            obj_.original_tagname_ = 'snapshot'
        elif nodeName_ == 'template':
            class_obj_ = self.get_class_obj_(child_, Template)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.template = obj_
            obj_.original_tagname_ = 'template'
        elif nodeName_ == 'host_nics':
            obj_ = HostNics.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nics = obj_
            obj_.original_tagname_ = 'host_nics'
        elif nodeName_ == 'modified_network_attachments':
            obj_ = NetworkAttachments.factory(parent_object_=self)
            obj_.build(child_)
            self.modified_network_attachments = obj_
            obj_.original_tagname_ = 'modified_network_attachments'
        elif nodeName_ == 'removed_network_attachments':
            obj_ = NetworkAttachments.factory(parent_object_=self)
            obj_.build(child_)
            self.removed_network_attachments = obj_
            obj_.original_tagname_ = 'removed_network_attachments'
        elif nodeName_ == 'synchronized_network_attachments':
            obj_ = NetworkAttachments.factory(parent_object_=self)
            obj_.build(child_)
            self.synchronized_network_attachments = obj_
            obj_.original_tagname_ = 'synchronized_network_attachments'
        elif nodeName_ == 'modified_bonds':
            obj_ = HostNics.factory(parent_object_=self)
            obj_.build(child_)
            self.modified_bonds = obj_
            obj_.original_tagname_ = 'modified_bonds'
        elif nodeName_ == 'removed_bonds':
            obj_ = HostNics.factory(parent_object_=self)
            obj_.build(child_)
            self.removed_bonds = obj_
            obj_.original_tagname_ = 'removed_bonds'
        elif nodeName_ == 'modified_labels':
            obj_ = Labels.factory(parent_object_=self)
            obj_.build(child_)
            self.modified_labels = obj_
            obj_.original_tagname_ = 'modified_labels'
        elif nodeName_ == 'removed_labels':
            obj_ = Labels.factory(parent_object_=self)
            obj_.build(child_)
            self.removed_labels = obj_
            obj_.original_tagname_ = 'removed_labels'
        elif nodeName_ == 'check_connectivity':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'check_connectivity')
            self.check_connectivity = ival_
        elif nodeName_ == 'connectivity_timeout' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'connectivity_timeout')
            self.connectivity_timeout = ival_
        elif nodeName_ == 'virtual_functions_configuration':
            obj_ = HostNicVirtualFunctionsConfiguration.factory(parent_object_=self)
            obj_.build(child_)
            self.virtual_functions_configuration = obj_
            obj_.original_tagname_ = 'virtual_functions_configuration'
        elif nodeName_ == 'pause':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'pause')
            self.pause = ival_
        elif nodeName_ == 'force':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'force')
            self.force = ival_
        elif nodeName_ == 'option':
            obj_ = Option.factory(parent_object_=self)
            obj_.build(child_)
            self.option = obj_
            obj_.original_tagname_ = 'option'
        elif nodeName_ == 'fix_layout':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'fix_layout')
            self.fix_layout = ival_
        elif nodeName_ == 'brick':
            obj_ = GlusterBrick.factory(parent_object_=self)
            obj_.build(child_)
            self.brick = obj_
            obj_.original_tagname_ = 'brick'
        elif nodeName_ == 'detach':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'detach')
            self.detach = ival_
        elif nodeName_ == 'clone':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'clone')
            self.clone = ival_
        elif nodeName_ == 'restore_memory':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'restore_memory')
            self.restore_memory = ival_
        elif nodeName_ == 'disks':
            obj_ = Disks.factory(parent_object_=self)
            obj_.build(child_)
            self.disks = obj_
            obj_.original_tagname_ = 'disks'
        elif nodeName_ == 'succeeded':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'succeeded')
            self.succeeded = ival_
        elif nodeName_ == 'resolution_type':
            resolution_type_ = child_.text
            resolution_type_ = self.gds_validate_string(resolution_type_, node, 'resolution_type')
            self.resolution_type = resolution_type_
        elif nodeName_ == 'bricks':
            obj_ = GlusterBricks.factory(parent_object_=self)
            obj_.build(child_)
            self.bricks = obj_
            obj_.original_tagname_ = 'bricks'
        elif nodeName_ == 'job':
            obj_ = Job.factory(parent_object_=self)
            obj_.build(child_)
            self.job = obj_
            obj_.original_tagname_ = 'job'
        elif nodeName_ == 'import_as_template':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'import_as_template')
            self.import_as_template = ival_
        elif nodeName_ == 'maintenance_enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'maintenance_enabled')
            self.maintenance_enabled = ival_
        elif nodeName_ == 'storage_domains':
            obj_ = StorageDomains.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domains = obj_
            obj_.original_tagname_ = 'storage_domains'
        elif nodeName_ == 'disk':
            class_obj_ = self.get_class_obj_(child_, Disk)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.disk = obj_
            obj_.original_tagname_ = 'disk'
        elif nodeName_ == 'reason':
            reason_ = child_.text
            reason_ = self.gds_validate_string(reason_, node, 'reason')
            self.reason = reason_
        elif nodeName_ == 'logical_units':
            obj_ = LogicalUnits.factory(parent_object_=self)
            obj_.build(child_)
            self.logical_units = obj_
            obj_.original_tagname_ = 'logical_units'
        elif nodeName_ == 'use_sysprep':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'use_sysprep')
            self.use_sysprep = ival_
        elif nodeName_ == 'use_cloud_init':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'use_cloud_init')
            self.use_cloud_init = ival_
        elif nodeName_ == 'certificates':
            obj_ = Certificates.factory(parent_object_=self)
            obj_.build(child_)
            self.certificates = obj_
            obj_.original_tagname_ = 'certificates'
        elif nodeName_ == 'status':
            obj_ = Status.factory(parent_object_=self)
            obj_.build(child_)
            self.status = obj_
            obj_.original_tagname_ = 'status'
        elif nodeName_ == 'fault':
            obj_ = Fault.factory(parent_object_=self)
            obj_.build(child_)
            self.fault = obj_
            obj_.original_tagname_ = 'fault'
        elif nodeName_ == 'iscsi_target':
            iscsi_target_ = child_.text
            iscsi_target_ = self.gds_validate_string(iscsi_target_, node, 'iscsi_target')
            self.iscsi_target.append(iscsi_target_)
        elif nodeName_ == 'power_management':
            obj_ = PowerManagement.factory(parent_object_=self)
            obj_.build(child_)
            self.power_management = obj_
            obj_.original_tagname_ = 'power_management'
        elif nodeName_ == 'is_attached':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'is_attached')
            self.is_attached = ival_
        super(Action, self).buildChildren(child_, node, nodeName_, True)
# end class Action


class SpecialObjects(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SpecialObjects, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SpecialObjects)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SpecialObjects.subclass:
            return SpecialObjects.subclass(*args_, **kwargs_)
        else:
            return SpecialObjects(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SpecialObjects, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='special_objects', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('special_objects')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='special_objects')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='special_objects', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='special_objects'):
        super(SpecialObjects, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='special_objects')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='special_objects', fromsubclass_=False, pretty_print=True):
        super(SpecialObjects, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SpecialObjects, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SpecialObjects, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SpecialObjects


class API(BaseResource):
    subclass = None
    superclass = BaseResource
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, special_objects=None, product_info=None, summary=None, time=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(API, self).__init__(actions, href, id, name, description, comment, creation_status, link,  **kwargs_)
        self.special_objects = special_objects
        self.product_info = product_info
        self.summary = summary
        if isinstance(time, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, API)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if API.subclass:
            return API.subclass(*args_, **kwargs_)
        else:
            return API(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_special_objects(self):
        return self.special_objects
    def set_special_objects(self, special_objects):
        self.special_objects = special_objects
    special_objectsProp = property(get_special_objects, set_special_objects)
    def get_product_info(self):
        return self.product_info
    def set_product_info(self, product_info):
        self.product_info = product_info
    product_infoProp = property(get_product_info, set_product_info)
    def get_summary(self):
        return self.summary
    def set_summary(self, summary):
        self.summary = summary
    summaryProp = property(get_summary, set_summary)
    def get_time(self):
        return self.time
    def set_time(self, time):
        self.time = time
    timeProp = property(get_time, set_time)
    def hasContent_(self):
        if (
            self.special_objects is not None or
            self.product_info is not None or
            self.summary is not None or
            self.time is not None or
            super(API, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='api', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('api')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='api')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='api', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='api'):
        super(API, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='api')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='api', fromsubclass_=False, pretty_print=True):
        super(API, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.special_objects is not None:
            self.special_objects.export(outfile, level, namespaceprefix_, name_='special_objects', pretty_print=pretty_print)
        if self.product_info is not None:
            self.product_info.export(outfile, level, namespaceprefix_, name_='product_info', pretty_print=pretty_print)
        if self.summary is not None:
            self.summary.export(outfile, level, namespaceprefix_, name_='summary', pretty_print=pretty_print)
        if self.time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stime>%s</%stime>%s' % (namespaceprefix_ , self.gds_format_datetime(self.time, input_name='time'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(API, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'special_objects':
            obj_ = SpecialObjects.factory(parent_object_=self)
            obj_.build(child_)
            self.special_objects = obj_
            obj_.original_tagname_ = 'special_objects'
        elif nodeName_ == 'product_info':
            obj_ = ProductInfo.factory(parent_object_=self)
            obj_.build(child_)
            self.product_info = obj_
            obj_.original_tagname_ = 'product_info'
        elif nodeName_ == 'summary':
            obj_ = ApiSummary.factory(parent_object_=self)
            obj_.build(child_)
            self.summary = obj_
            obj_.original_tagname_ = 'summary'
        elif nodeName_ == 'time':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.time = dval_
        super(API, self).buildChildren(child_, node, nodeName_, True)
# end class API


class DetailedLink(Link):
    subclass = None
    superclass = Link
    def __init__(self, href=None, rel=None, description=None, request=None, response=None, linkCapabilities=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DetailedLink, self).__init__(href, rel, extensiontype_,  **kwargs_)
        self.description = description
        self.request = request
        self.response = response
        self.linkCapabilities = linkCapabilities
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DetailedLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DetailedLink.subclass:
            return DetailedLink.subclass(*args_, **kwargs_)
        else:
            return DetailedLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    descriptionProp = property(get_description, set_description)
    def get_request(self):
        return self.request
    def set_request(self, request):
        self.request = request
    requestProp = property(get_request, set_request)
    def get_response(self):
        return self.response
    def set_response(self, response):
        self.response = response
    responseProp = property(get_response, set_response)
    def get_linkCapabilities(self):
        return self.linkCapabilities
    def set_linkCapabilities(self, linkCapabilities):
        self.linkCapabilities = linkCapabilities
    linkCapabilitiesProp = property(get_linkCapabilities, set_linkCapabilities)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.description is not None or
            self.request is not None or
            self.response is not None or
            self.linkCapabilities is not None or
            super(DetailedLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='detailedLink', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detailedLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detailedLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='detailedLink', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detailedLink'):
        super(DetailedLink, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detailedLink')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='detailedLink', fromsubclass_=False, pretty_print=True):
        super(DetailedLink, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.request is not None:
            self.request.export(outfile, level, namespaceprefix_, name_='request', pretty_print=pretty_print)
        if self.response is not None:
            self.response.export(outfile, level, namespaceprefix_, name_='response', pretty_print=pretty_print)
        if self.linkCapabilities is not None:
            self.linkCapabilities.export(outfile, level, namespaceprefix_, name_='linkCapabilities', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DetailedLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'request':
            obj_ = Request.factory(parent_object_=self)
            obj_.build(child_)
            self.request = obj_
            obj_.original_tagname_ = 'request'
        elif nodeName_ == 'response':
            obj_ = Response.factory(parent_object_=self)
            obj_.build(child_)
            self.response = obj_
            obj_.original_tagname_ = 'response'
        elif nodeName_ == 'linkCapabilities':
            obj_ = LinkCapabilities.factory(parent_object_=self)
            obj_.build(child_)
            self.linkCapabilities = obj_
            obj_.original_tagname_ = 'linkCapabilities'
        super(DetailedLink, self).buildChildren(child_, node, nodeName_, True)
# end class DetailedLink


class GeneralMetadata(DetailedLink):
    subclass = None
    superclass = DetailedLink
    def __init__(self, href=None, rel=None, description=None, request=None, response=None, linkCapabilities=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GeneralMetadata, self).__init__(href, rel, description, request, response, linkCapabilities,  **kwargs_)
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeneralMetadata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeneralMetadata.subclass:
            return GeneralMetadata.subclass(*args_, **kwargs_)
        else:
            return GeneralMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    nameProp = property(get_name, set_name)
    def hasContent_(self):
        if (
            self.name is not None or
            super(GeneralMetadata, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='general_metadata', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('general_metadata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='general_metadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='general_metadata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='general_metadata'):
        super(GeneralMetadata, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='general_metadata')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='general_metadata', fromsubclass_=False, pretty_print=True):
        super(GeneralMetadata, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GeneralMetadata, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        super(GeneralMetadata, self).buildChildren(child_, node, nodeName_, True)
# end class GeneralMetadata


class VersionCaps(Version):
    subclass = None
    superclass = Version
    def __init__(self, actions=None, href=None, id=None, name=None, description=None, comment=None, creation_status=None, link=None, major=None, minor=None, build_=None, revision=None, full_version=None, current=None, features=None, cpus=None, power_managers=None, fence_types=None, storage_types=None, configuration_types=None, storage_domain_types=None, vm_types=None, boot_devices=None, display_types=None, nic_interfaces=None, os_types=None, disk_formats=None, graphics_types=None, disk_storage_types=None, disk_interfaces=None, vm_affinities=None, custom_properties=None, boot_protocols=None, error_handling=None, storage_formats=None, creation_states=None, power_management_states=None, host_states=None, external_statuses=None, host_protocols=None, host_non_operational_details=None, network_states=None, storage_domain_states=None, template_states=None, vm_states=None, vm_pause_details=None, disk_states=None, host_nic_states=None, data_center_states=None, vm_device_types=None, permits=None, scheduling_policies=None, usages=None, nfs_versions=None, pm_proxy_types=None, cpu_modes=None, sgio_options=None, watchdog_models=None, watchdog_actions=None, authentication_methods=None, kdump_states=None, spm_states=None, vm_pool_types=None, step_types=None, payload_encodings=None, gluster_volume_types=None, transport_types=None, gluster_volume_states=None, brick_states=None, reported_device_types=None, ip_versions=None, snapshot_statuses=None, content_types=None, hook_states=None, stages=None, sso_methods=None, architecture_capabilities=None, serial_number_policies=None, selinux_modes=None, rng_sources=None, scheduling_policy_unit_types=None, qos_types=None, inheritable_booleans=None, network_plugin_types=None, message_broker_types=None, display_disconnect_actions=None, quota_mode_types=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(VersionCaps, self).__init__(actions, href, id, name, description, comment, creation_status, link, major, minor, build_, revision, full_version,  **kwargs_)
        self.current = current
        self.features = features
        self.cpus = cpus
        self.power_managers = power_managers
        self.fence_types = fence_types
        self.storage_types = storage_types
        self.configuration_types = configuration_types
        self.storage_domain_types = storage_domain_types
        self.vm_types = vm_types
        self.boot_devices = boot_devices
        self.display_types = display_types
        self.nic_interfaces = nic_interfaces
        self.os_types = os_types
        self.disk_formats = disk_formats
        self.graphics_types = graphics_types
        self.disk_storage_types = disk_storage_types
        self.disk_interfaces = disk_interfaces
        self.vm_affinities = vm_affinities
        self.custom_properties = custom_properties
        self.boot_protocols = boot_protocols
        self.error_handling = error_handling
        self.storage_formats = storage_formats
        self.creation_states = creation_states
        self.power_management_states = power_management_states
        self.host_states = host_states
        self.external_statuses = external_statuses
        self.host_protocols = host_protocols
        self.host_non_operational_details = host_non_operational_details
        self.network_states = network_states
        self.storage_domain_states = storage_domain_states
        self.template_states = template_states
        self.vm_states = vm_states
        self.vm_pause_details = vm_pause_details
        self.disk_states = disk_states
        self.host_nic_states = host_nic_states
        self.data_center_states = data_center_states
        self.vm_device_types = vm_device_types
        self.permits = permits
        self.scheduling_policies = scheduling_policies
        self.usages = usages
        self.nfs_versions = nfs_versions
        self.pm_proxy_types = pm_proxy_types
        self.cpu_modes = cpu_modes
        self.sgio_options = sgio_options
        self.watchdog_models = watchdog_models
        self.watchdog_actions = watchdog_actions
        self.authentication_methods = authentication_methods
        self.kdump_states = kdump_states
        self.spm_states = spm_states
        self.vm_pool_types = vm_pool_types
        self.step_types = step_types
        self.payload_encodings = payload_encodings
        self.gluster_volume_types = gluster_volume_types
        self.transport_types = transport_types
        self.gluster_volume_states = gluster_volume_states
        self.brick_states = brick_states
        self.reported_device_types = reported_device_types
        self.ip_versions = ip_versions
        self.snapshot_statuses = snapshot_statuses
        self.content_types = content_types
        self.hook_states = hook_states
        self.stages = stages
        self.sso_methods = sso_methods
        self.architecture_capabilities = architecture_capabilities
        self.serial_number_policies = serial_number_policies
        self.selinux_modes = selinux_modes
        self.rng_sources = rng_sources
        self.scheduling_policy_unit_types = scheduling_policy_unit_types
        self.qos_types = qos_types
        self.inheritable_booleans = inheritable_booleans
        self.network_plugin_types = network_plugin_types
        self.message_broker_types = message_broker_types
        self.display_disconnect_actions = display_disconnect_actions
        self.quota_mode_types = quota_mode_types
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionCaps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionCaps.subclass:
            return VersionCaps.subclass(*args_, **kwargs_)
        else:
            return VersionCaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_current(self):
        return self.current
    def set_current(self, current):
        self.current = current
    currentProp = property(get_current, set_current)
    def get_features(self):
        return self.features
    def set_features(self, features):
        self.features = features
    featuresProp = property(get_features, set_features)
    def get_cpus(self):
        return self.cpus
    def set_cpus(self, cpus):
        self.cpus = cpus
    cpusProp = property(get_cpus, set_cpus)
    def get_power_managers(self):
        return self.power_managers
    def set_power_managers(self, power_managers):
        self.power_managers = power_managers
    power_managersProp = property(get_power_managers, set_power_managers)
    def get_fence_types(self):
        return self.fence_types
    def set_fence_types(self, fence_types):
        self.fence_types = fence_types
    fence_typesProp = property(get_fence_types, set_fence_types)
    def get_storage_types(self):
        return self.storage_types
    def set_storage_types(self, storage_types):
        self.storage_types = storage_types
    storage_typesProp = property(get_storage_types, set_storage_types)
    def get_configuration_types(self):
        return self.configuration_types
    def set_configuration_types(self, configuration_types):
        self.configuration_types = configuration_types
    configuration_typesProp = property(get_configuration_types, set_configuration_types)
    def get_storage_domain_types(self):
        return self.storage_domain_types
    def set_storage_domain_types(self, storage_domain_types):
        self.storage_domain_types = storage_domain_types
    storage_domain_typesProp = property(get_storage_domain_types, set_storage_domain_types)
    def get_vm_types(self):
        return self.vm_types
    def set_vm_types(self, vm_types):
        self.vm_types = vm_types
    vm_typesProp = property(get_vm_types, set_vm_types)
    def get_boot_devices(self):
        return self.boot_devices
    def set_boot_devices(self, boot_devices):
        self.boot_devices = boot_devices
    boot_devicesProp = property(get_boot_devices, set_boot_devices)
    def get_display_types(self):
        return self.display_types
    def set_display_types(self, display_types):
        self.display_types = display_types
    display_typesProp = property(get_display_types, set_display_types)
    def get_nic_interfaces(self):
        return self.nic_interfaces
    def set_nic_interfaces(self, nic_interfaces):
        self.nic_interfaces = nic_interfaces
    nic_interfacesProp = property(get_nic_interfaces, set_nic_interfaces)
    def get_os_types(self):
        return self.os_types
    def set_os_types(self, os_types):
        self.os_types = os_types
    os_typesProp = property(get_os_types, set_os_types)
    def get_disk_formats(self):
        return self.disk_formats
    def set_disk_formats(self, disk_formats):
        self.disk_formats = disk_formats
    disk_formatsProp = property(get_disk_formats, set_disk_formats)
    def get_graphics_types(self):
        return self.graphics_types
    def set_graphics_types(self, graphics_types):
        self.graphics_types = graphics_types
    graphics_typesProp = property(get_graphics_types, set_graphics_types)
    def get_disk_storage_types(self):
        return self.disk_storage_types
    def set_disk_storage_types(self, disk_storage_types):
        self.disk_storage_types = disk_storage_types
    disk_storage_typesProp = property(get_disk_storage_types, set_disk_storage_types)
    def get_disk_interfaces(self):
        return self.disk_interfaces
    def set_disk_interfaces(self, disk_interfaces):
        self.disk_interfaces = disk_interfaces
    disk_interfacesProp = property(get_disk_interfaces, set_disk_interfaces)
    def get_vm_affinities(self):
        return self.vm_affinities
    def set_vm_affinities(self, vm_affinities):
        self.vm_affinities = vm_affinities
    vm_affinitiesProp = property(get_vm_affinities, set_vm_affinities)
    def get_custom_properties(self):
        return self.custom_properties
    def set_custom_properties(self, custom_properties):
        self.custom_properties = custom_properties
    custom_propertiesProp = property(get_custom_properties, set_custom_properties)
    def get_boot_protocols(self):
        return self.boot_protocols
    def set_boot_protocols(self, boot_protocols):
        self.boot_protocols = boot_protocols
    boot_protocolsProp = property(get_boot_protocols, set_boot_protocols)
    def get_error_handling(self):
        return self.error_handling
    def set_error_handling(self, error_handling):
        self.error_handling = error_handling
    error_handlingProp = property(get_error_handling, set_error_handling)
    def get_storage_formats(self):
        return self.storage_formats
    def set_storage_formats(self, storage_formats):
        self.storage_formats = storage_formats
    storage_formatsProp = property(get_storage_formats, set_storage_formats)
    def get_creation_states(self):
        return self.creation_states
    def set_creation_states(self, creation_states):
        self.creation_states = creation_states
    creation_statesProp = property(get_creation_states, set_creation_states)
    def get_power_management_states(self):
        return self.power_management_states
    def set_power_management_states(self, power_management_states):
        self.power_management_states = power_management_states
    power_management_statesProp = property(get_power_management_states, set_power_management_states)
    def get_host_states(self):
        return self.host_states
    def set_host_states(self, host_states):
        self.host_states = host_states
    host_statesProp = property(get_host_states, set_host_states)
    def get_external_statuses(self):
        return self.external_statuses
    def set_external_statuses(self, external_statuses):
        self.external_statuses = external_statuses
    external_statusesProp = property(get_external_statuses, set_external_statuses)
    def get_host_protocols(self):
        return self.host_protocols
    def set_host_protocols(self, host_protocols):
        self.host_protocols = host_protocols
    host_protocolsProp = property(get_host_protocols, set_host_protocols)
    def get_host_non_operational_details(self):
        return self.host_non_operational_details
    def set_host_non_operational_details(self, host_non_operational_details):
        self.host_non_operational_details = host_non_operational_details
    host_non_operational_detailsProp = property(get_host_non_operational_details, set_host_non_operational_details)
    def get_network_states(self):
        return self.network_states
    def set_network_states(self, network_states):
        self.network_states = network_states
    network_statesProp = property(get_network_states, set_network_states)
    def get_storage_domain_states(self):
        return self.storage_domain_states
    def set_storage_domain_states(self, storage_domain_states):
        self.storage_domain_states = storage_domain_states
    storage_domain_statesProp = property(get_storage_domain_states, set_storage_domain_states)
    def get_template_states(self):
        return self.template_states
    def set_template_states(self, template_states):
        self.template_states = template_states
    template_statesProp = property(get_template_states, set_template_states)
    def get_vm_states(self):
        return self.vm_states
    def set_vm_states(self, vm_states):
        self.vm_states = vm_states
    vm_statesProp = property(get_vm_states, set_vm_states)
    def get_vm_pause_details(self):
        return self.vm_pause_details
    def set_vm_pause_details(self, vm_pause_details):
        self.vm_pause_details = vm_pause_details
    vm_pause_detailsProp = property(get_vm_pause_details, set_vm_pause_details)
    def get_disk_states(self):
        return self.disk_states
    def set_disk_states(self, disk_states):
        self.disk_states = disk_states
    disk_statesProp = property(get_disk_states, set_disk_states)
    def get_host_nic_states(self):
        return self.host_nic_states
    def set_host_nic_states(self, host_nic_states):
        self.host_nic_states = host_nic_states
    host_nic_statesProp = property(get_host_nic_states, set_host_nic_states)
    def get_data_center_states(self):
        return self.data_center_states
    def set_data_center_states(self, data_center_states):
        self.data_center_states = data_center_states
    data_center_statesProp = property(get_data_center_states, set_data_center_states)
    def get_vm_device_types(self):
        return self.vm_device_types
    def set_vm_device_types(self, vm_device_types):
        self.vm_device_types = vm_device_types
    vm_device_typesProp = property(get_vm_device_types, set_vm_device_types)
    def get_permits(self):
        return self.permits
    def set_permits(self, permits):
        self.permits = permits
    permitsProp = property(get_permits, set_permits)
    def get_scheduling_policies(self):
        return self.scheduling_policies
    def set_scheduling_policies(self, scheduling_policies):
        self.scheduling_policies = scheduling_policies
    scheduling_policiesProp = property(get_scheduling_policies, set_scheduling_policies)
    def get_usages(self):
        return self.usages
    def set_usages(self, usages):
        self.usages = usages
    usagesProp = property(get_usages, set_usages)
    def get_nfs_versions(self):
        return self.nfs_versions
    def set_nfs_versions(self, nfs_versions):
        self.nfs_versions = nfs_versions
    nfs_versionsProp = property(get_nfs_versions, set_nfs_versions)
    def get_pm_proxy_types(self):
        return self.pm_proxy_types
    def set_pm_proxy_types(self, pm_proxy_types):
        self.pm_proxy_types = pm_proxy_types
    pm_proxy_typesProp = property(get_pm_proxy_types, set_pm_proxy_types)
    def get_cpu_modes(self):
        return self.cpu_modes
    def set_cpu_modes(self, cpu_modes):
        self.cpu_modes = cpu_modes
    cpu_modesProp = property(get_cpu_modes, set_cpu_modes)
    def get_sgio_options(self):
        return self.sgio_options
    def set_sgio_options(self, sgio_options):
        self.sgio_options = sgio_options
    sgio_optionsProp = property(get_sgio_options, set_sgio_options)
    def get_watchdog_models(self):
        return self.watchdog_models
    def set_watchdog_models(self, watchdog_models):
        self.watchdog_models = watchdog_models
    watchdog_modelsProp = property(get_watchdog_models, set_watchdog_models)
    def get_watchdog_actions(self):
        return self.watchdog_actions
    def set_watchdog_actions(self, watchdog_actions):
        self.watchdog_actions = watchdog_actions
    watchdog_actionsProp = property(get_watchdog_actions, set_watchdog_actions)
    def get_authentication_methods(self):
        return self.authentication_methods
    def set_authentication_methods(self, authentication_methods):
        self.authentication_methods = authentication_methods
    authentication_methodsProp = property(get_authentication_methods, set_authentication_methods)
    def get_kdump_states(self):
        return self.kdump_states
    def set_kdump_states(self, kdump_states):
        self.kdump_states = kdump_states
    kdump_statesProp = property(get_kdump_states, set_kdump_states)
    def get_spm_states(self):
        return self.spm_states
    def set_spm_states(self, spm_states):
        self.spm_states = spm_states
    spm_statesProp = property(get_spm_states, set_spm_states)
    def get_vm_pool_types(self):
        return self.vm_pool_types
    def set_vm_pool_types(self, vm_pool_types):
        self.vm_pool_types = vm_pool_types
    vm_pool_typesProp = property(get_vm_pool_types, set_vm_pool_types)
    def get_step_types(self):
        return self.step_types
    def set_step_types(self, step_types):
        self.step_types = step_types
    step_typesProp = property(get_step_types, set_step_types)
    def get_payload_encodings(self):
        return self.payload_encodings
    def set_payload_encodings(self, payload_encodings):
        self.payload_encodings = payload_encodings
    payload_encodingsProp = property(get_payload_encodings, set_payload_encodings)
    def get_gluster_volume_types(self):
        return self.gluster_volume_types
    def set_gluster_volume_types(self, gluster_volume_types):
        self.gluster_volume_types = gluster_volume_types
    gluster_volume_typesProp = property(get_gluster_volume_types, set_gluster_volume_types)
    def get_transport_types(self):
        return self.transport_types
    def set_transport_types(self, transport_types):
        self.transport_types = transport_types
    transport_typesProp = property(get_transport_types, set_transport_types)
    def get_gluster_volume_states(self):
        return self.gluster_volume_states
    def set_gluster_volume_states(self, gluster_volume_states):
        self.gluster_volume_states = gluster_volume_states
    gluster_volume_statesProp = property(get_gluster_volume_states, set_gluster_volume_states)
    def get_brick_states(self):
        return self.brick_states
    def set_brick_states(self, brick_states):
        self.brick_states = brick_states
    brick_statesProp = property(get_brick_states, set_brick_states)
    def get_reported_device_types(self):
        return self.reported_device_types
    def set_reported_device_types(self, reported_device_types):
        self.reported_device_types = reported_device_types
    reported_device_typesProp = property(get_reported_device_types, set_reported_device_types)
    def get_ip_versions(self):
        return self.ip_versions
    def set_ip_versions(self, ip_versions):
        self.ip_versions = ip_versions
    ip_versionsProp = property(get_ip_versions, set_ip_versions)
    def get_snapshot_statuses(self):
        return self.snapshot_statuses
    def set_snapshot_statuses(self, snapshot_statuses):
        self.snapshot_statuses = snapshot_statuses
    snapshot_statusesProp = property(get_snapshot_statuses, set_snapshot_statuses)
    def get_content_types(self):
        return self.content_types
    def set_content_types(self, content_types):
        self.content_types = content_types
    content_typesProp = property(get_content_types, set_content_types)
    def get_hook_states(self):
        return self.hook_states
    def set_hook_states(self, hook_states):
        self.hook_states = hook_states
    hook_statesProp = property(get_hook_states, set_hook_states)
    def get_stages(self):
        return self.stages
    def set_stages(self, stages):
        self.stages = stages
    stagesProp = property(get_stages, set_stages)
    def get_sso_methods(self):
        return self.sso_methods
    def set_sso_methods(self, sso_methods):
        self.sso_methods = sso_methods
    sso_methodsProp = property(get_sso_methods, set_sso_methods)
    def get_architecture_capabilities(self):
        return self.architecture_capabilities
    def set_architecture_capabilities(self, architecture_capabilities):
        self.architecture_capabilities = architecture_capabilities
    architecture_capabilitiesProp = property(get_architecture_capabilities, set_architecture_capabilities)
    def get_serial_number_policies(self):
        return self.serial_number_policies
    def set_serial_number_policies(self, serial_number_policies):
        self.serial_number_policies = serial_number_policies
    serial_number_policiesProp = property(get_serial_number_policies, set_serial_number_policies)
    def get_selinux_modes(self):
        return self.selinux_modes
    def set_selinux_modes(self, selinux_modes):
        self.selinux_modes = selinux_modes
    selinux_modesProp = property(get_selinux_modes, set_selinux_modes)
    def get_rng_sources(self):
        return self.rng_sources
    def set_rng_sources(self, rng_sources):
        self.rng_sources = rng_sources
    rng_sourcesProp = property(get_rng_sources, set_rng_sources)
    def get_scheduling_policy_unit_types(self):
        return self.scheduling_policy_unit_types
    def set_scheduling_policy_unit_types(self, scheduling_policy_unit_types):
        self.scheduling_policy_unit_types = scheduling_policy_unit_types
    scheduling_policy_unit_typesProp = property(get_scheduling_policy_unit_types, set_scheduling_policy_unit_types)
    def get_qos_types(self):
        return self.qos_types
    def set_qos_types(self, qos_types):
        self.qos_types = qos_types
    qos_typesProp = property(get_qos_types, set_qos_types)
    def get_inheritable_booleans(self):
        return self.inheritable_booleans
    def set_inheritable_booleans(self, inheritable_booleans):
        self.inheritable_booleans = inheritable_booleans
    inheritable_booleansProp = property(get_inheritable_booleans, set_inheritable_booleans)
    def get_network_plugin_types(self):
        return self.network_plugin_types
    def set_network_plugin_types(self, network_plugin_types):
        self.network_plugin_types = network_plugin_types
    network_plugin_typesProp = property(get_network_plugin_types, set_network_plugin_types)
    def get_message_broker_types(self):
        return self.message_broker_types
    def set_message_broker_types(self, message_broker_types):
        self.message_broker_types = message_broker_types
    message_broker_typesProp = property(get_message_broker_types, set_message_broker_types)
    def get_display_disconnect_actions(self):
        return self.display_disconnect_actions
    def set_display_disconnect_actions(self, display_disconnect_actions):
        self.display_disconnect_actions = display_disconnect_actions
    display_disconnect_actionsProp = property(get_display_disconnect_actions, set_display_disconnect_actions)
    def get_quota_mode_types(self):
        return self.quota_mode_types
    def set_quota_mode_types(self, quota_mode_types):
        self.quota_mode_types = quota_mode_types
    quota_mode_typesProp = property(get_quota_mode_types, set_quota_mode_types)
    def hasContent_(self):
        if (
            self.current is not None or
            self.features is not None or
            self.cpus is not None or
            self.power_managers is not None or
            self.fence_types is not None or
            self.storage_types is not None or
            self.configuration_types is not None or
            self.storage_domain_types is not None or
            self.vm_types is not None or
            self.boot_devices is not None or
            self.display_types is not None or
            self.nic_interfaces is not None or
            self.os_types is not None or
            self.disk_formats is not None or
            self.graphics_types is not None or
            self.disk_storage_types is not None or
            self.disk_interfaces is not None or
            self.vm_affinities is not None or
            self.custom_properties is not None or
            self.boot_protocols is not None or
            self.error_handling is not None or
            self.storage_formats is not None or
            self.creation_states is not None or
            self.power_management_states is not None or
            self.host_states is not None or
            self.external_statuses is not None or
            self.host_protocols is not None or
            self.host_non_operational_details is not None or
            self.network_states is not None or
            self.storage_domain_states is not None or
            self.template_states is not None or
            self.vm_states is not None or
            self.vm_pause_details is not None or
            self.disk_states is not None or
            self.host_nic_states is not None or
            self.data_center_states is not None or
            self.vm_device_types is not None or
            self.permits is not None or
            self.scheduling_policies is not None or
            self.usages is not None or
            self.nfs_versions is not None or
            self.pm_proxy_types is not None or
            self.cpu_modes is not None or
            self.sgio_options is not None or
            self.watchdog_models is not None or
            self.watchdog_actions is not None or
            self.authentication_methods is not None or
            self.kdump_states is not None or
            self.spm_states is not None or
            self.vm_pool_types is not None or
            self.step_types is not None or
            self.payload_encodings is not None or
            self.gluster_volume_types is not None or
            self.transport_types is not None or
            self.gluster_volume_states is not None or
            self.brick_states is not None or
            self.reported_device_types is not None or
            self.ip_versions is not None or
            self.snapshot_statuses is not None or
            self.content_types is not None or
            self.hook_states is not None or
            self.stages is not None or
            self.sso_methods is not None or
            self.architecture_capabilities is not None or
            self.serial_number_policies is not None or
            self.selinux_modes is not None or
            self.rng_sources is not None or
            self.scheduling_policy_unit_types is not None or
            self.qos_types is not None or
            self.inheritable_booleans is not None or
            self.network_plugin_types is not None or
            self.message_broker_types is not None or
            self.display_disconnect_actions is not None or
            self.quota_mode_types is not None or
            super(VersionCaps, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', name_='version', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('version')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, name_='version', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='version'):
        super(VersionCaps, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='version')
    def exportChildren(self, outfile, level, namespaceprefix_='', name_='version', fromsubclass_=False, pretty_print=True):
        super(VersionCaps, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.current is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrent>%s</%scurrent>%s' % (namespaceprefix_ , self.gds_format_boolean(self.current, input_name='current'), namespaceprefix_ , eol_))
        if self.features is not None:
            self.features.export(outfile, level, namespaceprefix_, name_='features', pretty_print=pretty_print)
        if self.cpus is not None:
            self.cpus.export(outfile, level, namespaceprefix_, name_='cpus', pretty_print=pretty_print)
        if self.power_managers is not None:
            self.power_managers.export(outfile, level, namespaceprefix_, name_='power_managers', pretty_print=pretty_print)
        if self.fence_types is not None:
            self.fence_types.export(outfile, level, namespaceprefix_, name_='fence_types', pretty_print=pretty_print)
        if self.storage_types is not None:
            self.storage_types.export(outfile, level, namespaceprefix_, name_='storage_types', pretty_print=pretty_print)
        if self.configuration_types is not None:
            self.configuration_types.export(outfile, level, namespaceprefix_, name_='configuration_types', pretty_print=pretty_print)
        if self.storage_domain_types is not None:
            self.storage_domain_types.export(outfile, level, namespaceprefix_, name_='storage_domain_types', pretty_print=pretty_print)
        if self.vm_types is not None:
            self.vm_types.export(outfile, level, namespaceprefix_, name_='vm_types', pretty_print=pretty_print)
        if self.boot_devices is not None:
            self.boot_devices.export(outfile, level, namespaceprefix_, name_='boot_devices', pretty_print=pretty_print)
        if self.display_types is not None:
            self.display_types.export(outfile, level, namespaceprefix_, name_='display_types', pretty_print=pretty_print)
        if self.nic_interfaces is not None:
            self.nic_interfaces.export(outfile, level, namespaceprefix_, name_='nic_interfaces', pretty_print=pretty_print)
        if self.os_types is not None:
            self.os_types.export(outfile, level, namespaceprefix_, name_='os_types', pretty_print=pretty_print)
        if self.disk_formats is not None:
            self.disk_formats.export(outfile, level, namespaceprefix_, name_='disk_formats', pretty_print=pretty_print)
        if self.graphics_types is not None:
            self.graphics_types.export(outfile, level, namespaceprefix_, name_='graphics_types', pretty_print=pretty_print)
        if self.disk_storage_types is not None:
            self.disk_storage_types.export(outfile, level, namespaceprefix_, name_='disk_storage_types', pretty_print=pretty_print)
        if self.disk_interfaces is not None:
            self.disk_interfaces.export(outfile, level, namespaceprefix_, name_='disk_interfaces', pretty_print=pretty_print)
        if self.vm_affinities is not None:
            self.vm_affinities.export(outfile, level, namespaceprefix_, name_='vm_affinities', pretty_print=pretty_print)
        if self.custom_properties is not None:
            self.custom_properties.export(outfile, level, namespaceprefix_, name_='custom_properties', pretty_print=pretty_print)
        if self.boot_protocols is not None:
            self.boot_protocols.export(outfile, level, namespaceprefix_, name_='boot_protocols', pretty_print=pretty_print)
        if self.error_handling is not None:
            self.error_handling.export(outfile, level, namespaceprefix_, name_='error_handling', pretty_print=pretty_print)
        if self.storage_formats is not None:
            self.storage_formats.export(outfile, level, namespaceprefix_, name_='storage_formats', pretty_print=pretty_print)
        if self.creation_states is not None:
            self.creation_states.export(outfile, level, namespaceprefix_, name_='creation_states', pretty_print=pretty_print)
        if self.power_management_states is not None:
            self.power_management_states.export(outfile, level, namespaceprefix_, name_='power_management_states', pretty_print=pretty_print)
        if self.host_states is not None:
            self.host_states.export(outfile, level, namespaceprefix_, name_='host_states', pretty_print=pretty_print)
        if self.external_statuses is not None:
            self.external_statuses.export(outfile, level, namespaceprefix_, name_='external_statuses', pretty_print=pretty_print)
        if self.host_protocols is not None:
            self.host_protocols.export(outfile, level, namespaceprefix_, name_='host_protocols', pretty_print=pretty_print)
        if self.host_non_operational_details is not None:
            self.host_non_operational_details.export(outfile, level, namespaceprefix_, name_='host_non_operational_details', pretty_print=pretty_print)
        if self.network_states is not None:
            self.network_states.export(outfile, level, namespaceprefix_, name_='network_states', pretty_print=pretty_print)
        if self.storage_domain_states is not None:
            self.storage_domain_states.export(outfile, level, namespaceprefix_, name_='storage_domain_states', pretty_print=pretty_print)
        if self.template_states is not None:
            self.template_states.export(outfile, level, namespaceprefix_, name_='template_states', pretty_print=pretty_print)
        if self.vm_states is not None:
            self.vm_states.export(outfile, level, namespaceprefix_, name_='vm_states', pretty_print=pretty_print)
        if self.vm_pause_details is not None:
            self.vm_pause_details.export(outfile, level, namespaceprefix_, name_='vm_pause_details', pretty_print=pretty_print)
        if self.disk_states is not None:
            self.disk_states.export(outfile, level, namespaceprefix_, name_='disk_states', pretty_print=pretty_print)
        if self.host_nic_states is not None:
            self.host_nic_states.export(outfile, level, namespaceprefix_, name_='host_nic_states', pretty_print=pretty_print)
        if self.data_center_states is not None:
            self.data_center_states.export(outfile, level, namespaceprefix_, name_='data_center_states', pretty_print=pretty_print)
        if self.vm_device_types is not None:
            self.vm_device_types.export(outfile, level, namespaceprefix_, name_='vm_device_types', pretty_print=pretty_print)
        if self.permits is not None:
            self.permits.export(outfile, level, namespaceprefix_, name_='permits', pretty_print=pretty_print)
        if self.scheduling_policies is not None:
            self.scheduling_policies.export(outfile, level, namespaceprefix_, name_='scheduling_policies', pretty_print=pretty_print)
        if self.usages is not None:
            self.usages.export(outfile, level, namespaceprefix_, name_='usages', pretty_print=pretty_print)
        if self.nfs_versions is not None:
            self.nfs_versions.export(outfile, level, namespaceprefix_, name_='nfs_versions', pretty_print=pretty_print)
        if self.pm_proxy_types is not None:
            self.pm_proxy_types.export(outfile, level, namespaceprefix_, name_='pm_proxy_types', pretty_print=pretty_print)
        if self.cpu_modes is not None:
            self.cpu_modes.export(outfile, level, namespaceprefix_, name_='cpu_modes', pretty_print=pretty_print)
        if self.sgio_options is not None:
            self.sgio_options.export(outfile, level, namespaceprefix_, name_='sgio_options', pretty_print=pretty_print)
        if self.watchdog_models is not None:
            self.watchdog_models.export(outfile, level, namespaceprefix_, name_='watchdog_models', pretty_print=pretty_print)
        if self.watchdog_actions is not None:
            self.watchdog_actions.export(outfile, level, namespaceprefix_, name_='watchdog_actions', pretty_print=pretty_print)
        if self.authentication_methods is not None:
            self.authentication_methods.export(outfile, level, namespaceprefix_, name_='authentication_methods', pretty_print=pretty_print)
        if self.kdump_states is not None:
            self.kdump_states.export(outfile, level, namespaceprefix_, name_='kdump_states', pretty_print=pretty_print)
        if self.spm_states is not None:
            self.spm_states.export(outfile, level, namespaceprefix_, name_='spm_states', pretty_print=pretty_print)
        if self.vm_pool_types is not None:
            self.vm_pool_types.export(outfile, level, namespaceprefix_, name_='vm_pool_types', pretty_print=pretty_print)
        if self.step_types is not None:
            self.step_types.export(outfile, level, namespaceprefix_, name_='step_types', pretty_print=pretty_print)
        if self.payload_encodings is not None:
            self.payload_encodings.export(outfile, level, namespaceprefix_, name_='payload_encodings', pretty_print=pretty_print)
        if self.gluster_volume_types is not None:
            self.gluster_volume_types.export(outfile, level, namespaceprefix_, name_='gluster_volume_types', pretty_print=pretty_print)
        if self.transport_types is not None:
            self.transport_types.export(outfile, level, namespaceprefix_, name_='transport_types', pretty_print=pretty_print)
        if self.gluster_volume_states is not None:
            self.gluster_volume_states.export(outfile, level, namespaceprefix_, name_='gluster_volume_states', pretty_print=pretty_print)
        if self.brick_states is not None:
            self.brick_states.export(outfile, level, namespaceprefix_, name_='brick_states', pretty_print=pretty_print)
        if self.reported_device_types is not None:
            self.reported_device_types.export(outfile, level, namespaceprefix_, name_='reported_device_types', pretty_print=pretty_print)
        if self.ip_versions is not None:
            self.ip_versions.export(outfile, level, namespaceprefix_, name_='ip_versions', pretty_print=pretty_print)
        if self.snapshot_statuses is not None:
            self.snapshot_statuses.export(outfile, level, namespaceprefix_, name_='snapshot_statuses', pretty_print=pretty_print)
        if self.content_types is not None:
            self.content_types.export(outfile, level, namespaceprefix_, name_='content_types', pretty_print=pretty_print)
        if self.hook_states is not None:
            self.hook_states.export(outfile, level, namespaceprefix_, name_='hook_states', pretty_print=pretty_print)
        if self.stages is not None:
            self.stages.export(outfile, level, namespaceprefix_, name_='stages', pretty_print=pretty_print)
        if self.sso_methods is not None:
            self.sso_methods.export(outfile, level, namespaceprefix_, name_='sso_methods', pretty_print=pretty_print)
        if self.architecture_capabilities is not None:
            self.architecture_capabilities.export(outfile, level, namespaceprefix_, name_='architecture_capabilities', pretty_print=pretty_print)
        if self.serial_number_policies is not None:
            self.serial_number_policies.export(outfile, level, namespaceprefix_, name_='serial_number_policies', pretty_print=pretty_print)
        if self.selinux_modes is not None:
            self.selinux_modes.export(outfile, level, namespaceprefix_, name_='selinux_modes', pretty_print=pretty_print)
        if self.rng_sources is not None:
            self.rng_sources.export(outfile, level, namespaceprefix_, name_='rng_sources', pretty_print=pretty_print)
        if self.scheduling_policy_unit_types is not None:
            self.scheduling_policy_unit_types.export(outfile, level, namespaceprefix_, name_='scheduling_policy_unit_types', pretty_print=pretty_print)
        if self.qos_types is not None:
            self.qos_types.export(outfile, level, namespaceprefix_, name_='qos_types', pretty_print=pretty_print)
        if self.inheritable_booleans is not None:
            self.inheritable_booleans.export(outfile, level, namespaceprefix_, name_='inheritable_booleans', pretty_print=pretty_print)
        if self.network_plugin_types is not None:
            self.network_plugin_types.export(outfile, level, namespaceprefix_, name_='network_plugin_types', pretty_print=pretty_print)
        if self.message_broker_types is not None:
            self.message_broker_types.export(outfile, level, namespaceprefix_, name_='message_broker_types', pretty_print=pretty_print)
        if self.display_disconnect_actions is not None:
            self.display_disconnect_actions.export(outfile, level, namespaceprefix_, name_='display_disconnect_actions', pretty_print=pretty_print)
        if self.quota_mode_types is not None:
            self.quota_mode_types.export(outfile, level, namespaceprefix_, name_='quota_mode_types', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VersionCaps, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'current':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'current')
            self.current = ival_
        elif nodeName_ == 'features':
            obj_ = Features.factory(parent_object_=self)
            obj_.build(child_)
            self.features = obj_
            obj_.original_tagname_ = 'features'
        elif nodeName_ == 'cpus':
            obj_ = CPUs.factory(parent_object_=self)
            obj_.build(child_)
            self.cpus = obj_
            obj_.original_tagname_ = 'cpus'
        elif nodeName_ == 'power_managers':
            obj_ = PowerManagers.factory(parent_object_=self)
            obj_.build(child_)
            self.power_managers = obj_
            obj_.original_tagname_ = 'power_managers'
        elif nodeName_ == 'fence_types':
            obj_ = FenceTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.fence_types = obj_
            obj_.original_tagname_ = 'fence_types'
        elif nodeName_ == 'storage_types':
            obj_ = StorageTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_types = obj_
            obj_.original_tagname_ = 'storage_types'
        elif nodeName_ == 'configuration_types':
            obj_ = ConfigurationTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.configuration_types = obj_
            obj_.original_tagname_ = 'configuration_types'
        elif nodeName_ == 'storage_domain_types':
            obj_ = StorageDomainTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain_types = obj_
            obj_.original_tagname_ = 'storage_domain_types'
        elif nodeName_ == 'vm_types':
            obj_ = VmTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_types = obj_
            obj_.original_tagname_ = 'vm_types'
        elif nodeName_ == 'boot_devices':
            obj_ = BootDevices.factory(parent_object_=self)
            obj_.build(child_)
            self.boot_devices = obj_
            obj_.original_tagname_ = 'boot_devices'
        elif nodeName_ == 'display_types':
            obj_ = DisplayTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.display_types = obj_
            obj_.original_tagname_ = 'display_types'
        elif nodeName_ == 'nic_interfaces':
            obj_ = NicInterfaces.factory(parent_object_=self)
            obj_.build(child_)
            self.nic_interfaces = obj_
            obj_.original_tagname_ = 'nic_interfaces'
        elif nodeName_ == 'os_types':
            obj_ = OsTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.os_types = obj_
            obj_.original_tagname_ = 'os_types'
        elif nodeName_ == 'disk_formats':
            obj_ = DiskFormats.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_formats = obj_
            obj_.original_tagname_ = 'disk_formats'
        elif nodeName_ == 'graphics_types':
            obj_ = GraphicsTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.graphics_types = obj_
            obj_.original_tagname_ = 'graphics_types'
        elif nodeName_ == 'disk_storage_types':
            obj_ = DiskStorageTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_storage_types = obj_
            obj_.original_tagname_ = 'disk_storage_types'
        elif nodeName_ == 'disk_interfaces':
            obj_ = DiskInterfaces.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_interfaces = obj_
            obj_.original_tagname_ = 'disk_interfaces'
        elif nodeName_ == 'vm_affinities':
            obj_ = VmAffinities.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_affinities = obj_
            obj_.original_tagname_ = 'vm_affinities'
        elif nodeName_ == 'custom_properties':
            obj_ = CustomProperties.factory(parent_object_=self)
            obj_.build(child_)
            self.custom_properties = obj_
            obj_.original_tagname_ = 'custom_properties'
        elif nodeName_ == 'boot_protocols':
            obj_ = BootProtocols.factory(parent_object_=self)
            obj_.build(child_)
            self.boot_protocols = obj_
            obj_.original_tagname_ = 'boot_protocols'
        elif nodeName_ == 'error_handling':
            obj_ = ErrorHandlingOptions.factory(parent_object_=self)
            obj_.build(child_)
            self.error_handling = obj_
            obj_.original_tagname_ = 'error_handling'
        elif nodeName_ == 'storage_formats':
            obj_ = StorageFormats.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_formats = obj_
            obj_.original_tagname_ = 'storage_formats'
        elif nodeName_ == 'creation_states':
            obj_ = CreationStates.factory(parent_object_=self)
            obj_.build(child_)
            self.creation_states = obj_
            obj_.original_tagname_ = 'creation_states'
        elif nodeName_ == 'power_management_states':
            obj_ = PowerManagementStates.factory(parent_object_=self)
            obj_.build(child_)
            self.power_management_states = obj_
            obj_.original_tagname_ = 'power_management_states'
        elif nodeName_ == 'host_states':
            obj_ = HostStates.factory(parent_object_=self)
            obj_.build(child_)
            self.host_states = obj_
            obj_.original_tagname_ = 'host_states'
        elif nodeName_ == 'external_statuses':
            obj_ = ExternalStatuses.factory(parent_object_=self)
            obj_.build(child_)
            self.external_statuses = obj_
            obj_.original_tagname_ = 'external_statuses'
        elif nodeName_ == 'host_protocols':
            obj_ = HostProtocols.factory(parent_object_=self)
            obj_.build(child_)
            self.host_protocols = obj_
            obj_.original_tagname_ = 'host_protocols'
        elif nodeName_ == 'host_non_operational_details':
            obj_ = HostNonOperationalDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.host_non_operational_details = obj_
            obj_.original_tagname_ = 'host_non_operational_details'
        elif nodeName_ == 'network_states':
            obj_ = NetworkStates.factory(parent_object_=self)
            obj_.build(child_)
            self.network_states = obj_
            obj_.original_tagname_ = 'network_states'
        elif nodeName_ == 'storage_domain_states':
            obj_ = StorageDomainStates.factory(parent_object_=self)
            obj_.build(child_)
            self.storage_domain_states = obj_
            obj_.original_tagname_ = 'storage_domain_states'
        elif nodeName_ == 'template_states':
            obj_ = TemplateStates.factory(parent_object_=self)
            obj_.build(child_)
            self.template_states = obj_
            obj_.original_tagname_ = 'template_states'
        elif nodeName_ == 'vm_states':
            obj_ = VmStates.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_states = obj_
            obj_.original_tagname_ = 'vm_states'
        elif nodeName_ == 'vm_pause_details':
            obj_ = VmPauseDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_pause_details = obj_
            obj_.original_tagname_ = 'vm_pause_details'
        elif nodeName_ == 'disk_states':
            obj_ = DiskStates.factory(parent_object_=self)
            obj_.build(child_)
            self.disk_states = obj_
            obj_.original_tagname_ = 'disk_states'
        elif nodeName_ == 'host_nic_states':
            obj_ = HostNICStates.factory(parent_object_=self)
            obj_.build(child_)
            self.host_nic_states = obj_
            obj_.original_tagname_ = 'host_nic_states'
        elif nodeName_ == 'data_center_states':
            obj_ = DataCenterStates.factory(parent_object_=self)
            obj_.build(child_)
            self.data_center_states = obj_
            obj_.original_tagname_ = 'data_center_states'
        elif nodeName_ == 'vm_device_types':
            obj_ = VmDeviceTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_device_types = obj_
            obj_.original_tagname_ = 'vm_device_types'
        elif nodeName_ == 'permits':
            obj_ = Permits.factory(parent_object_=self)
            obj_.build(child_)
            self.permits = obj_
            obj_.original_tagname_ = 'permits'
        elif nodeName_ == 'scheduling_policies':
            obj_ = SchedulingPolicies.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policies = obj_
            obj_.original_tagname_ = 'scheduling_policies'
        elif nodeName_ == 'usages':
            obj_ = Usages.factory(parent_object_=self)
            obj_.build(child_)
            self.usages = obj_
            obj_.original_tagname_ = 'usages'
        elif nodeName_ == 'nfs_versions':
            obj_ = NfsVersions.factory(parent_object_=self)
            obj_.build(child_)
            self.nfs_versions = obj_
            obj_.original_tagname_ = 'nfs_versions'
        elif nodeName_ == 'pm_proxy_types':
            obj_ = PmProxyTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.pm_proxy_types = obj_
            obj_.original_tagname_ = 'pm_proxy_types'
        elif nodeName_ == 'cpu_modes':
            obj_ = CpuModes.factory(parent_object_=self)
            obj_.build(child_)
            self.cpu_modes = obj_
            obj_.original_tagname_ = 'cpu_modes'
        elif nodeName_ == 'sgio_options':
            obj_ = ScsiGenericIoOptions.factory(parent_object_=self)
            obj_.build(child_)
            self.sgio_options = obj_
            obj_.original_tagname_ = 'sgio_options'
        elif nodeName_ == 'watchdog_models':
            obj_ = WatchdogModels.factory(parent_object_=self)
            obj_.build(child_)
            self.watchdog_models = obj_
            obj_.original_tagname_ = 'watchdog_models'
        elif nodeName_ == 'watchdog_actions':
            obj_ = WatchdogActions.factory(parent_object_=self)
            obj_.build(child_)
            self.watchdog_actions = obj_
            obj_.original_tagname_ = 'watchdog_actions'
        elif nodeName_ == 'authentication_methods':
            obj_ = AuthenticationMethod.factory(parent_object_=self)
            obj_.build(child_)
            self.authentication_methods = obj_
            obj_.original_tagname_ = 'authentication_methods'
        elif nodeName_ == 'kdump_states':
            obj_ = KdumpStates.factory(parent_object_=self)
            obj_.build(child_)
            self.kdump_states = obj_
            obj_.original_tagname_ = 'kdump_states'
        elif nodeName_ == 'spm_states':
            obj_ = SpmStates.factory(parent_object_=self)
            obj_.build(child_)
            self.spm_states = obj_
            obj_.original_tagname_ = 'spm_states'
        elif nodeName_ == 'vm_pool_types':
            obj_ = VmPoolTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.vm_pool_types = obj_
            obj_.original_tagname_ = 'vm_pool_types'
        elif nodeName_ == 'step_types':
            obj_ = StepTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.step_types = obj_
            obj_.original_tagname_ = 'step_types'
        elif nodeName_ == 'payload_encodings':
            obj_ = PayloadEncodings.factory(parent_object_=self)
            obj_.build(child_)
            self.payload_encodings = obj_
            obj_.original_tagname_ = 'payload_encodings'
        elif nodeName_ == 'gluster_volume_types':
            obj_ = GlusterVolumeTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_volume_types = obj_
            obj_.original_tagname_ = 'gluster_volume_types'
        elif nodeName_ == 'transport_types':
            obj_ = TransportTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.transport_types = obj_
            obj_.original_tagname_ = 'transport_types'
        elif nodeName_ == 'gluster_volume_states':
            obj_ = GlusterStates.factory(parent_object_=self)
            obj_.build(child_)
            self.gluster_volume_states = obj_
            obj_.original_tagname_ = 'gluster_volume_states'
        elif nodeName_ == 'brick_states':
            obj_ = GlusterStates.factory(parent_object_=self)
            obj_.build(child_)
            self.brick_states = obj_
            obj_.original_tagname_ = 'brick_states'
        elif nodeName_ == 'reported_device_types':
            obj_ = ReportedDeviceTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.reported_device_types = obj_
            obj_.original_tagname_ = 'reported_device_types'
        elif nodeName_ == 'ip_versions':
            obj_ = IpVersions.factory(parent_object_=self)
            obj_.build(child_)
            self.ip_versions = obj_
            obj_.original_tagname_ = 'ip_versions'
        elif nodeName_ == 'snapshot_statuses':
            obj_ = SnapshotStatuses.factory(parent_object_=self)
            obj_.build(child_)
            self.snapshot_statuses = obj_
            obj_.original_tagname_ = 'snapshot_statuses'
        elif nodeName_ == 'content_types':
            obj_ = ContentTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.content_types = obj_
            obj_.original_tagname_ = 'content_types'
        elif nodeName_ == 'hook_states':
            obj_ = HookStates.factory(parent_object_=self)
            obj_.build(child_)
            self.hook_states = obj_
            obj_.original_tagname_ = 'hook_states'
        elif nodeName_ == 'stages':
            obj_ = Stages.factory(parent_object_=self)
            obj_.build(child_)
            self.stages = obj_
            obj_.original_tagname_ = 'stages'
        elif nodeName_ == 'sso_methods':
            obj_ = SsoMethods.factory(parent_object_=self)
            obj_.build(child_)
            self.sso_methods = obj_
            obj_.original_tagname_ = 'sso_methods'
        elif nodeName_ == 'architecture_capabilities':
            obj_ = ArchitectureCapabilities.factory(parent_object_=self)
            obj_.build(child_)
            self.architecture_capabilities = obj_
            obj_.original_tagname_ = 'architecture_capabilities'
        elif nodeName_ == 'serial_number_policies':
            obj_ = SerialNumberPolicies.factory(parent_object_=self)
            obj_.build(child_)
            self.serial_number_policies = obj_
            obj_.original_tagname_ = 'serial_number_policies'
        elif nodeName_ == 'selinux_modes':
            obj_ = SELinuxModes.factory(parent_object_=self)
            obj_.build(child_)
            self.selinux_modes = obj_
            obj_.original_tagname_ = 'selinux_modes'
        elif nodeName_ == 'rng_sources':
            obj_ = RngSources.factory(parent_object_=self)
            obj_.build(child_)
            self.rng_sources = obj_
            obj_.original_tagname_ = 'rng_sources'
        elif nodeName_ == 'scheduling_policy_unit_types':
            obj_ = SchedulingPolicyUnitTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.scheduling_policy_unit_types = obj_
            obj_.original_tagname_ = 'scheduling_policy_unit_types'
        elif nodeName_ == 'qos_types':
            obj_ = QosTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.qos_types = obj_
            obj_.original_tagname_ = 'qos_types'
        elif nodeName_ == 'inheritable_booleans':
            obj_ = InheritableBooleans.factory(parent_object_=self)
            obj_.build(child_)
            self.inheritable_booleans = obj_
            obj_.original_tagname_ = 'inheritable_booleans'
        elif nodeName_ == 'network_plugin_types':
            obj_ = NetworkPluginTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.network_plugin_types = obj_
            obj_.original_tagname_ = 'network_plugin_types'
        elif nodeName_ == 'message_broker_types':
            obj_ = MessageBrokerTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.message_broker_types = obj_
            obj_.original_tagname_ = 'message_broker_types'
        elif nodeName_ == 'display_disconnect_actions':
            obj_ = DisplayDisconnectActions.factory(parent_object_=self)
            obj_.build(child_)
            self.display_disconnect_actions = obj_
            obj_.original_tagname_ = 'display_disconnect_actions'
        elif nodeName_ == 'quota_mode_types':
            obj_ = QuotaModeTypes.factory(parent_object_=self)
            obj_.build(child_)
            self.quota_mode_types = obj_
            obj_.original_tagname_ = 'quota_mode_types'
        super(VersionCaps, self).buildChildren(child_, node, nodeName_, True)
# end class VersionCaps


GDSClassesMapping = {
    'action': Action,
    'affinity_group': AffinityGroup,
    'affinity_groups': AffinityGroups,
    'agent': Agent,
    'agent_configuration': AgentConfiguration,
    'agents': Agents,
    'api': API,
    'application': Application,
    'applications': Applications,
    'architecture_capabilities': ArchitectureCapabilities,
    'architecture_capability': ArchitectureCapability,
    'authentication_methods': AuthenticationMethod,
    'authorized_key': AuthorizedKey,
    'authorized_keys': AuthorizedKeys,
    'balance': Balance,
    'balances': Balances,
    'block_statistic': BlockStatistic,
    'body': Body,
    'bonding': Bonding,
    'bookmark': Bookmark,
    'bookmarks': Bookmarks,
    'boot_devices': BootDevices,
    'boot_menu': BootMenu,
    'boot_protocols': BootProtocols,
    'brick': GlusterBrick,
    'brick_details': GlusterBrickAdvancedDetails,
    'brick_memoryinfo': GlusterBrickMemoryInfo,
    'brick_profile_detail': BrickProfileDetail,
    'brick_profile_details': BrickProfileDetails,
    'brick_states': GlusterStates,
    'bricks': GlusterBricks,
    'capabilities': Capabilities,
    'cdrom': CdRom,
    'cdroms': CdRoms,
    'certificate': Certificate,
    'certificates': Certificates,
    'cloud_init': CloudInit,
    'cluster': Cluster,
    'cluster_quota_limit': QuotaClusterLimit,
    'cluster_quota_limits': QuotaClusterLimits,
    'clusters': Clusters,
    'configuration': Configuration,
    'configuration_types': ConfigurationTypes,
    'console': Console,
    'content_types': ContentTypes,
    'core': Core,
    'cores': Cores,
    'cpu': CPU,
    'cpu_modes': CpuModes,
    'cpu_profile': CpuProfile,
    'cpu_profiles': CpuProfiles,
    'cpu_tune': CpuTune,
    'cpus': CPUs,
    'creation': Creation,
    'creation_states': CreationStates,
    'custom_properties': CustomProperties,
    'data_center': DataCenter,
    'data_center_states': DataCenterStates,
    'data_centers': DataCenters,
    'detailedLink': DetailedLink,
    'detailedLinks': DetailedLinks,
    'device_passthrough': HostDevicePassthrough,
    'disk': Disk,
    'disk_formats': DiskFormats,
    'disk_interfaces': DiskInterfaces,
    'disk_profile': DiskProfile,
    'disk_profiles': DiskProfiles,
    'disk_snapshot': DiskSnapshot,
    'disk_snapshots': DiskSnapshots,
    'disk_states': DiskStates,
    'disk_storage_types': DiskStorageTypes,
    'disks': Disks,
    'display': Display,
    'display_disconnect_actions': DisplayDisconnectActions,
    'display_types': DisplayTypes,
    'dns': DNS,
    'dns_servers': DnsServers,
    'domain': Domain,
    'domains': Domains,
    'entity_profile_detail': EntityProfileDetail,
    'error_handling': ErrorHandlingOptions,
    'event': Event,
    'events': Events,
    'external_compute_resource': ExternalComputeResource,
    'external_compute_resources': ExternalComputeResources,
    'external_discovered_host': ExternalDiscoveredHost,
    'external_discovered_hosts': ExternalDiscoveredHosts,
    'external_host': ExternalHost,
    'external_host_group': ExternalHostGroup,
    'external_host_groups': ExternalHostGroups,
    'external_host_provider': ExternalHostProvider,
    'external_host_providers': ExternalHostProviders,
    'external_hosts': ExternalHosts,
    'external_statuses': ExternalStatuses,
    'fault': Fault,
    'feature': Feature,
    'features': Features,
    'fence_types': FenceTypes,
    'fencing_policy': FencingPolicy,
    'file': File,
    'files': Files,
    'filter': Filter,
    'filters': Filters,
    'floppies': Floppies,
    'floppy': Floppy,
    'fop_statistic': FopStatistic,
    'general_metadata': GeneralMetadata,
    'gluster_client': GlusterClient,
    'gluster_clients': GlusterClients,
    'gluster_hook': GlusterHook,
    'gluster_hooks': GlusterHooks,
    'gluster_volume': GlusterVolume,
    'gluster_volume_states': GlusterStates,
    'gluster_volume_types': GlusterVolumeTypes,
    'gluster_volumes': GlusterVolumes,
    'graphics_console': GraphicsConsole,
    'graphics_consoles': GraphicsConsoles,
    'graphics_types': GraphicsTypes,
    'group': Group,
    'groups': Groups,
    'hardware_information': HardwareInformation,
    'header': Header,
    'headers': Headers,
    'hook': Hook,
    'hook_states': HookStates,
    'hooks': Hooks,
    'host': Host,
    'host_device': HostDevice,
    'host_devices': HostDevices,
    'host_nic': HostNIC,
    'host_nic_states': HostNICStates,
    'host_nic_virtual_functions_configuration': HostNicVirtualFunctionsConfiguration,
    'host_nics': HostNics,
    'host_non_operational_details': HostNonOperationalDetails,
    'host_numa_node': NumaNode,
    'host_numa_nodes': NumaNodes,
    'host_protocols': HostProtocols,
    'host_states': HostStates,
    'host_storage': HostStorage,
    'hosted_engine': HostedEngine,
    'hosts': Hosts,
    'icon': Icon,
    'icons': Icons,
    'image': Image,
    'images': Images,
    'inheritable_booleans': InheritableBooleans,
    'initialization': Initialization,
    'instance_type': InstanceType,
    'instance_types': InstanceTypes,
    'io': IO,
    'ip': IP,
    'ip_versions': IpVersions,
    'ips': IPs,
    'iscsi_bond': IscsiBond,
    'iscsi_bonds': IscsiBonds,
    'job': Job,
    'jobs': Jobs,
    'katello_errata': KatelloErrata,
    'katello_erratum': KatelloErratum,
    'kdump_states': KdumpStates,
    'keyValuePair': KeyValuePair,
    'ksm': KSM,
    'label': Label,
    'labels': Labels,
    'link': Link,
    'linkCapabilities': LinkCapabilities,
    'logical_unit': LogicalUnit,
    'logical_units': LogicalUnits,
    'mac': MAC,
    'mac_pool': MacPool,
    'mac_pools': MacPools,
    'memory_pool': GlusterMemoryPool,
    'memory_pools': GlusterMemoryPools,
    'message_broker_types': MessageBrokerTypes,
    'method': Method,
    'methods': Methods,
    'migration': MigrationOptions,
    'network': Network,
    'network_attachment': NetworkAttachment,
    'network_attachments': NetworkAttachments,
    'network_configuration': NetworkConfiguration,
    'network_plugin_types': NetworkPluginTypes,
    'network_states': NetworkStates,
    'networks': Networks,
    'nfs_profile_detail': NfsProfileDetail,
    'nfs_profile_details': NfsProfileDetails,
    'nfs_versions': NfsVersions,
    'nic': NIC,
    'nic_configuration': GuestNicConfiguration,
    'nic_configurations': GuestNicsConfiguration,
    'nic_interfaces': NicInterfaces,
    'nics': Nics,
    'numa_node_pin': NumaNodePin,
    'numa_node_pins': NumaNodePins,
    'openstack_image': OpenStackImage,
    'openstack_image_provider': OpenStackImageProvider,
    'openstack_image_providers': OpenStackImageProviders,
    'openstack_images': OpenStackImages,
    'openstack_network': OpenStackNetwork,
    'openstack_network_provider': OpenStackNetworkProvider,
    'openstack_network_providers': OpenStackNetworkProviders,
    'openstack_networks': OpenStackNetworks,
    'openstack_provider': OpenStackProvider,
    'openstack_subnet': OpenStackSubnet,
    'openstack_subnets': OpenStackSubnets,
    'openstack_volume_authentication_key': OpenstackVolumeAuthenticationKey,
    'openstack_volume_authentication_keys': OpenstackVolumeAuthenticationKeys,
    'openstack_volume_provider': OpenStackVolumeProvider,
    'openstack_volume_providers': OpenStackVolumeProviders,
    'openstack_volume_type': OpenStackVolumeType,
    'openstack_volume_types': OpenStackVolumeTypes,
    'operating_system': OperatingSystemInfo,
    'operating_systems': OperatingSystemInfos,
    'options': Options,
    'os_types': OsTypes,
    'package': Package,
    'packages': Packages,
    'parameter': Parameter,
    'parameters_set': ParametersSet,
    'payload': Payload,
    'payload_encodings': PayloadEncodings,
    'payloads': Payloads,
    'permission': Permission,
    'permissions': Permissions,
    'permit': Permit,
    'permits': Permits,
    'pm_proxies': PmProxies,
    'pm_proxy': PmProxy,
    'pm_proxy_types': PmProxyTypes,
    'port_mirroring': PortMirroring,
    'power_management': PowerManagement,
    'power_management_states': PowerManagementStates,
    'power_managers': PowerManagers,
    'preview_vms': PreviewVMs,
    'product': Product,
    'product_info': ProductInfo,
    'profile_detail': ProfileDetail,
    'properties': Properties,
    'property': Property,
    'qos': QoS,
    'qos_types': QosTypes,
    'qoss': QoSs,
    'quota': Quota,
    'quota_mode_types': QuotaModeTypes,
    'quotas': Quotas,
    'range': Range,
    'ranges': Ranges,
    'reported_device': ReportedDevice,
    'reported_device_types': ReportedDeviceTypes,
    'reported_devices': ReportedDevices,
    'request': Request,
    'response': Response,
    'rng_device': RngDevice,
    'rng_sources': RngSources,
    'role': Role,
    'roles': Roles,
    'rsdl': RSDL,
    'scheduling_policies': SchedulingPolicies,
    'scheduling_policy': SchedulingPolicy,
    'scheduling_policy_unit': SchedulingPolicyUnit,
    'scheduling_policy_unit_types': SchedulingPolicyUnitTypes,
    'scheduling_policy_units': SchedulingPolicyUnits,
    'schema': Schema,
    'selinux': SELinux,
    'selinux_modes': SELinuxModes,
    'serial_number': SerialNumber,
    'serial_number_policies': SerialNumberPolicies,
    'server_hook': GlusterServerHook,
    'server_hooks': GlusterServerHooks,
    'session': Session,
    'sessions': Sessions,
    'sgio_options': ScsiGenericIoOptions,
    'skip_if_connectivity_broken': SkipIfConnectivityBroken,
    'skip_if_sd_active': SkipIfSDActive,
    'slaves': Slaves,
    'snapshot': Snapshot,
    'snapshot_statuses': SnapshotStatuses,
    'snapshots': Snapshots,
    'special_objects': SpecialObjects,
    'spm': SPM,
    'spm_states': SpmStates,
    'ssh': SSH,
    'ssh_public_key': SSHPublicKey,
    'ssh_public_keys': SSHPublicKeys,
    'sso': Sso,
    'sso_methods': SsoMethods,
    'stages': Stages,
    'statistic': Statistic,
    'statistics': Statistics,
    'status': Status,
    'step': Step,
    'step_types': StepTypes,
    'steps': Steps,
    'storage': Storage,
    'storage_connection': StorageConnection,
    'storage_connection_extension': StorageConnectionExtension,
    'storage_connection_extensions': StorageConnectionExtensions,
    'storage_connections': StorageConnections,
    'storage_domain': StorageDomain,
    'storage_domain_states': StorageDomainStates,
    'storage_domain_types': StorageDomainTypes,
    'storage_domains': StorageDomains,
    'storage_formats': StorageFormats,
    'storage_manager': StorageManager,
    'storage_quota_limit': QuotaStorageLimit,
    'storage_quota_limits': QuotaStorageLimits,
    'storage_types': StorageTypes,
    'summary': ApiSummary,
    'system_version': Version,
    'tag': Tag,
    'tags': Tags,
    'template': Template,
    'template_states': TemplateStates,
    'templates': Templates,
    'transparent_hugepages': TransparentHugePages,
    'transport_types': TransportTypes,
    'unmanaged_network': UnmanagedNetwork,
    'unmanaged_networks': UnmanagedNetworks,
    'url': Url,
    'usage_message': UsageMessage,
    'usages': Usages,
    'usb': Usb,
    'user': User,
    'users': Users,
    'value': Value,
    'values': Values,
    'vcpu_pin': VCpuPin,
    'vendor': Vendor,
    'version': VersionCaps,
    'virtio_scsi': VirtIO_SCSI,
    'vlan': VLAN,
    'vm': VM,
    'vm_affinities': VmAffinities,
    'vm_device_types': VmDeviceTypes,
    'vm_numa_node': VirtualNumaNode,
    'vm_numa_nodes': VirtualNumaNodes,
    'vm_pause_details': VmPauseDetails,
    'vm_pool_types': VmPoolTypes,
    'vm_states': VmStates,
    'vm_types': VmTypes,
    'vmpool': VmPool,
    'vmpools': VmPools,
    'vms': VMs,
    'vnic_pass_through': VnicPassThrough,
    'vnic_profile': VnicProfile,
    'vnic_profiles': VnicProfiles,
    'volume_group': VolumeGroup,
    'volume_profile_details': GlusterVolumeProfileDetails,
    'watchdog': WatchDog,
    'watchdog_actions': WatchdogActions,
    'watchdog_models': WatchdogModels,
    'watchdogs': WatchDogs,
    'weight': Weight,
    'weights': Weights,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'KeyValuePair'
        rootClass = KeyValuePair
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'KeyValuePair'
        rootClass = KeyValuePair
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'KeyValuePair'
        rootClass = KeyValuePair
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'KeyValuePair'
        rootClass = KeyValuePair
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from types import *\n\n')
        sys.stdout.write('import types as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "API",
    "Action",
    "ActionableResource",
    "Actions",
    "AffinityGroup",
    "AffinityGroups",
    "Agent",
    "AgentConfiguration",
    "Agents",
    "ApiSummary",
    "Application",
    "Applications",
    "ArchitectureCapabilities",
    "ArchitectureCapability",
    "AuthenticationMethod",
    "AuthorizedKey",
    "AuthorizedKeys",
    "Balance",
    "Balances",
    "BaseDevice",
    "BaseDevices",
    "BaseResource",
    "BaseResources",
    "Bios",
    "BlockStatistic",
    "Body",
    "Bonding",
    "Bookmark",
    "Bookmarks",
    "Boot",
    "BootDevices",
    "BootMenu",
    "BootProtocols",
    "BrickProfileDetail",
    "BrickProfileDetails",
    "CPU",
    "CPUs",
    "Capabilities",
    "CdRom",
    "CdRoms",
    "Certificate",
    "Certificates",
    "CloudInit",
    "Cluster",
    "Clusters",
    "Configuration",
    "ConfigurationTypes",
    "Console",
    "ContentTypes",
    "Core",
    "Cores",
    "CpuModes",
    "CpuProfile",
    "CpuProfiles",
    "CpuTopology",
    "CpuTune",
    "Creation",
    "CreationStates",
    "CustomProperties",
    "CustomProperty",
    "DNS",
    "DataCenter",
    "DataCenterStates",
    "DataCenters",
    "DetailedLink",
    "DetailedLinks",
    "Disk",
    "DiskFormats",
    "DiskInterfaces",
    "DiskProfile",
    "DiskProfiles",
    "DiskSnapshot",
    "DiskSnapshots",
    "DiskStates",
    "DiskStorageTypes",
    "Disks",
    "Display",
    "DisplayDisconnectActions",
    "DisplayTypes",
    "DnsServers",
    "Domain",
    "Domains",
    "EntityProfileDetail",
    "ErrorHandling",
    "ErrorHandlingOptions",
    "Event",
    "Events",
    "ExternalComputeResource",
    "ExternalComputeResources",
    "ExternalDiscoveredHost",
    "ExternalDiscoveredHosts",
    "ExternalHost",
    "ExternalHostGroup",
    "ExternalHostGroups",
    "ExternalHostProvider",
    "ExternalHostProviders",
    "ExternalHosts",
    "ExternalProvider",
    "ExternalStatuses",
    "Fault",
    "Feature",
    "Features",
    "FenceTypes",
    "FencingPolicy",
    "File",
    "Files",
    "Filter",
    "Filters",
    "Floppies",
    "Floppy",
    "FopStatistic",
    "GeneralMetadata",
    "GlusterBrick",
    "GlusterBrickAdvancedDetails",
    "GlusterBrickMemoryInfo",
    "GlusterBricks",
    "GlusterClient",
    "GlusterClients",
    "GlusterHook",
    "GlusterHooks",
    "GlusterMemoryPool",
    "GlusterMemoryPools",
    "GlusterServerHook",
    "GlusterServerHooks",
    "GlusterStates",
    "GlusterVolume",
    "GlusterVolumeProfileDetails",
    "GlusterVolumeTypes",
    "GlusterVolumes",
    "GracePeriod",
    "GraphicsConsole",
    "GraphicsConsoles",
    "GraphicsTypes",
    "Group",
    "Groups",
    "GuestInfo",
    "GuestNicConfiguration",
    "GuestNicsConfiguration",
    "GuestOperatingSystem",
    "HardwareInformation",
    "Header",
    "Headers",
    "HighAvailability",
    "Hook",
    "HookStates",
    "Hooks",
    "Host",
    "HostDevice",
    "HostDevicePassthrough",
    "HostDevices",
    "HostNIC",
    "HostNICStates",
    "HostNicVirtualFunctionsConfiguration",
    "HostNics",
    "HostNonOperationalDetails",
    "HostProtocols",
    "HostStates",
    "HostStorage",
    "HostedEngine",
    "Hosts",
    "IO",
    "IP",
    "IPs",
    "Icon",
    "Icons",
    "Image",
    "Images",
    "InheritableBooleans",
    "Initialization",
    "InstanceType",
    "InstanceTypes",
    "IpAddressAssignment",
    "IpAddressAssignments",
    "IpVersions",
    "IscsiBond",
    "IscsiBonds",
    "IscsiDetails",
    "Job",
    "Jobs",
    "KSM",
    "KatelloErrata",
    "KatelloErratum",
    "KdumpStates",
    "Kernel",
    "KeyValuePair",
    "Label",
    "Labels",
    "Link",
    "LinkCapabilities",
    "LogicalUnit",
    "LogicalUnits",
    "MAC",
    "MacPool",
    "MacPools",
    "MemoryOverCommit",
    "MemoryPolicy",
    "MessageBrokerTypes",
    "Method",
    "Methods",
    "MigrationOptions",
    "NIC",
    "Network",
    "NetworkAttachment",
    "NetworkAttachments",
    "NetworkConfiguration",
    "NetworkPluginTypes",
    "NetworkStates",
    "Networks",
    "NfsProfileDetail",
    "NfsProfileDetails",
    "NfsVersions",
    "NicInterfaces",
    "Nics",
    "NumaNode",
    "NumaNodePin",
    "NumaNodePins",
    "NumaNodes",
    "OpenStackImage",
    "OpenStackImageProvider",
    "OpenStackImageProviders",
    "OpenStackImages",
    "OpenStackNetwork",
    "OpenStackNetworkProvider",
    "OpenStackNetworkProviders",
    "OpenStackNetworks",
    "OpenStackProvider",
    "OpenStackSubnet",
    "OpenStackSubnets",
    "OpenStackVolumeProvider",
    "OpenStackVolumeProviders",
    "OpenStackVolumeType",
    "OpenStackVolumeTypes",
    "OpenstackVolumeAuthenticationKey",
    "OpenstackVolumeAuthenticationKeys",
    "OperatingSystem",
    "OperatingSystemInfo",
    "OperatingSystemInfos",
    "Option",
    "Options",
    "OsTypes",
    "Package",
    "Packages",
    "Parameter",
    "ParametersSet",
    "Payload",
    "PayloadEncodings",
    "Payloads",
    "Permission",
    "Permissions",
    "Permit",
    "Permits",
    "PmProxies",
    "PmProxy",
    "PmProxyTypes",
    "PortMirroring",
    "PowerManagement",
    "PowerManagementStates",
    "PowerManagers",
    "PreviewVMs",
    "Product",
    "ProductInfo",
    "ProfileDetail",
    "Properties",
    "Property",
    "ProxyTicket",
    "QoS",
    "QoSs",
    "QosTypes",
    "Quota",
    "QuotaClusterLimit",
    "QuotaClusterLimits",
    "QuotaModeTypes",
    "QuotaStorageLimit",
    "QuotaStorageLimits",
    "Quotas",
    "RSDL",
    "Range",
    "Ranges",
    "Rate",
    "ReportedConfiguration",
    "ReportedConfigurations",
    "ReportedDevice",
    "ReportedDeviceTypes",
    "ReportedDevices",
    "Request",
    "Response",
    "RngDevice",
    "RngSources",
    "Role",
    "Roles",
    "SELinux",
    "SELinuxModes",
    "SPM",
    "SSH",
    "SSHPublicKey",
    "SSHPublicKeys",
    "SchedulingPolicies",
    "SchedulingPolicy",
    "SchedulingPolicyThresholds",
    "SchedulingPolicyUnit",
    "SchedulingPolicyUnitTypes",
    "SchedulingPolicyUnits",
    "Schema",
    "ScsiGenericIoOptions",
    "SerialNumber",
    "SerialNumberPolicies",
    "Session",
    "Sessions",
    "SkipIfConnectivityBroken",
    "SkipIfSDActive",
    "Slaves",
    "Snapshot",
    "SnapshotStatuses",
    "Snapshots",
    "SpecialObjects",
    "SpmStates",
    "Sso",
    "SsoMethods",
    "Stages",
    "Statistic",
    "Statistics",
    "Status",
    "Step",
    "StepTypes",
    "Steps",
    "Storage",
    "StorageConnection",
    "StorageConnectionExtension",
    "StorageConnectionExtensions",
    "StorageConnections",
    "StorageDomain",
    "StorageDomainStates",
    "StorageDomainTypes",
    "StorageDomains",
    "StorageFormats",
    "StorageManager",
    "StorageTypes",
    "SupportedVersions",
    "Tag",
    "TagParent",
    "Tags",
    "Template",
    "TemplateStates",
    "TemplateVersion",
    "Templates",
    "Ticket",
    "TimeZone",
    "TransparentHugePages",
    "TransportTypes",
    "UnmanagedNetwork",
    "UnmanagedNetworks",
    "Url",
    "UsageMessage",
    "Usages",
    "Usb",
    "User",
    "Users",
    "VCpuPin",
    "VLAN",
    "VM",
    "VMs",
    "Value",
    "Values",
    "Vendor",
    "Version",
    "VersionCaps",
    "VirtIO_SCSI",
    "VirtualNumaNode",
    "VirtualNumaNodes",
    "VmAffinities",
    "VmBase",
    "VmDeviceTypes",
    "VmPauseDetails",
    "VmPlacementPolicy",
    "VmPool",
    "VmPoolTypes",
    "VmPools",
    "VmStates",
    "VmSummary",
    "VmTypes",
    "VnicPassThrough",
    "VnicProfile",
    "VnicProfiles",
    "VolumeGroup",
    "WatchDog",
    "WatchDogs",
    "WatchdogActions",
    "WatchdogModels",
    "Weight",
    "Weights"
]
